{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AquaCrop-OSPy","text":"<p>Soil-Crop-Water model based on AquaCrop-OS.</p> <p> </p> <pre><code>\nfrom aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent\nfrom aquacrop.utils import prepare_weather, get_filepath\n\n\nweather_file_path = get_filepath('tunis_climate.txt')\nmodel_os = AquaCropModel(\n            sim_start_time=f\"{1979}/10/01\",\n            sim_end_time=f\"{1985}/05/30\",\n            weather_df=prepare_weather(weather_file_path),\n            soil=Soil(soil_type='SandyLoam'),\n            crop=Crop('Wheat', planting_date='10/01'),\n            initial_water_content=InitialWaterContent(value=['FC']),\n        )\nmodel_os.run_model(till_termination=True)\nmodel_results = model_os.get_simulation_results().head()\nprint(model_results)\n</code></pre>"},{"location":"#about","title":"ABOUT","text":"<p>AquaCrop-OSPy is a python implementation of the popular crop-water model AquaCrop, built from the AquaCrop-OS source code.</p> <p>AquaCrop-OS, an open source version of FAO\u2019s multi-crop model, was released in August 2016 and is the result of collaboration between researchers at the University of Manchester, Water for Food Global Institute, U.N. Food and Agriculture Organization, and Imperial College London.</p> <p>AquaCrop-OSPy has been designed in way that users can conduct cutting edge research with only basic python experience. In particular for the design and testing of irrigation stratgeies.</p> <p>Open access journal article  here </p> <p>It is built upon the AquaCropOS crop-growth model written in Matlab ( paper ,  webpage ) which itself itself is based on the FAO AquaCrop model Webpage . Comparisons to both base models are shown  here. </p> <p>A forum  has also been created so that users of AquaCrop-OSPy and AquaCrop-OS can discuss research, bugs and future development.</p> <p>There is also an extensive documentation  for the model</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install aquacrop\n</code></pre>"},{"location":"core/","title":"core","text":""},{"location":"core/#aquacrop.core","title":"<code>aquacrop.core</code>","text":"<p>This file contains the AquacropModel class that runs the simulation.</p>"},{"location":"core/#aquacrop.core.AquaCropModel","title":"<code>AquaCropModel</code>","text":"<p>This is the main class of the AquaCrop-OSPy model. It is in charge of executing all the operations.</p> <p>Parameters:</p> <pre><code>sim_start_time (str): YYYY/MM/DD, Simulation start date\n\nsim_end_time (str): date YYYY/MM/DD, Simulation end date\n\nweather_df: daily weather data , created using prepare_weather\n\nsoil: Soil object contains paramaters and variables of the soil\n        used in the simulation\n\ncrop: Crop object contains Paramaters and variables of the crop used\n        in the simulation\n\ninitial_water_content: Defines water content at start of simulation\n\nirrigation_management: Defines irrigation strategy\n\nfield_management: Defines field management options\n\nfallow_field_management: Defines field management options during fallow period\n\ngroundwater: Stores information on water table parameters\n\nco2_concentration: Defines CO2 concentrations\n\noff_season: (True) simulate off-season or (False) skip ahead to start of \n            next growing season\n</code></pre> Source code in <code>aquacrop/core.py</code> <pre><code>class AquaCropModel:\n    \"\"\"\n    This is the main class of the AquaCrop-OSPy model.\n    It is in charge of executing all the operations.\n\n    Parameters:\n\n        sim_start_time (str): YYYY/MM/DD, Simulation start date\n\n        sim_end_time (str): date YYYY/MM/DD, Simulation end date\n\n        weather_df: daily weather data , created using prepare_weather\n\n        soil: Soil object contains paramaters and variables of the soil\n                used in the simulation\n\n        crop: Crop object contains Paramaters and variables of the crop used\n                in the simulation\n\n        initial_water_content: Defines water content at start of simulation\n\n        irrigation_management: Defines irrigation strategy\n\n        field_management: Defines field management options\n\n        fallow_field_management: Defines field management options during fallow period\n\n        groundwater: Stores information on water table parameters\n\n        co2_concentration: Defines CO2 concentrations\n\n        off_season: (True) simulate off-season or (False) skip ahead to start of \n                    next growing season\n\n\n    \"\"\"\n\n    # Model parameters\n    __steps_are_finished: bool = False  # True if all steps of the simulation are done.\n    __has_model_executed: bool = False  # Determines if the model has been run\n    __has_model_finished: bool = False  # Determines if the model is finished\n    __start_model_execution: float = 0.0  # Time when the execution start\n    __end_model_execution: float = 0.0  # Time when the execution end\n    # Attributes initialised later\n    _clock_struct: \"ClockStruct\"\n    _param_struct: \"ParamStruct\"\n    _init_cond: \"InitialCondition\"\n    _outputs: \"Output\"\n    _weather: \"DataFrame\"\n\n    def __init__(\n        self,\n        sim_start_time: str,\n        sim_end_time: str,\n        weather_df: \"DataFrame\",\n        soil: \"Soil\",\n        crop: \"Crop\",\n        initial_water_content: \"InitialWaterContent\",\n        irrigation_management: Optional[\"IrrigationManagement\"] = None,\n        field_management: Optional[\"FieldMngt\"] = None,\n        fallow_field_management: Optional[\"FieldMngt\"] = None,\n        groundwater: Optional[\"GroundWater\"] = None,\n        co2_concentration: Optional[\"CO2\"] = None,\n        off_season: bool=False,\n    ) -&gt; None:\n\n        self.sim_start_time = sim_start_time\n        self.sim_end_time = sim_end_time\n        self.weather_df = weather_df\n        self.soil = soil\n        self.crop = crop\n        self.initial_water_content = initial_water_content   \n        self.co2_concentration = co2_concentration\n        self.off_season = off_season\n\n        self.irrigation_management = irrigation_management\n        self.field_management = field_management\n        self.fallow_field_management = fallow_field_management\n        self.groundwater = groundwater\n\n        if irrigation_management is None:\n            self.irrigation_management = IrrigationManagement(irrigation_method=0)\n        if field_management is None:\n            self.field_management = FieldMngt()\n        if fallow_field_management is None:\n            self.fallow_field_management = FieldMngt()\n        if groundwater is None:\n            self.groundwater = GroundWater()\n        if co2_concentration is None:\n            self.co2_concentration = CO2()\n\n    @property\n    def sim_start_time(self) -&gt; str:\n        \"\"\"\n        Return sim start date\n        \"\"\"\n        return self._sim_start_time\n\n    @sim_start_time.setter\n    def sim_start_time(self, value: str) -&gt; None:\n        \"\"\"\n        Check if sim start date is in a correct format.\n        \"\"\"\n\n        if _sim_date_format_is_correct(value) is not False:\n            self._sim_start_time = value\n        else:\n            raise ValueError(\"sim_start_time format must be 'YYYY/MM/DD'\")\n\n    @property\n    def sim_end_time(self) -&gt; str:\n        \"\"\"\n        Return sim end date\n        \"\"\"\n        return self._sim_end_time\n\n    @sim_end_time.setter\n    def sim_end_time(self, value: str) -&gt; None:\n        \"\"\"\n        Check if sim end date is in a correct format.\n        \"\"\"\n        if _sim_date_format_is_correct(value) is not False:\n            self._sim_end_time = value\n        else:\n            raise ValueError(\"sim_end_time format must be 'YYYY/MM/DD'\")\n\n    @property\n    def weather_df(self) -&gt; \"DataFrame\":\n        \"\"\"\n        Return weather dataframe\n        \"\"\"\n        return self._weather_df\n\n    @weather_df.setter\n    def weather_df(self, value: \"DataFrame\"):\n        \"\"\"\n        Check if weather dataframe is in a correct format.\n        \"\"\"\n        weather_df_columns = \"Date MinTemp MaxTemp Precipitation ReferenceET\".split(\" \")\n        if not all([column in value for column in weather_df_columns]):\n            raise ValueError(\n                \"Error in weather_df format. Check if all the following columns exist \"\n                + \"(Date MinTemp MaxTemp Precipitation ReferenceET).\"\n            )\n\n        self._weather_df = value\n\n    def _initialize(self) -&gt; None:\n        \"\"\"\n        Initialise all model variables\n        \"\"\"\n\n        # Initialize ClockStruct object\n        self._clock_struct = read_clock_parameters(\n            self.sim_start_time, self.sim_end_time, self.off_season\n        )\n\n        # get _weather data\n        self.weather_df = read_weather_inputs(self._clock_struct, self.weather_df)\n\n        # read model params\n        self._clock_struct, self._param_struct = read_model_parameters(\n            self._clock_struct, self.soil, self.crop, self.weather_df\n        )\n\n        # read irrigation management\n        self._param_struct = read_irrigation_management(\n            self._param_struct, self.irrigation_management, self._clock_struct\n        )\n\n        # read field management\n        self._param_struct = read_field_management(\n            self._param_struct, self.field_management, self.fallow_field_management\n        )\n\n        # read groundwater table\n        self._param_struct = read_groundwater_table(\n            self._param_struct, self.groundwater, self._clock_struct\n        )\n\n        # Compute additional variables\n        self._param_struct.CO2 = self.co2_concentration\n        self._param_struct = compute_variables(\n            self._param_struct, self.weather_df, self._clock_struct\n        )\n\n        # read, calculate inital conditions\n        self._param_struct, self._init_cond = read_model_initial_conditions(\n            self._param_struct, self._clock_struct, self.initial_water_content, self.crop\n        )\n\n        self._param_struct = create_soil_profile(self._param_struct)\n\n        # Outputs results (water_flux, crop_growth, final_stats)\n        self._outputs = Output(self._clock_struct.time_span, self._init_cond.th)\n\n        # save model _weather to _init_cond\n        self._weather = self.weather_df.values\n\n    def run_model(\n        self,\n        num_steps: int = 1,\n        till_termination: bool = False,\n        initialize_model: bool = True,\n        process_outputs: bool = False,\n    ) -&gt; bool:\n        \"\"\"\n        This function is responsible for executing the model.\n\n        Arguments:\n\n            num_steps: Number of steps (Days) to be executed.\n\n            till_termination: Run the simulation to completion\n\n            initialize_model: Whether to initialize the model \\\n            (i.e., go back to beginning of season)\n\n            process_outputs: process outputs into dataframe before \\\n                simulation is finished\n\n        Returns:\n            True if finished\n        \"\"\"\n\n        if initialize_model:\n            self._initialize()\n\n        if till_termination:\n            self.__start_model_execution = time.time()\n            while self._clock_struct.model_is_finished is False:\n                (\n                    self._clock_struct,\n                    self._init_cond,\n                    self._param_struct,\n                    self._outputs,\n                ) = self._perform_timestep()\n            self.__end_model_execution = time.time()\n            self.__has_model_executed = True\n            self.__has_model_finished = True\n            return True\n        else:\n            if num_steps &lt; 1:\n                raise ValueError(\"num_steps must be equal to or greater than 1.\")\n            self.__start_model_execution = time.time()\n            for i in range(num_steps):\n\n                if (i == range(num_steps)[-1]) and (process_outputs is True):\n                    self.__steps_are_finished = True\n\n                (\n                    self._clock_struct,\n                    self._init_cond,\n                    self._param_struct,\n                    self._outputs,\n                ) = self._perform_timestep()\n\n                if self._clock_struct.model_is_finished:\n                    self.__end_model_execution = time.time()\n                    self.__has_model_executed = True\n                    self.__has_model_finished = True\n                    return True\n\n            self.__end_model_execution = time.time()\n            self.__has_model_executed = True\n            self.__has_model_finished = False\n            return True\n\n    def _perform_timestep(\n        self,\n    ) -&gt; Tuple[\"ClockStruct\", \"InitialCondition\", \"ParamStruct\", \"Output\"]:\n\n        \"\"\"\n        Function to run a single time-step (day) calculation of AquaCrop-OS\n        \"\"\"\n\n        # extract _weather data for current timestep\n        weather_step = _weather_data_current_timestep(\n            self._weather, self._clock_struct.time_step_counter\n        )\n\n        # Get model solution_single_time_step\n        new_cond, param_struct, outputs = solution_single_time_step(\n            self._init_cond,\n            self._param_struct,\n            self._clock_struct,\n            weather_step,\n            self._outputs,\n        )\n\n        # Check model termination\n        clock_struct = self._clock_struct\n        clock_struct.model_is_finished = check_model_is_finished(\n            self._clock_struct.step_end_time,\n            self._clock_struct.simulation_end_date,\n            self._clock_struct.model_is_finished,\n            self._clock_struct.season_counter,\n            self._clock_struct.n_seasons,\n            new_cond.harvest_flag,\n        )\n\n        # Update time step\n        clock_struct, _init_cond, param_struct = update_time(\n            clock_struct, new_cond, param_struct, self._weather, self.crop\n        )\n\n        # Create  _outputsdataframes when model is finished\n        final_water_flux_growth_outputs = outputs_when_model_is_finished(\n            clock_struct.model_is_finished,\n            outputs.water_flux,\n            outputs.water_storage,\n            outputs.crop_growth,\n            self.__steps_are_finished,\n        )\n\n        if final_water_flux_growth_outputs is not False:\n            (\n                outputs.water_flux,\n                outputs.water_storage,\n                outputs.crop_growth,\n            ) = final_water_flux_growth_outputs\n\n        return clock_struct, _init_cond, param_struct, outputs\n\n    def get_simulation_results(self):\n        \"\"\"\n        Return all the simulation results\n        \"\"\"\n        if self.__has_model_executed:\n            if self.__has_model_finished:\n                return self._outputs.final_stats\n            else:\n                return False  # If the model is not finished, the results are not generated.\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_water_storage(self):\n        \"\"\"\n        Return water storage in soil results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.water_storage\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_water_flux(self):\n        \"\"\"\n        Return water flux results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.water_flux\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_crop_growth(self):\n        \"\"\"\n        Return crop growth results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.crop_growth\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_additional_information(self) -&gt; Dict[str, Union[bool, float]]:\n        \"\"\"\n        Additional model information.\n\n        Returns:\n            dict: {has_model_finished,execution_time}\n\n        \"\"\"\n        if self.__has_model_executed:\n            return {\n                \"has_model_finished\": self.__has_model_finished,\n                \"execution_time\": self.__end_model_execution\n                - self.__start_model_execution,\n            }\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.sim_end_time","title":"<code>sim_end_time</code>  <code>property</code> <code>writable</code>","text":"<p>Return sim end date</p>"},{"location":"core/#aquacrop.core.AquaCropModel.sim_start_time","title":"<code>sim_start_time</code>  <code>property</code> <code>writable</code>","text":"<p>Return sim start date</p>"},{"location":"core/#aquacrop.core.AquaCropModel.weather_df","title":"<code>weather_df</code>  <code>property</code> <code>writable</code>","text":"<p>Return weather dataframe</p>"},{"location":"core/#aquacrop.core.AquaCropModel.get_additional_information","title":"<code>get_additional_information()</code>","text":"<p>Additional model information.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Union[bool, float]]</code> <p>{has_model_finished,execution_time}</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_additional_information(self) -&gt; Dict[str, Union[bool, float]]:\n    \"\"\"\n    Additional model information.\n\n    Returns:\n        dict: {has_model_finished,execution_time}\n\n    \"\"\"\n    if self.__has_model_executed:\n        return {\n            \"has_model_finished\": self.__has_model_finished,\n            \"execution_time\": self.__end_model_execution\n            - self.__start_model_execution,\n        }\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.get_crop_growth","title":"<code>get_crop_growth()</code>","text":"<p>Return crop growth results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_crop_growth(self):\n    \"\"\"\n    Return crop growth results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.crop_growth\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.get_simulation_results","title":"<code>get_simulation_results()</code>","text":"<p>Return all the simulation results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_simulation_results(self):\n    \"\"\"\n    Return all the simulation results\n    \"\"\"\n    if self.__has_model_executed:\n        if self.__has_model_finished:\n            return self._outputs.final_stats\n        else:\n            return False  # If the model is not finished, the results are not generated.\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.get_water_flux","title":"<code>get_water_flux()</code>","text":"<p>Return water flux results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_water_flux(self):\n    \"\"\"\n    Return water flux results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.water_flux\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.get_water_storage","title":"<code>get_water_storage()</code>","text":"<p>Return water storage in soil results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_water_storage(self):\n    \"\"\"\n    Return water storage in soil results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.water_storage\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"core/#aquacrop.core.AquaCropModel.run_model","title":"<code>run_model(num_steps=1, till_termination=False, initialize_model=True, process_outputs=False)</code>","text":"<p>This function is responsible for executing the model.</p> <p>Arguments:</p> <pre><code>num_steps: Number of steps (Days) to be executed.\n\ntill_termination: Run the simulation to completion\n\ninitialize_model: Whether to initialize the model             (i.e., go back to beginning of season)\n\nprocess_outputs: process outputs into dataframe before                 simulation is finished\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if finished</p> Source code in <code>aquacrop/core.py</code> <pre><code>def run_model(\n    self,\n    num_steps: int = 1,\n    till_termination: bool = False,\n    initialize_model: bool = True,\n    process_outputs: bool = False,\n) -&gt; bool:\n    \"\"\"\n    This function is responsible for executing the model.\n\n    Arguments:\n\n        num_steps: Number of steps (Days) to be executed.\n\n        till_termination: Run the simulation to completion\n\n        initialize_model: Whether to initialize the model \\\n        (i.e., go back to beginning of season)\n\n        process_outputs: process outputs into dataframe before \\\n            simulation is finished\n\n    Returns:\n        True if finished\n    \"\"\"\n\n    if initialize_model:\n        self._initialize()\n\n    if till_termination:\n        self.__start_model_execution = time.time()\n        while self._clock_struct.model_is_finished is False:\n            (\n                self._clock_struct,\n                self._init_cond,\n                self._param_struct,\n                self._outputs,\n            ) = self._perform_timestep()\n        self.__end_model_execution = time.time()\n        self.__has_model_executed = True\n        self.__has_model_finished = True\n        return True\n    else:\n        if num_steps &lt; 1:\n            raise ValueError(\"num_steps must be equal to or greater than 1.\")\n        self.__start_model_execution = time.time()\n        for i in range(num_steps):\n\n            if (i == range(num_steps)[-1]) and (process_outputs is True):\n                self.__steps_are_finished = True\n\n            (\n                self._clock_struct,\n                self._init_cond,\n                self._param_struct,\n                self._outputs,\n            ) = self._perform_timestep()\n\n            if self._clock_struct.model_is_finished:\n                self.__end_model_execution = time.time()\n                self.__has_model_executed = True\n                self.__has_model_finished = True\n                return True\n\n        self.__end_model_execution = time.time()\n        self.__has_model_executed = True\n        self.__has_model_finished = False\n        return True\n</code></pre>"},{"location":"core/#aquacrop.core.check_iwc_soil_match","title":"<code>check_iwc_soil_match(iwc_layers, soil_layers)</code>","text":"<p>This function checks if the number of soil layers is equivalent between the user-specified soil profile and initial water content.</p> Return <p>boolean: True if number of layers match</p> Source code in <code>aquacrop/core.py</code> <pre><code>def check_iwc_soil_match(iwc_layers: int, soil_layers: int) -&gt; bool:\n    \"\"\"\n    This function checks if the number of soil layers is equivalent between the user-specified soil profile and initial water content.\n\n    Arguments:\n        iwc_layers\n        soil_layers\n\n    Return:\n        boolean: True if number of layers match\n\n    \"\"\"\n    if(iwc_layers == soil_layers):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"entities/","title":"entities","text":""},{"location":"entities/#aquacrop.entities.clockStruct","title":"<code>aquacrop.entities.clockStruct</code>","text":"<p>Contains model information regarding dates and step times etc.</p>"},{"location":"entities/#aquacrop.entities.clockStruct.ClockStruct","title":"<code>ClockStruct</code>","text":"<p>Contains model information regarding dates and step times etc.</p> <p>Attributes:</p> <pre><code>time_step_counter (int): Keeps track of current timestep\n\nmodel_is_finished (Bool): False unless model has finished\n\nsimulation_start_date (np.Datetime64): Date of simulation start\n\nsimulation_end_date (np.Datetime64): Date of simulation end\n\ntime_step (int): time step (evaluation needed\n\nn_steps (int): total number of days of simulation\n\ntime_span (np.array): all dates that lie within the start and end dates of simulation\n\nstep_start_time (np.Datetime64): Date at start of timestep\n\nstep_end_time (np.Datetime64): Date at end of timestep\n\nevap_time_steps (int): Number of time-steps (per day) for soil evaporation calculation\n\nsim_off_season (str): 'Y' if you want to simulate the off season,'N' otherwise\n\nplanting_dates (list-like): list of planting dates in datetime format\n\nharvest_dates (list-like): list of harvest dates in datetime format\n\nn_seasons (int): Total number of seasons to be simulated\n\nseason_counter (int): counter to keep track of which season we are currenlty simulating\n</code></pre> Source code in <code>aquacrop/entities/clockStruct.py</code> <pre><code>class ClockStruct:\n    \"\"\"\n    Contains model information regarding dates and step times etc.\n\n    Attributes:\n\n        time_step_counter (int): Keeps track of current timestep\n\n        model_is_finished (Bool): False unless model has finished\n\n        simulation_start_date (np.Datetime64): Date of simulation start\n\n        simulation_end_date (np.Datetime64): Date of simulation end\n\n        time_step (int): time step (evaluation needed\n\n        n_steps (int): total number of days of simulation\n\n        time_span (np.array): all dates that lie within the start and end dates of simulation\n\n        step_start_time (np.Datetime64): Date at start of timestep\n\n        step_end_time (np.Datetime64): Date at end of timestep\n\n        evap_time_steps (int): Number of time-steps (per day) for soil evaporation calculation\n\n        sim_off_season (str): 'Y' if you want to simulate the off season,'N' otherwise\n\n        planting_dates (list-like): list of planting dates in datetime format\n\n        harvest_dates (list-like): list of harvest dates in datetime format\n\n        n_seasons (int): Total number of seasons to be simulated\n\n        season_counter (int): counter to keep track of which season we are currenlty simulating\n\n\n    \"\"\"\n\n    def __init__(self):\n\n        self.time_step_counter = 0  # Keeps track of current timestep\n        self.model_is_finished = False  # False unless model has finished\n        self.simulation_start_date = 0  # Date of simulation start\n        self.simulation_end_date = 0  # Date of simulation end\n        self.time_step = 0  # time step (evaluaiton needed)\n        self.n_steps = 0  # total number of days of simulation\n        self.time_span = (\n            0  # all dates that lie within the start and end dates of simulation\n        )\n        self.step_start_time = 0  # Date at start of timestep\n        self.step_end_time = 0  # Date at start of timestep\n        # Number of time-steps (per day) for soil evaporation calculation\n        self.evap_time_steps = 20\n        self.sim_off_season = (\n            \"N\"  # 'Yes' if you want to simulate the off season, 'N' otherwise\n        )\n        self.planting_dates = (\n            []\n        )  # list of crop planting dates during simulation\n        self.harvest_dates = []  # list of crop planting dates during simulation\n        self.n_seasons = 0  # total number of seasons (plant and harvest)\n        self.season_counter = -1  # running counter of seasons\n</code></pre>"},{"location":"entities/#aquacrop.entities.co2","title":"<code>aquacrop.entities.co2</code>","text":""},{"location":"entities/#aquacrop.entities.co2.CO2","title":"<code>CO2</code>","text":"<p>               Bases: <code>object</code></p> <p>Attributes:</p> <pre><code>ref_concentration (float): reference CO2 concentration\n\ncurrent_concentration (float): current CO2 concentration (initialize if constant_conc=True)\n\nconstant_conc (bool): use constant conc every season\n\nco2_data (DataFrame): CO2 timeseries (2 columns: 'year' and 'ppm')\n</code></pre> Source code in <code>aquacrop/entities/co2.py</code> <pre><code>class CO2(object):\n\n    \"\"\"\n\n    Attributes:\n\n        ref_concentration (float): reference CO2 concentration\n\n        current_concentration (float): current CO2 concentration (initialize if constant_conc=True)\n\n        constant_conc (bool): use constant conc every season\n\n        co2_data (DataFrame): CO2 timeseries (2 columns: 'year' and 'ppm')\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ref_concentration=369.41,\n        current_concentration=0.,\n        constant_conc=False,\n        co2_data=None,\n    ):\n        self.ref_concentration = ref_concentration\n        self.current_concentration = current_concentration\n        self.constant_conc = constant_conc\n        if co2_data is not None:\n            self.co2_data = co2_data\n        else:\n            self.co2_data = pd.read_csv(\n                    f\"{acfp}/data/MaunaLoaCO2.txt\",\n                    header=1,\n                    sep='\\s+',\n                    names=[\"year\", \"ppm\"],\n    )\n        self.co2_data_processed = None\n</code></pre>"},{"location":"entities/#aquacrop.entities.crop","title":"<code>aquacrop.entities.crop</code>","text":"<p>Crop class module</p>"},{"location":"entities/#aquacrop.entities.crop.Crop","title":"<code>Crop</code>","text":"<p>The Crop Class contains paramaters and variables of the crop used in the simulation</p> <p>Most Crop attributes can be found in the <code>crops.crop_params.py</code> file</p> <p>A number of default program properties of type float are also specified during initialisation</p> <pre><code>Initialization example:\n\ncrop = Crop('Maize', planting_date='05/01')\n</code></pre> <p>Attributes:</p> <pre><code>c_name (str): crop name ('custom' or one of built in defaults e.g. 'Maize')\n\nplanting_date (str): Planting Date (mm/dd)\n\nharvest_date (str): Latest Harvest Date (mm/dd)\n</code></pre> Source code in <code>aquacrop/entities/crop.py</code> <pre><code>class Crop:\n    \"\"\"\n    The Crop Class contains paramaters and variables of the crop used in the simulation\n\n    Most Crop attributes can be found in the `crops.crop_params.py` file\n\n    A number of default program properties of type float are also specified during initialisation\n\n    ```\n    Initialization example:\n\n    crop = Crop('Maize', planting_date='05/01')\n    ```\n\n    Attributes:\n\n        c_name (str): crop name ('custom' or one of built in defaults e.g. 'Maize')\n\n        planting_date (str): Planting Date (mm/dd)\n\n        harvest_date (str): Latest Harvest Date (mm/dd)\n\n\n    \"\"\"\n\n    def __init__(self, c_name, planting_date, harvest_date=None, **kwargs):\n\n        self.Name = c_name\n\n        # Assign default program properties (should not be changed without expert knowledge)\n\n        self.fshape_b = 13.8135  # Shape factor describing the reduction in biomass production for insufficient growing degree days\n        self.PctZmin = (\n            70  # Initial percentage of minimum effective rooting depth\n        )\n        self.fshape_ex = (\n            -6\n        )  # Shape factor describing the effects of water stress on root expansion\n        self.ETadj = 1  # Adjustment to water stress thresholds depending on daily ET0 (0 = No, 1 = Yes)\n        self.ET0dorm = 0 # Duration of dormant crop period (during early senescence) in terms of cumulative reference ET (mm)\n        self.Aer = 5  # Vol (%) below saturation at which stress begins to occur due to deficient aeration\n        self.LagAer = (\n            3  # Number of days lag before aeration stress affects crop growth\n        )\n        self.beta = 12  # Reduction (%) to p_lo3 when early canopy senescence is triggered\n        self.a_Tr = 1  # Exponent parameter for adjustment of Kcx once senescence is triggered\n        self.GermThr = 0.2  # Proportion of total water storage needed for crop to germinate\n        self.CCmin = 0.05  # Minimum canopy size below which yield_ formation cannot occur\n        self.MaxFlowPct = (\n            100 / 3\n        )  # Proportion of total flowering time (%) at which peak flowering occurs\n        self.HIini = 0.01  # Initial harvest index\n        self.bsted = 0.000138  # WP co2 adjustment parameter given by Steduto et al. 2007\n        self.bface = (\n            0.001165  # WP co2 adjustment parameter given by FACE experiments\n        )\n\n        # added in Read_Model_Paramaters (CB added in from duplicate CropStruct object whilst removing AOT 13/12/24)\n        self.CropType = 3  # Crop Type (1 = Leafy vegetable, 2 = Root/tuber, 3 = Fruit/grain)\n        self.PlantMethod = 1  # Planting method (0 = Transplanted, 1 =  Sown)\n        self.CalendarType = (\n            2  # Calendar Type (1 = Calendar days, 2 = Growing degree days)\n        )\n        self.SwitchGDD = 0  # Convert calendar to gdd mode if inputs are given in calendar days (0 = No; 1 = Yes)\n        self.SwitchGDDType = 'mean' # calculate GDD phenology based on mean of CD phenology across entire simulation period (mean/median)\n\n        self.EmergenceCD = 0\n        self.Canopy10PctCD = 0\n        self.MaxRootingCD = 0\n        self.SenescenceCD = 0\n        self.MaturityCD = 0\n        self.MaxCanopyCD = 0\n        self.CanopyDevEndCD = 0\n        self.HIstartCD = 0\n        self.HIendCD = 0\n        self.YldFormCD = 0\n\n        self.Emergence = 80  # Growing degree/Calendar days from sowing to emergence/transplant recovery\n        self.MaxRooting = (\n            1420  # Growing degree/Calendar days from sowing to maximum rooting\n        )\n        self.Senescence = (\n            1420  # Growing degree/Calendar days from sowing to senescence\n        )\n        self.Maturity = (\n            1670  # Growing degree/Calendar days from sowing to maturity\n        )\n        self.HIstart = 850  # Growing degree/Calendar days from sowing to start of yield_ formation\n        self.Flowering = 190  # Duration of flowering in growing degree/calendar days (-999 for non-fruit/grain crops)\n        self.YldForm = (\n            775  # Duration of yield_ formation in growing degree/calendar days\n        )\n        self.HIend = 0\n        self.MaxCanopy = 0\n        self.CanopyDevEnd = 0\n        self.Canopy10Pct = 0\n        self.YldWC = 0\n        self.GDDmethod = 2  # Growing degree day calculation method\n        self.Tbase = (\n            8  # Base temperature (degC) below which growth does not progress\n        )\n        self.Tupp = 30  # Upper temperature (degC) above which crop development no longer increases\n        self.PolHeatStress = (\n            1  # Pollination affected by heat stress (0 = No, 1 = Yes)\n        )\n        self.Tmax_up = 40  # Maximum air temperature (degC) above which pollination begins to fail\n        self.Tmax_lo = 45  # Maximum air temperature (degC) at which pollination completely fails\n        self.PolColdStress = (\n            1  # Pollination affected by cold stress (0 = No, 1 = Yes)\n        )\n        self.Tmin_up = 10  # Minimum air temperature (degC) below which pollination begins to fail\n        self.Tmin_lo = 5  # Minimum air temperature (degC) at which pollination completely fails\n        self.TrColdStress = 1  # Transpiration affected by cold temperature stress (0 = No, 1 = Yes)\n        self.GDD_up = 12  # Minimum growing degree days (degC/day) required for full crop transpiration potential\n        self.GDD_lo = 0  # Growing degree days (degC/day) at which no crop transpiration occurs\n        self.Zmin = 0.3  # Minimum effective rooting depth (m)\n        self.Zmax = 1.7  # Maximum rooting depth (m)\n        self.fshape_r = 1.3  # Shape factor describing root expansion\n        self.SxTopQ = 0.0480  # Maximum root water extraction at top of the root zone (m3/m3/day)\n        self.SxBotQ = 0.0117  # Maximum root water extraction at the bottom of the root zone (m3/m3/day)\n\n        self.SxTop = 0.0\n        self.SxBot = 0.0\n\n        self.SeedSize = 6.5  # Soil surface area (cm2) covered by an individual seedling at 90% emergence\n        self.PlantPop = 75_000  # Number of plants per hectare\n        self.CCx = 0.96  # Maximum canopy cover (fraction of soil cover)\n        self.CDC = (\n            0.01  # Canopy decline coefficient (fraction per gdd/calendar day)\n        )\n        self.CGC = 0.0125  # Canopy growth coefficient (fraction per gdd)\n        self.CDC_CD = (\n            0.01  # Canopy decline coefficient (fraction per gdd/calendar day)\n        )\n        self.CGC_CD = 0.0125  # Canopy growth coefficient (fraction per gdd)\n        self.Kcb = 1.05  # Crop coefficient when canopy growth is complete but prior to senescence\n        self.fage = 0.3  #  Decline of crop coefficient due to ageing (%/day)\n        self.WP = 33.7  # Water productivity normalized for ET0 and C02 (g/m2)\n        self.WPy = 100  # Adjustment of water productivity in yield_ formation stage (% of WP)\n        self.fsink = 0.5  # Crop performance under elevated atmospheric CO2 concentration (%/100)\n        self.HI0 = 0.48  # Reference harvest index\n        self.dHI_pre = 0  # Possible increase of harvest index due to water stress before flowering (%)\n        self.a_HI = 7  # Coefficient describing positive impact on harvest index of restricted vegetative growth during yield_ formation\n        self.b_HI = 3  # Coefficient describing negative impact on harvest index of stomatal closure during yield_ formation\n        self.dHI0 = 15  # Maximum allowable increase of harvest index above reference value\n        self.Determinant = (\n            1  # Crop Determinancy (0 = Indeterminant, 1 = Determinant)\n        )\n        self.exc = 50  # Excess of potential fruits\n        self.p_up = np.zeros(\n            4\n        )  # Upper soil water depletion threshold for water stress effects on affect canopy expansion\n        self.p_lo = np.zeros(\n            4\n        )  # Lower soil water depletion threshold for water stress effects on canopy expansion\n        self.fshape_w = np.ones(\n            4\n        )  # Shape factor describing water stress effects on canopy expansion\n\n        self.CC0 = 0.0\n\n        self.HIGC = 0.0\n        self.tLinSwitch = 0\n        self.dHILinear = 0.0\n\n        self.fCO2 = 0.0\n\n        self.FloweringCD = 0\n        self.FloweringEnd = 0.0\n\n        if c_name == \"custom\":\n\n            self.Name = \"custom\"\n            self.planting_date = planting_date  # Planting Date (mm/dd)\n            self.harvest_date = harvest_date  # Latest Harvest Date (mm/dd)\n\n        elif c_name in crop_params.keys():\n            self.__dict__.update(\n                (k, v) for k, v in crop_params[c_name].items()\n            )\n            self.planting_date = planting_date  # Planting Date (mm/dd)\n            self.harvest_date = harvest_date  # Latest Harvest Date (mm/dd)\n\n        else:\n            assert (\n                c_name in crop_params.keys()\n            ), f\"Crop name not defined in crop_params dictionary, \\\n        if defining a custom crop please use crop name 'custom'. Otherwise use one of the \\\n        pre-defined crops: {crop_params.keys()}\"\n\n        # overide any pre-defined paramater with any passed by the user\n        allowed_keys = {\n            \"fshape_b\",\n            \"PctZmin\",\n            \"fshape_ex\",\n            \"ETadj\",\n            \"ET0dorm\",\n            \"Aer\",\n            \"LagAer\",\n            \"beta\",\n            \"a_Tr\",\n            \"GermThr\",\n            \"CCmin\",\n            \"MaxFlowPct\",\n            \"HIini\",\n            \"bsted\",\n            \"bface\",\n            \"Name\",\n            \"CropType\",\n            \"PlantMethod\",\n            \"CalendarType\",\n            \"SwitchGDD\",\n            \"SwitchGDDType\",\n            \"planting_date\",\n            \"harvest_date\",\n            \"Emergence\",\n            \"MaxRooting\",\n            \"Senescence\",\n            \"Maturity\",\n            \"HIstart\",\n            \"Flowering\",\n            \"YldForm\",\n            \"YldWC\",\n            \"GDDmethod\",\n            \"Tbase\",\n            \"Tupp\",\n            \"PolHeatStress\",\n            \"Tmax_up\",\n            \"Tmax_lo\",\n            \"PolColdStress\",\n            \"Tmin_up\",\n            \"Tmin_lo\",\n            \"TrColdStress\",\n            \"GDD_up\",\n            \"GDD_lo\",\n            \"Zmin\",\n            \"Zmax\",\n            \"fshape_r\",\n            \"SxTopQ\",\n            \"SxBotQ\",\n            \"SeedSize\",\n            \"PlantPop\",\n            \"CCx\",\n            \"CDC\",\n            \"CGC\",\n            \"Kcb\",\n            \"fage\",\n            \"WP\",\n            \"WPy\",\n            \"fsink\",\n            \"HI0\",\n            \"dHI_pre\",\n            \"a_HI\",\n            \"b_HI\",\n            \"dHI0\",\n            \"Determinant\",\n            \"exc\",\n            \"p_up1\",\n            \"p_up2\",\n            \"p_up3\",\n            \"p_up4\",\n            \"p_lo1\",\n            \"p_lo2\",\n            \"p_lo3\",\n            \"p_lo4\",\n            \"fshape_w1\",\n            \"fshape_w2\",\n            \"fshape_w3\",\n            \"fshape_w4\",\n            \"CGC_CD\",\n            \"CDC_CD\",\n            \"EmergenceCD\",\n            \"MaxRootingCD\",\n            \"SenescenceCD\",\n            \"MaturityCD\",\n            \"HIstartCD\",\n            \"FloweringCD\",\n            \"YldFormCD\",\n        }\n\n        self.__dict__.update(\n            (k, v) for k, v in kwargs.items() if k in allowed_keys\n        )\n\n        self.calculate_additional_params()\n\n    def calculate_additional_params(\n        self,\n    ):\n        '''\n        Calculate additional parameters for all self types in mix\n        '''\n\n        # Fractional canopy cover size at emergence\n        self.CC0 = self.PlantPop * self.SeedSize * 1e-8\n        # Root extraction terms\n        SxTopQ = self.SxTopQ\n        SxBotQ = self.SxBotQ\n        S1 = self.SxTopQ\n        S2 = self.SxBotQ\n        if S1 == S2:\n            SxTop = S1\n            SxBot = S2\n        else:\n            if SxTopQ &lt; SxBotQ:\n                S1 = SxBotQ\n                S2 = SxTopQ\n\n            xx = 3 * (S2 / (S1 - S2))\n            if xx &lt; 0.5:\n                SS1 = (4 / 3.5) * S1\n                SS2 = 0\n            else:\n                SS1 = (xx + 3.5) * (S1 / (xx + 3))\n                SS2 = (xx - 0.5) * (S2 / xx)\n\n            if SxTopQ &gt; SxBotQ:\n                SxTop = SS1\n                SxBot = SS2\n            else:\n                SxTop = SS2\n                SxBot = SS1\n\n        self.SxTop = SxTop\n        self.SxBot = SxBot\n\n        # Water stress thresholds\n        self.p_up = np.array([self.p_up1, self.p_up2, self.p_up3, self.p_up4])\n\n        self.p_lo = np.array([self.p_lo1, self.p_lo2, self.p_lo3, self.p_lo4])\n\n        self.fshape_w = np.array(\n            [self.fshape_w1, self.fshape_w2, self.fshape_w3, self.fshape_w4]\n        )\n</code></pre>"},{"location":"entities/#aquacrop.entities.crop.Crop.calculate_additional_params","title":"<code>calculate_additional_params()</code>","text":"<p>Calculate additional parameters for all self types in mix</p> Source code in <code>aquacrop/entities/crop.py</code> <pre><code>def calculate_additional_params(\n    self,\n):\n    '''\n    Calculate additional parameters for all self types in mix\n    '''\n\n    # Fractional canopy cover size at emergence\n    self.CC0 = self.PlantPop * self.SeedSize * 1e-8\n    # Root extraction terms\n    SxTopQ = self.SxTopQ\n    SxBotQ = self.SxBotQ\n    S1 = self.SxTopQ\n    S2 = self.SxBotQ\n    if S1 == S2:\n        SxTop = S1\n        SxBot = S2\n    else:\n        if SxTopQ &lt; SxBotQ:\n            S1 = SxBotQ\n            S2 = SxTopQ\n\n        xx = 3 * (S2 / (S1 - S2))\n        if xx &lt; 0.5:\n            SS1 = (4 / 3.5) * S1\n            SS2 = 0\n        else:\n            SS1 = (xx + 3.5) * (S1 / (xx + 3))\n            SS2 = (xx - 0.5) * (S2 / xx)\n\n        if SxTopQ &gt; SxBotQ:\n            SxTop = SS1\n            SxBot = SS2\n        else:\n            SxTop = SS2\n            SxBot = SS1\n\n    self.SxTop = SxTop\n    self.SxBot = SxBot\n\n    # Water stress thresholds\n    self.p_up = np.array([self.p_up1, self.p_up2, self.p_up3, self.p_up4])\n\n    self.p_lo = np.array([self.p_lo1, self.p_lo2, self.p_lo3, self.p_lo4])\n\n    self.fshape_w = np.array(\n        [self.fshape_w1, self.fshape_w2, self.fshape_w3, self.fshape_w4]\n    )\n</code></pre>"},{"location":"entities/#aquacrop.entities.fieldManagement","title":"<code>aquacrop.entities.fieldManagement</code>","text":""},{"location":"entities/#aquacrop.entities.fieldManagement.FieldMngt","title":"<code>FieldMngt</code>","text":"<p>Field Management Class containing mulches and bunds parameters</p> <p>Attributes:</p> <pre><code>mulches (bool):  Soil surface covered by mulches (yield_ or N)\n\nbunds (bool):  Surface bunds present (yield_ or N)\n\ncurve_number_adj (bool): Field conditions affect curve number (yield_ or N)\n\nsr_inhb (bool): Management practices fully inhibit surface runoff (yield_ or N)\n\nmulch_pct (float):  Area of soil surface covered by mulches (%)\n\nf_mulch (float): Soil evaporation adjustment factor due to effect of mulches\n\nz_bund (float): Bund height, user specifies in (m) but immediately converted to (mm) on initialisation for coherent calculations\n\nbund_water (float): Initial water height in surface bunds (mm)\n\ncurve_number_adj_pct (float): Percentage change in curve number (positive or negative)\n</code></pre> Source code in <code>aquacrop/entities/fieldManagement.py</code> <pre><code>class FieldMngt:\n    \"\"\"\n    Field Management Class containing mulches and bunds parameters\n\n    Attributes:\n\n        mulches (bool):  Soil surface covered by mulches (yield_ or N)\n\n        bunds (bool):  Surface bunds present (yield_ or N)\n\n        curve_number_adj (bool): Field conditions affect curve number (yield_ or N)\n\n        sr_inhb (bool): Management practices fully inhibit surface runoff (yield_ or N)\n\n        mulch_pct (float):  Area of soil surface covered by mulches (%)\n\n        f_mulch (float): Soil evaporation adjustment factor due to effect of mulches\n\n        z_bund (float): Bund height, user specifies in (m) but immediately converted to (mm) on initialisation for coherent calculations\n\n        bund_water (float): Initial water height in surface bunds (mm)\n\n        curve_number_adj_pct (float): Percentage change in curve number (positive or negative)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mulches=False,\n        bunds=False,\n        curve_number_adj=False,\n        sr_inhb=False,\n        mulch_pct=50,\n        f_mulch=0.5,\n        z_bund=0,\n        bund_water=0,\n        curve_number_adj_pct=0,\n    ):\n\n        self.mulches = mulches  #  Soil surface covered by mulches (yield_ or N)\n        self.bunds = bunds  #  Surface bunds present (yield_ or N)\n        self.curve_number_adj = curve_number_adj  # Field conditions affect curve number (yield_ or N)\n        self.sr_inhb = sr_inhb  # Management practices fully inhibit surface runoff (yield_ or N)\n\n        self.mulch_pct = mulch_pct  #  Area of soil surface covered by mulches (%)\n        self.f_mulch = f_mulch  # Soil evaporation adjustment factor due to effect of mulches\n        self.z_bund = z_bund * 1000 # Bund height, user-specified as (m), here immediately converted to (mm)\n        self.bund_water = bund_water  # Initial water height in surface bunds (mm)\n        self.curve_number_adj_pct = curve_number_adj_pct  # Percentage change in curve number (positive or negative)\n</code></pre>"},{"location":"entities/#aquacrop.entities.fieldManagement.FieldMngtStruct","title":"<code>FieldMngtStruct</code>","text":"Source code in <code>aquacrop/entities/fieldManagement.py</code> <pre><code>class FieldMngtStruct:\n\n    \"\"\"\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.mulches = False\n        self.bunds = False\n        self.curve_number_adj = False\n        self.sr_inhb = False\n\n        self.mulch_pct = 0.0\n        self.f_mulch = 0.0\n        self.z_bund = 0.0\n        self.bund_water = 0.0\n        self.curve_number_adj_pct = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.groundWater","title":"<code>aquacrop.entities.groundWater</code>","text":""},{"location":"entities/#aquacrop.entities.groundWater.GroundWater","title":"<code>GroundWater</code>","text":"<p>Ground Water Class stores information on water table params</p> <p>Attributes:</p> <pre><code>water_table (str):  Water table considered (Y or N)\n\nmethod (str):  Water table input data ('Constant' or 'Variable')\n\ndates (list): water table observation dates\n\nvalues (list): water table observation depths\n</code></pre> Source code in <code>aquacrop/entities/groundWater.py</code> <pre><code>class GroundWater:\n    \"\"\"\n    Ground Water Class stores information on water table params\n\n    Attributes:\n\n        water_table (str):  Water table considered (Y or N)\n\n        method (str):  Water table input data ('Constant' or 'Variable')\n\n        dates (list): water table observation dates\n\n        values (list): water table observation depths\n\n    \"\"\"\n\n    def __init__(self, water_table=\"N\", method=\"Constant\", dates=[], values=[]):\n\n        self.water_table = water_table\n        self.method = method\n        self.dates = dates\n        self.values = values\n</code></pre>"},{"location":"entities/#aquacrop.entities.inititalWaterContent","title":"<code>aquacrop.entities.inititalWaterContent</code>","text":""},{"location":"entities/#aquacrop.entities.inititalWaterContent.InitialWaterContent","title":"<code>InitialWaterContent</code>","text":"<p>Initial water content Class defines water content at start of sim</p> <p>Attributes:</p> <pre><code>wc_type (str):  Type of value ('Prop' = 'WP'/'FC'/'SAT'; 'Num' = XXX m3/m3; 'Pct' = % taw))\n\nmethod (str):  method ('Depth' = Interpolate depth points; 'Layer' = Constant value for each soil layer)\n\ndepth_layer (list): location in soil profile (soil layer or depth)\n\nvalue (list): value at each location given in depth_layer\n</code></pre> Source code in <code>aquacrop/entities/inititalWaterContent.py</code> <pre><code>class InitialWaterContent:\n    \"\"\"\n    Initial water content Class defines water content at start of sim\n\n    Attributes:\n\n        wc_type (str):  Type of value ('Prop' = 'WP'/'FC'/'SAT'; 'Num' = XXX m3/m3; 'Pct' = % taw))\n\n        method (str):  method ('Depth' = Interpolate depth points; 'Layer' = Constant value for each soil layer)\n\n        depth_layer (list): location in soil profile (soil layer or depth)\n\n        value (list): value at each location given in depth_layer\n\n    \"\"\"\n\n    def __init__(self, wc_type=\"Prop\", method=\"Layer\", depth_layer=[1], value=[\"FC\"]):\n\n        self.wc_type = wc_type\n        self.method = method\n        self.depth_layer = depth_layer\n        self.value = value\n</code></pre>"},{"location":"entities/#aquacrop.entities.initParamVariables","title":"<code>aquacrop.entities.initParamVariables</code>","text":""},{"location":"entities/#aquacrop.entities.initParamVariables.InitialCondition","title":"<code>InitialCondition</code>","text":"<p>The InitCond Class contains all Paramaters and variables used in the simulation</p> <p>updated each timestep with the name NewCond</p> Source code in <code>aquacrop/entities/initParamVariables.py</code> <pre><code>class InitialCondition:\n    \"\"\"\n    The InitCond Class contains all Paramaters and variables used in the simulation\n\n    updated each timestep with the name NewCond\n\n\n    \"\"\"\n\n    def __init__(self, num_comp):\n        # counters\n        self.age_days = 0\n        self.age_days_ns = 0\n        self.aer_days = 0\n        self.aer_days_comp = np.zeros(num_comp)\n        self.irr_cum = 0\n        self.delayed_gdds = 0\n        self.delayed_cds = 0\n        self.pct_lag_phase = 0\n        self.t_early_sen = 0\n        self.gdd_cum = 0\n        self.day_submerged = 0\n        self.irr_net_cum = 0\n        self.dap = 0\n        self.e_pot = 0\n        self.t_pot = 0\n\n        # States\n        self.pre_adj = False\n        self.crop_mature = False\n        self.crop_dead = False\n        self.germination = False\n        self.premat_senes = False\n        self.harvest_flag = False\n        self.growing_season = False\n        self.yield_form = False\n        self.stage2 = False\n\n        self.wt_in_soil = False\n\n        # harvest_index\n        self.stage = 1\n        self.f_pre = 1\n        self.f_post = 1\n        self.fpost_dwn = 1\n        self.fpost_upp = 1\n\n        self.h1_cor_asum = 0\n        self.h1_cor_bsum = 0\n        self.f_pol = 0\n        self.s_cor1 = 0\n        self.s_cor2 = 0\n        self.hi_ref = 0.0\n        self.HIfinal = 0.0\n\n        # GS\n        self.growth_stage = 0\n\n        # Transpiration\n        self.tr_ratio = 1\n\n        # crop growth\n        self.r_cor = 1\n\n        self.canopy_cover = 0\n        self.canopy_cover_adj = 0\n        self.canopy_cover_ns = 0\n        self.canopy_cover_adj_ns = 0\n        self.biomass = 0\n        self.biomass_ns = 0\n        self.YieldPot = 0\n        self.harvest_index = 0\n        self.harvest_index_adj = 0\n        self.ccx_act = 0\n        self.ccx_act_ns = 0\n        self.ccx_w = 0\n        self.ccx_w_ns = 0\n        self.ccx_early_sen = 0\n        self.cc_prev = 0\n        self.protected_seed = 0\n        self.DryYield = 0\n        self.FreshYield = 0\n\n        self.z_root = 0.0\n        self.cc0_adj = 0\n        self.surface_storage = 0\n        self.z_gw = ModelConstants.NO_VALUE\n\n        self.th_fc_Adj = np.zeros(num_comp)\n        self.th = np.zeros(num_comp)\n        self.thini = np.zeros(num_comp)\n\n        self.time_step_counter = 0\n\n        self.precipitation = 0\n        self.temp_max = 0\n        self.temp_min = 0\n        self.et0 = 0\n        self.sumET0EarlySen = 0\n        self.gdd = 0\n\n        self.w_surf = 0\n        self.evap_z = 0\n        self.w_stage_2 = 0\n\n        self.depletion = 0\n        self.taw = 0\n</code></pre>"},{"location":"entities/#aquacrop.entities.irrigationManagement","title":"<code>aquacrop.entities.irrigationManagement</code>","text":""},{"location":"entities/#aquacrop.entities.irrigationManagement.IrrMngtStruct","title":"<code>IrrMngtStruct</code>","text":"Source code in <code>aquacrop/entities/irrigationManagement.py</code> <pre><code>class IrrMngtStruct:\n\n    \"\"\"\n\n\n    \"\"\"\n\n    def __init__(self, sim_len):\n        self.irrigation_method = 0\n\n        self.WetSurf = 100.0\n        self.AppEff = 100.0\n        self.MaxIrr = 25.0\n        self.MaxIrrSeason = 10_000\n        self.SMT = np.zeros(4)\n        self.IrrInterval = 0\n        self.Schedule = np.zeros(sim_len)\n        self.NetIrrSMT = 80.0\n        self.depth = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.irrigationManagement.IrrigationManagement","title":"<code>IrrigationManagement</code>","text":"<p>IrrigationManagement Class defines irrigation strategy</p> <p>Attributes:</p> <pre><code>irrigation_method (int):  Irrigation method {0: rainfed, 1: soil moisture targets, 2: set time interval,\n                                        3: predifined schedule, 4: net irrigation, 5: constant depth }\n\nWetSurf (int): Soil surface wetted by irrigation (%)\n\nAppEff (int): Irrigation application efficiency (%)\n\nMaxIrr (float): Maximum depth (mm) that can be applied each day\n\nSMT (list):  Soil moisture targets (%taw) to maintain in each growth stage (only used if irrigation method is equal to 1)\n\nIrrInterval (int): Irrigation interval in days (only used if irrigation method is equal to 2)\n\nSchedule (pandas.DataFrame): DataFrame containing dates and depths\n\nNetIrrSMT (float): Net irrigation threshold moisture level (% of taw that will be maintained, for irrigation_method=4)\n\nDepth (float): constant depth to apply on each day (mm)\n</code></pre> Source code in <code>aquacrop/entities/irrigationManagement.py</code> <pre><code>class IrrigationManagement:\n\n    \"\"\"\n    IrrigationManagement Class defines irrigation strategy\n\n    Attributes:\n\n\n        irrigation_method (int):  Irrigation method {0: rainfed, 1: soil moisture targets, 2: set time interval,\n                                                3: predifined schedule, 4: net irrigation, 5: constant depth }\n\n        WetSurf (int): Soil surface wetted by irrigation (%)\n\n        AppEff (int): Irrigation application efficiency (%)\n\n        MaxIrr (float): Maximum depth (mm) that can be applied each day\n\n        SMT (list):  Soil moisture targets (%taw) to maintain in each growth stage (only used if irrigation method is equal to 1)\n\n        IrrInterval (int): Irrigation interval in days (only used if irrigation method is equal to 2)\n\n        Schedule (pandas.DataFrame): DataFrame containing dates and depths\n\n        NetIrrSMT (float): Net irrigation threshold moisture level (% of taw that will be maintained, for irrigation_method=4)\n\n        Depth (float): constant depth to apply on each day (mm)\n\n    \"\"\"\n\n    def __init__(self, irrigation_method, **kwargs):\n        self.irrigation_method = irrigation_method\n\n        self.WetSurf = 100.0\n        self.AppEff = 100.0\n        self.MaxIrr = 25.0\n        self.MaxIrrSeason = 10_000.0\n        self.SMT = np.zeros(4)\n        self.IrrInterval = 0\n        self.Schedule = []\n        self.NetIrrSMT = 80.0\n        self.depth = 0.0\n\n        if irrigation_method == 1:\n            self.SMT = [100] * 4\n\n        if irrigation_method == 2:\n            self.IrrInterval = 3\n\n        if irrigation_method == 3:\n            # wants a pandas dataframe with Date and Depth, pd.Datetime and float\n            \"\"\"\n            dates = pd.DatetimeIndex(['20/10/1979','20/11/1979','20/12/1979'])\n            depths = [25,25,25]\n            irr=pd.DataFrame([dates,depths]).T\n            irr.columns=['Date','Depth']\n            \"\"\"\n            self.Schedule = pd.DataFrame(columns=[\"Date\", \"Depth\"])\n\n        if irrigation_method == 4:\n            self.NetIrrSMT = 80\n\n        if irrigation_method == 5:\n            self.depth = 0\n\n        allowed_keys = {\n            \"name\",\n            \"WetSurf\",\n            \"AppEff\",\n            \"MaxIrr\",\n            \"MaxIrrSeason\",\n            \"SMT\",\n            \"IrrInterval\",\n            \"NetIrrSMT\",\n            \"Schedule\",\n            \"depth\",\n        }\n\n        self.__dict__.update((k, v) for k, v in kwargs.items() if k in allowed_keys)\n</code></pre>"},{"location":"entities/#aquacrop.entities.moistureDepletion","title":"<code>aquacrop.entities.moistureDepletion</code>","text":""},{"location":"entities/#aquacrop.entities.moistureDepletion.Dr","title":"<code>Dr</code>","text":"<p>Depletion class to hold the rootzone and topsoil depletion</p> <p>Attributes:</p> <p>Rz (float): Root zone soil-water depletion</p> <p>Zt (float): Top soil depletion</p> Source code in <code>aquacrop/entities/moistureDepletion.py</code> <pre><code>class Dr:\n    \"\"\"\n    Depletion class to hold the rootzone and topsoil depletion\n\n    Attributes:\n\n    Rz (float): Root zone soil-water depletion\n\n    Zt (float): Top soil depletion\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.Rz = 0.0\n        self.Zt = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.output","title":"<code>aquacrop.entities.output</code>","text":""},{"location":"entities/#aquacrop.entities.output.Output","title":"<code>Output</code>","text":"<p>Class to hold output data</p> <p>During Simulation these are numpy arrays and are converted to pandas dataframes at the end of the simulation</p> <p>Atributes:</p> <pre><code>water_flux (pandas.DataFrame, numpy.array): Daily water flux changes\n\nwater_storage (pandas.DataFrame, numpy array): daily water content of each soil compartment\n\ncrop_growth (pandas.DataFrame, numpy array): daily crop growth variables\n\nfinal_stats (pandas.DataFrame, numpy array): final stats at end of each season\n</code></pre> Source code in <code>aquacrop/entities/output.py</code> <pre><code>class Output:\n    \"\"\"\n    Class to hold output data\n\n    During Simulation these are numpy arrays and are converted to pandas dataframes\n    at the end of the simulation\n\n    Atributes:\n\n        water_flux (pandas.DataFrame, numpy.array): Daily water flux changes\n\n        water_storage (pandas.DataFrame, numpy array): daily water content of each soil compartment\n\n        crop_growth (pandas.DataFrame, numpy array): daily crop growth variables\n\n        final_stats (pandas.DataFrame, numpy array): final stats at end of each season\n\n    \"\"\"\n\n    def __init__(self, time_span, initial_th):\n\n        self.water_storage = np.zeros((len(time_span), 3 + len(initial_th)))\n        self.water_flux = np.zeros((len(time_span), 16))\n        self.crop_growth = np.zeros((len(time_span), 15))\n        self.final_stats = pd.DataFrame(\n            columns=[\n                \"Season\",\n                \"crop Type\",\n                \"Harvest Date (YYYY/MM/DD)\",\n                \"Harvest Date (Step)\",\n                \"Dry yield (tonne/ha)\",\n                \"Fresh yield (tonne/ha)\",\n                \"Yield potential (tonne/ha)\",\n                \"Seasonal irrigation (mm)\",\n            ]\n        )\n</code></pre>"},{"location":"entities/#aquacrop.entities.paramStruct","title":"<code>aquacrop.entities.paramStruct</code>","text":""},{"location":"entities/#aquacrop.entities.paramStruct.ParamStruct","title":"<code>ParamStruct</code>","text":"<p>The ParamStruct class contains the bulk of model Paramaters.  In general these will not change over the course of the simulation</p> <p>Attributes:</p> <pre><code>Soil (Soil): Soil object contains data and paramaters related to the soil\n\nFallowFieldMngt (FieldMngt): Object containing field management variables for the off season (fallow periods)\n\nNCrops (int): Number of crop types to be simulated\n\nSpecifiedPlantCalander (str):  Specified crop rotation calendar (yield_ or N)\n\nCropChoices (list): List of crop type names in each simulated season\n\nCO2data (pd.Series): CO2 data indexed by year\n\nCO2 (CO2): object containing reference and current co2 concentration\n\nwater_table (int): Water table present (1=yes, 0=no)\n\nz_gw (np.array): water_table depth (mm) for each day of simulation\n\nzGW_dates (np.array): Corresponding dates to the z_gw values\n\nWTMethod (str): 'Constant' or 'Variable'\n\nCropList (list): List of Crop Objects which contain paramaters for all the differnet crops used in simulations\n\npython_crop_list (list): List of Crop Objects, one for each season\n\npython_fallow_crop (Crop): Crop object for off season\n\nSeasonal_Crop_List (list): List of Crop objects, one for each season\n\ncrop_name_list (list): List of crop names, one for each season\n\nFallow_Crop (Crop): Crop object for off season\n\nFallow_Crop_Name (str): name of fallow crop\n</code></pre> Source code in <code>aquacrop/entities/paramStruct.py</code> <pre><code>class ParamStruct:\n    \"\"\"\n    The ParamStruct class contains the bulk of model Paramaters. \n    In general these will not change over the course of the simulation\n\n\n    Attributes:\n\n        Soil (Soil): Soil object contains data and paramaters related to the soil\n\n        FallowFieldMngt (FieldMngt): Object containing field management variables for the off season (fallow periods)\n\n        NCrops (int): Number of crop types to be simulated\n\n        SpecifiedPlantCalander (str):  Specified crop rotation calendar (yield_ or N)\n\n        CropChoices (list): List of crop type names in each simulated season\n\n        CO2data (pd.Series): CO2 data indexed by year\n\n        CO2 (CO2): object containing reference and current co2 concentration\n\n        water_table (int): Water table present (1=yes, 0=no)\n\n        z_gw (np.array): water_table depth (mm) for each day of simulation\n\n        zGW_dates (np.array): Corresponding dates to the z_gw values\n\n        WTMethod (str): 'Constant' or 'Variable'\n\n        CropList (list): List of Crop Objects which contain paramaters for all the differnet crops used in simulations\n\n        python_crop_list (list): List of Crop Objects, one for each season\n\n        python_fallow_crop (Crop): Crop object for off season\n\n        Seasonal_Crop_List (list): List of Crop objects, one for each season\n\n        crop_name_list (list): List of crop names, one for each season\n\n        Fallow_Crop (Crop): Crop object for off season\n\n        Fallow_Crop_Name (str): name of fallow crop\n\n        \"\"\"\n\n    def __init__(self):\n\n        # soil\n        self.Soil = 0\n\n        # field management\n        self.FallowFieldMngt = 0\n\n        # variables extracted from cropmix.txt\n        self.NCrops = 0\n        self.SpecifiedPlantCalander = \"\"\n        self.RotationFilename = \"\"\n\n        # calculated Co2 variables\n        self.CO2data = []\n        self.CO2 = 0\n        self.co2_concentration_adj = None\n\n        # water table\n        self.water_table = 0\n        self.z_gw = []\n        self.zGW_dates = []\n        self.WTMethod = \"\"\n\n        # crops\n        self.CropList = []\n        self.python_crop_list = []\n        self.python_fallow_crop = 0\n        self.Seasonal_Crop_List = []\n        self.crop_name_list = []\n        self.Fallow_Crop = 0\n        self.Fallow_Crop_Name = \"\"\n</code></pre>"},{"location":"entities/#aquacrop.entities.rootZoneWaterContent","title":"<code>aquacrop.entities.rootZoneWaterContent</code>","text":""},{"location":"entities/#aquacrop.entities.rootZoneWaterContent.RootZoneWater","title":"<code>RootZoneWater</code>","text":"<p>               Bases: <code>object</code></p> <p>TODO: This class is not used</p> <p>root zone water content</p> <p>Attributes:</p> <p><code>Act</code> : <code>float</code> : .</p> <p><code>S</code> : <code>float</code> : .</p> <p><code>FC</code> : <code>float</code> : .</p> <p><code>WP</code> : <code>float</code> : .</p> <p><code>Dry</code> : <code>float</code> : .</p> <p><code>Aer</code> : <code>float</code> : .</p> Source code in <code>aquacrop/entities/rootZoneWaterContent.py</code> <pre><code>class RootZoneWater(object):\n    \"\"\"\n    TODO: This class is not used\n\n    root zone water content\n\n    **Attributes:**\\n\n\n\n\n    `Act` : `float` : .\n\n    `S` : `float` : .\n\n    `FC` : `float` : .\n\n    `WP` : `float` : .\n\n    `Dry` : `float` : .\n\n    `Aer` : `float` : .\n\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.Act = 0.0\n        self.S = 0.0\n        self.FC = 0.0\n        self.WP = 0.0\n        self.Dry = 0.0\n        self.Aer = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.soil","title":"<code>aquacrop.entities.soil</code>","text":""},{"location":"entities/#aquacrop.entities.soil.Soil","title":"<code>Soil</code>","text":"<p>The Soil Class contains Paramaters and variables of the soil used in the simulation</p> <p>More float attributes are specified in the initialisation of the class</p> <p>Attributes:</p> <pre><code>profile (pandas.DataFrame): holds soil profile information\n\nProfile (SoilProfile): jit class object holdsing soil profile information\n\nHydrology (pandas.DataFrame): holds soil layer hydrology informaiton\n\nComp (pandas.DataFrame): holds soil compartment information\n</code></pre> Source code in <code>aquacrop/entities/soil.py</code> <pre><code>class Soil:\n    \"\"\"\n    The Soil Class contains Paramaters and variables of the soil used in the simulation\n\n    More float attributes are specified in the initialisation of the class\n\n    Attributes:\n\n        profile (pandas.DataFrame): holds soil profile information\n\n        Profile (SoilProfile): jit class object holdsing soil profile information\n\n        Hydrology (pandas.DataFrame): holds soil layer hydrology informaiton\n\n        Comp (pandas.DataFrame): holds soil compartment information\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        soil_type,\n        dz=[0.1] * 12,\n        adj_rew=1,\n        rew=9.0,\n        calc_cn=0,\n        cn=61.0,\n        z_res=ModelConstants.NO_VALUE,\n        evap_z_surf=0.04,\n        evap_z_min=0.15,\n        evap_z_max=0.30,\n        kex=1.1,\n        f_evap=4,\n        f_wrel_exp=0.4,\n        fwcc=50,\n        z_cn=0.3,\n        z_germ=0.3,\n        adj_cn=1,\n        fshape_cr=16,\n        z_top=0.1,\n    ):\n\n        self.Name = soil_type\n\n        self.zSoil = sum(dz)  # Total thickness of soil profile (m)\n        self.nComp = len(dz)  # Total number of soil compartments\n        self.nLayer = 0  # Total number of soil layers\n        self.adj_rew = adj_rew  # Adjust default value for readily evaporable water (0 = No, 1 = Yes)\n        self.rew = rew  # Readily evaporable water (mm) (only used if adjusting from default value)\n        self.calc_cn = calc_cn  # adjust Curve number based on Ksat\n        self.cn = cn  # Curve number  (0 = No, 1 = Yes)\n        self.z_res = z_res  # Depth of restrictive soil layer (set to negative value if not present)\n\n        # Assign default program properties (should not be changed without expert knowledge)\n        self.evap_z_surf = (\n            evap_z_surf  # Thickness of soil surface skin evaporation layer (m)\n        )\n        self.evap_z_min = (\n            evap_z_min  # Minimum thickness of full soil surface evaporation layer (m)\n        )\n        self.evap_z_max = (\n            evap_z_max  # Maximum thickness of full soil surface evaporation layer (m)\n        )\n        self.kex = kex  # Maximum soil evaporation coefficient\n        self.f_evap = (\n            f_evap  # Shape factor describing reduction in soil evaporation in stage 2.\n        )\n        self.f_wrel_exp = f_wrel_exp  # Proportional value of Wrel at which soil evaporation layer expands\n        self.fwcc = fwcc  # Maximum coefficient for soil evaporation reduction due to sheltering effect of withered canopy\n        self.z_cn = z_cn  # Thickness of soil surface (m) used to calculate water content to adjust curve number\n        self.z_germ = z_germ  # Thickness of soil surface (m) used to calculate water content for germination\n        self.adj_cn = (\n            adj_cn  # Adjust curve number for antecedent moisture content (0: No, 1: Yes)\n        )\n        self.fshape_cr = fshape_cr  # Capillary rise shape factor\n        self.z_top = max(\n            z_top, dz[0]\n        )  # Thickness of soil surface layer for water stress comparisons (m)\n\n        if soil_type == \"custom\":\n            self.create_df(dz)\n\n        elif soil_type == \"Clay\":\n            self.cn = 77\n            self.calc_cn = 0\n            self.rew = 14\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.39, 0.54, 0.55, 35, 100)\n\n        elif soil_type == \"ClayLoam\":\n            self.cn = 72\n            self.calc_cn = 0\n            self.rew = 11\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.23, 0.39, 0.5, 125, 100)\n\n        elif soil_type == 'Default':\n            self.cn = 61\n            self.calc_cn = 0\n            self.rew = 9\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.1, 0.3, 0.5, 500, 100)\n\n        elif soil_type == \"Loam\":\n            self.cn = 61\n            self.calc_cn = 0\n            self.rew = 9\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.15, 0.31, 0.46, 500, 100)\n\n        elif soil_type == \"LoamySand\":\n            self.cn = 46\n            self.calc_cn = 0\n            self.rew = 5\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.08, 0.16, 0.38, 2200, 100)\n\n        elif soil_type == \"Sand\":\n            self.cn = 46\n            self.calc_cn = 0\n            self.rew = 4\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.06, 0.13, 0.36, 3000, 100)\n\n        elif soil_type == \"SandyClay\":\n            self.cn = 77\n            self.calc_cn = 0\n            self.rew = 10\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.27, 0.39, 0.5, 35, 100)\n\n        elif soil_type == \"SandyClayLoam\":\n            self.cn = 72\n            self.calc_cn = 0\n            self.rew = 9\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.20, 0.32, 0.47, 225, 100)\n\n        elif soil_type == \"SandyLoam\":\n            self.cn = 46\n            self.calc_cn = 0\n            self.rew = 7\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.10, 0.22, 0.41, 1200, 100)\n\n        elif soil_type == \"Silt\":\n            self.cn = 61\n            self.calc_cn = 0\n            self.rew = 11\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.09, 0.33, 0.43, 500, 100)\n\n        elif soil_type == \"SiltClayLoam\":\n            self.cn = 72\n            self.calc_cn = 0\n            self.rew = 13\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.23, 0.44, 0.52, 150, 100)\n\n        elif soil_type == \"SiltLoam\":\n            self.cn = 61\n            self.calc_cn = 0\n            self.rew = 11\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.13, 0.33, 0.46, 575, 100)\n\n        elif soil_type == \"SiltClay\":\n            self.cn = 72\n            self.calc_cn = 0\n            self.rew = 14\n            self.create_df(dz)\n            self.add_layer(sum(dz), 0.32, 0.50, 0.54, 100, 100)\n\n        elif soil_type == \"Paddy\":\n            self.cn = 77\n            self.calc_cn = 0\n            self.rew = 10\n            self.create_df(dz)\n            self.add_layer(0.5, 0.32, 0.50, 0.54, 15, 100)\n            self.add_layer(1.5, 0.39, 0.54, 0.55, 2, 100)\n\n        elif soil_type == \"ac_TunisLocal\":\n            self.cn = 72\n            self.calc_cn = 0\n            self.rew = 11\n            dz = [0.1] * 6 + [0.15] * 5 + [0.2]\n            self.create_df(dz)\n            self.add_layer(0.3, 0.24, 0.40, 0.50, 155, 100)\n            self.add_layer(1.7, 0.11, 0.33, 0.46, 500, 100)\n\n        else:\n            print(\"wrong soil type\")\n            assert 1 == 2\n\n    def __repr__(self):\n        for key in self.__dict__:\n            if key != \"profile\":\n                print(f\"{key}: {getattr(self,key)}\")\n\n        return \" \"\n\n    def create_df(self, dz):\n\n        self.profile = pd.DataFrame(\n            np.empty((len(dz), 4)), columns=[\"Comp\", \"Layer\", \"dz\", \"dzsum\"]\n        )\n        self.profile.dz = dz\n        self.profile.dzsum = np.cumsum(self.profile.dz).round(2)\n        self.profile.Comp = np.arange(len(dz))\n        self.profile.Layer = np.nan\n\n        self.profile[\"zBot\"] = self.profile.dzsum\n        self.profile[\"z_top\"] = self.profile[\"zBot\"] - self.profile.dz\n        self.profile[\"zMid\"] = (self.profile[\"z_top\"] + self.profile[\"zBot\"]) / 2\n\n    def calculate_soil_hydraulic_properties(self, Sand, Clay, OrgMat, DF=1):\n\n        \"\"\"\n        Function to calculate soil hydraulic properties, given textural inputs.\n        Calculations use pedotransfer function equations described in Saxton and Rawls (2006)\n\n\n        \"\"\"\n\n        # do calculations\n\n        # Water content at permanent wilting point\n        Pred_thWP = (\n            -(0.024 * Sand)\n            + (0.487 * Clay)\n            + (0.006 * OrgMat)\n            + (0.005 * Sand * OrgMat)\n            - (0.013 * Clay * OrgMat)\n            + (0.068 * Sand * Clay)\n            + 0.031\n        )\n\n        th_wp = Pred_thWP + (0.14 * Pred_thWP) - 0.02\n\n        # Water content at field capacity and saturation\n        Pred_thFC = (\n            -(0.251 * Sand)\n            + (0.195 * Clay)\n            + (0.011 * OrgMat)\n            + (0.006 * Sand * OrgMat)\n            - (0.027 * Clay * OrgMat)\n            + (0.452 * Sand * Clay)\n            + 0.299\n        )\n\n        PredAdj_thFC = Pred_thFC + (\n            (1.283 * (np.power(Pred_thFC, 2))) - (0.374 * Pred_thFC) - 0.015\n        )\n\n        Pred_thS33 = (\n            (0.278 * Sand)\n            + (0.034 * Clay)\n            + (0.022 * OrgMat)\n            - (0.018 * Sand * OrgMat)\n            - (0.027 * Clay * OrgMat)\n            - (0.584 * Sand * Clay)\n            + 0.078\n        )\n\n        PredAdj_thS33 = Pred_thS33 + ((0.636 * Pred_thS33) - 0.107)\n        Pred_thS = (PredAdj_thFC + PredAdj_thS33) + ((-0.097 * Sand) + 0.043)\n\n        pN = (1 - Pred_thS) * 2.65\n        pDF = pN * DF\n        PorosComp = (1 - (pDF / 2.65)) - (1 - (pN / 2.65))\n        PorosCompOM = 1 - (pDF / 2.65)\n\n        DensAdj_thFC = PredAdj_thFC + (0.2 * PorosComp)\n        DensAdj_thS = PorosCompOM\n\n        th_fc = DensAdj_thFC\n        th_s = DensAdj_thS\n\n        # Saturated hydraulic conductivity (mm/day)\n        lmbda = 1 / ((np.log(1500) - np.log(33)) / (np.log(th_fc) - np.log(th_wp)))\n        Ksat = (1930 * (th_s - th_fc) ** (3 - lmbda)) * 24\n\n        # Water content at air dry\n        th_dry = th_wp / 2\n\n        # round values\n        th_dry = round(10_000 * th_dry) / 10_000\n        th_wp = round(1000 * th_wp) / 1000\n        th_fc = round(1000 * th_fc) / 1000\n        th_s = round(1000 * th_s) / 1000\n        Ksat = round(10 * Ksat) / 10\n\n        return th_wp, th_fc, th_s, Ksat\n\n    def add_layer_from_texture(self, thickness, Sand, Clay, OrgMat, penetrability):\n\n        th_wp, th_fc, th_s, Ksat = self.calculate_soil_hydraulic_properties(\n            Sand / 100, Clay / 100, OrgMat\n        )\n\n        self.add_layer(thickness, th_wp, th_fc, th_s, Ksat, penetrability)\n\n    def add_layer(self, thickness, thWP, thFC, thS, Ksat, penetrability):\n\n        self.nLayer += 1\n\n        num_layers = len(self.profile.dropna().Layer.unique())\n\n        new_layer = num_layers + 1\n\n        if new_layer == 1:\n            self.profile.loc[\n                (round(thickness, 2) &gt;= round(self.profile.dzsum, 2)), \"Layer\"\n            ] = new_layer\n        else:\n            last = self.profile[self.profile.Layer == new_layer - 1].dzsum.values[-1]\n            self.profile.loc[\n                (thickness + last &gt;= self.profile.dzsum) &amp; (self.profile.Layer.isna()),\n                \"Layer\",\n            ] = new_layer\n\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"th_dry\"\n        ] = self.profile.Layer.map({new_layer: thWP / 2})\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"th_wp\"\n        ] = self.profile.Layer.map({new_layer: thWP})\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"th_fc\"\n        ] = self.profile.Layer.map({new_layer: thFC})\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"th_s\"\n        ] = self.profile.Layer.map({new_layer: thS})\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"Ksat\"\n        ] = self.profile.Layer.map({new_layer: Ksat})\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"penetrability\"\n        ] = self.profile.Layer.map({new_layer: penetrability})\n\n        # Calculate drainage characteristic (tau)\n        # Calculations use equation given by Raes et al. 2012\n        tau = round(0.0866 * (Ksat**0.35), 2)\n        if tau &gt; 1:\n            tau = 1\n        elif tau &lt; 0:\n            tau = 0\n\n        self.profile.loc[\n            self.profile.Layer == new_layer, \"tau\"\n        ] = self.profile.Layer.map({new_layer: tau})\n\n    def fill_nan(\n        self,\n    ):\n\n        self.profile = self.profile.ffill()\n\n        self.profile.dz = self.profile.dz.round(2)\n\n        self.profile.dzsum = self.profile.dz.cumsum().round(2)\n\n        self.zSoil = round(self.profile.dz.sum(), 2)\n\n        self.nComp = len(self.profile)\n\n        self.profile.Layer = self.profile.Layer.astype(int)\n\n    def add_capillary_rise_params(\n        self,\n    ):\n        # Calculate capillary rise parameters for all soil layers\n        # Only do calculation if water table is present. Calculations use equations\n        # described in Raes et al. (2012)\n        prof = self.profile\n\n        hydf = prof.groupby(\"Layer\").mean().drop([\"dz\", \"dzsum\"], axis=1)\n\n        hydf[\"aCR\"] = 0\n        hydf[\"bCR\"] = 0\n\n        for layer in hydf.index.unique():\n            layer = int(layer)\n\n            soil = hydf.loc[layer]\n\n            thwp = soil.th_wp\n            thfc = soil.th_fc\n            ths = soil.th_s\n            Ksat = soil.Ksat\n\n            # usually just initialise here (both 0), but temporarily hard-coding for sandy-loam for testing\n            aCR =  0\n            bCR =  0\n\n            # Define aCR and bCR calculations for each Soil Class \n            aCR_sandy=-0.3112 - Ksat/100000\n            bCR_sandy=-1.4936 + 0.2416*np.log(Ksat)\n\n            aCR_loamy=-0.4986 + 9*Ksat/100000\n            bCR_loamy=-2.1320 + 0.4778*np.log(Ksat)\n\n            aCR_sandy_clayey=-0.5677 - 4*Ksat/100000\n            bCR_sandy_clayey=-3.7189 + 0.5922*np.log(Ksat)\n\n            aCR_silty_clayey=-0.6366 + 8*Ksat/10000\n            bCR_silty_clayey=-1.9165 + 0.7063*np.log(Ksat)\n\n            # NEW (V7) aCR bCR calculations logic\n            # Assign aCR/bCR based on soil class definition from FAO\n            if ths &lt;= 0.55:\n                if thwp &gt;= 0.20:\n                    if (ths &gt;= 0.49) and (thfc &gt;= 0.40):\n                        aCR=aCR_silty_clayey\n                        bCR=bCR_silty_clayey\n                    else:\n                        aCR=aCR_sandy_clayey\n                        bCR=bCR_sandy_clayey\n                else:\n                    if thfc &lt; 0.23:\n                        aCR=aCR_sandy\n                        bCR=bCR_sandy\n                    else:\n                        if (thwp &gt; 0.16) and (Ksat &lt; 100):\n                            aCR=aCR_sandy_clayey\n                            bCR=bCR_sandy_clayey\n                        else:\n                            if (thwp &lt; 0.06) and (thfc &lt; 0.28) and (Ksat &gt; 750):\n                                aCR=aCR_sandy\n                                bCR=bCR_sandy\n                            else:\n                                aCR=aCR_loamy\n                                bCR=bCR_loamy\n            else:\n                aCR=aCR_silty_clayey\n                bCR=bCR_silty_clayey\n\n\n\n\n\n\n            # OLD (V6) aCR bCR calculation logic\n            # if (\n            #     (thwp &gt;= 0.04)\n            #     and (thwp &lt;= 0.15)\n            #     and (thfc &gt;= 0.09)\n            #     and (thfc &lt;= 0.28)\n            #     and (ths &gt;= 0.32)\n            #     and (ths &lt;= 0.51)\n            # ):\n\n            #     # Sandy soil class\n            #     if (Ksat &gt;= 200) and (Ksat &lt;= 2000):\n            #         aCR = -0.3112 - (Ksat * (1e-5))\n            #         bCR = -1.4936 + (0.2416 * np.log(Ksat))\n            #     elif Ksat &lt; 200:\n            #         aCR = -0.3112 - (200 * (1e-5))\n            #         bCR = -1.4936 + (0.2416 * np.log(200))\n            #     elif Ksat &gt; 2000:\n            #         aCR = -0.3112 - (2000 * (1e-5))\n            #         bCR = -1.4936 + (0.2416 * np.log(2000))\n\n            # elif (\n            #     (thwp &gt;= 0.06)\n            #     and (thwp &lt;= 0.20)\n            #     and (thfc &gt;= 0.23)\n            #     and (thfc &lt;= 0.42)\n            #     and (ths &gt;= 0.42)\n            #     and (ths &lt;= 0.55)\n            # ):\n\n            #     # Loamy soil class\n            #     if (Ksat &gt;= 100) and (Ksat &lt;= 750):\n            #         aCR = -0.4986 + (9 * (1e-5) * Ksat)\n            #         bCR = -2.132 + (0.4778 * np.log(Ksat))\n            #     elif Ksat &lt; 100:\n            #         aCR = -0.4986 + (9 * (1e-5) * 100)\n            #         bCR = -2.132 + (0.4778 * np.log(100))\n            #     elif Ksat &gt; 750:\n            #         aCR = -0.4986 + (9 * (1e-5) * 750)\n            #         bCR = -2.132 + (0.4778 * np.log(750))\n\n            # elif (\n            #     (thwp &gt;= 0.16)\n            #     and (thwp &lt;= 0.34)\n            #     and (thfc &gt;= 0.25)\n            #     and (thfc &lt;= 0.45)\n            #     and (ths &gt;= 0.40)\n            #     and (ths &lt;= 0.53)\n            # ):\n\n            #     # Sandy clayey soil class\n            #     if (Ksat &gt;= 5) and (Ksat &lt;= 150):\n            #         aCR = -0.5677 - (4 * (1e-5) * Ksat)\n            #         bCR = -3.7189 + (0.5922 * np.log(Ksat))\n            #     elif Ksat &lt; 5:\n            #         aCR = -0.5677 - (4 * (1e-5) * 5)\n            #         bCR = -3.7189 + (0.5922 * np.log(5))\n            #     elif Ksat &gt; 150:\n            #         aCR = -0.5677 - (4 * (1e-5) * 150)\n            #         bCR = -3.7189 + (0.5922 * np.log(150))\n\n            # elif (\n            #     (thwp &gt;= 0.20)\n            #     and (thwp &lt;= 0.42)\n            #     and (thfc &gt;= 0.40)\n            #     and (thfc &lt;= 0.58)\n            #     and (ths &gt;= 0.49)\n            #     and (ths &lt;= 0.58)\n            # ):\n\n            #     # Silty clayey soil class\n            #     if (Ksat &gt;= 1) and (Ksat &lt;= 150):\n            #         aCR = -0.6366 + (8 * (1e-4) * Ksat)\n            #         bCR = -1.9165 + (0.7063 * np.log(Ksat))\n            #     elif Ksat &lt; 1:\n            #         aCR = -0.6366 + (8 * (1e-4) * 1)\n            #         bCR = -1.9165 + (0.7063 * np.log(1))\n            #     elif Ksat &gt; 150:\n            #         aCR = -0.6366 + (8 * (1e-4) * 150)\n            #         bCR = -1.9165 + (0.7063 * np.log(150))\n\n            assert aCR != 0\n            assert bCR != 0\n\n            prof.loc[prof.Layer == layer, \"aCR\"] = prof.Layer.map({layer: aCR})\n            prof.loc[prof.Layer == layer, \"bCR\"] = prof.Layer.map({layer: bCR})\n\n        self.profile = prof\n</code></pre>"},{"location":"entities/#aquacrop.entities.soil.Soil.calculate_soil_hydraulic_properties","title":"<code>calculate_soil_hydraulic_properties(Sand, Clay, OrgMat, DF=1)</code>","text":"<p>Function to calculate soil hydraulic properties, given textural inputs. Calculations use pedotransfer function equations described in Saxton and Rawls (2006)</p> Source code in <code>aquacrop/entities/soil.py</code> <pre><code>def calculate_soil_hydraulic_properties(self, Sand, Clay, OrgMat, DF=1):\n\n    \"\"\"\n    Function to calculate soil hydraulic properties, given textural inputs.\n    Calculations use pedotransfer function equations described in Saxton and Rawls (2006)\n\n\n    \"\"\"\n\n    # do calculations\n\n    # Water content at permanent wilting point\n    Pred_thWP = (\n        -(0.024 * Sand)\n        + (0.487 * Clay)\n        + (0.006 * OrgMat)\n        + (0.005 * Sand * OrgMat)\n        - (0.013 * Clay * OrgMat)\n        + (0.068 * Sand * Clay)\n        + 0.031\n    )\n\n    th_wp = Pred_thWP + (0.14 * Pred_thWP) - 0.02\n\n    # Water content at field capacity and saturation\n    Pred_thFC = (\n        -(0.251 * Sand)\n        + (0.195 * Clay)\n        + (0.011 * OrgMat)\n        + (0.006 * Sand * OrgMat)\n        - (0.027 * Clay * OrgMat)\n        + (0.452 * Sand * Clay)\n        + 0.299\n    )\n\n    PredAdj_thFC = Pred_thFC + (\n        (1.283 * (np.power(Pred_thFC, 2))) - (0.374 * Pred_thFC) - 0.015\n    )\n\n    Pred_thS33 = (\n        (0.278 * Sand)\n        + (0.034 * Clay)\n        + (0.022 * OrgMat)\n        - (0.018 * Sand * OrgMat)\n        - (0.027 * Clay * OrgMat)\n        - (0.584 * Sand * Clay)\n        + 0.078\n    )\n\n    PredAdj_thS33 = Pred_thS33 + ((0.636 * Pred_thS33) - 0.107)\n    Pred_thS = (PredAdj_thFC + PredAdj_thS33) + ((-0.097 * Sand) + 0.043)\n\n    pN = (1 - Pred_thS) * 2.65\n    pDF = pN * DF\n    PorosComp = (1 - (pDF / 2.65)) - (1 - (pN / 2.65))\n    PorosCompOM = 1 - (pDF / 2.65)\n\n    DensAdj_thFC = PredAdj_thFC + (0.2 * PorosComp)\n    DensAdj_thS = PorosCompOM\n\n    th_fc = DensAdj_thFC\n    th_s = DensAdj_thS\n\n    # Saturated hydraulic conductivity (mm/day)\n    lmbda = 1 / ((np.log(1500) - np.log(33)) / (np.log(th_fc) - np.log(th_wp)))\n    Ksat = (1930 * (th_s - th_fc) ** (3 - lmbda)) * 24\n\n    # Water content at air dry\n    th_dry = th_wp / 2\n\n    # round values\n    th_dry = round(10_000 * th_dry) / 10_000\n    th_wp = round(1000 * th_wp) / 1000\n    th_fc = round(1000 * th_fc) / 1000\n    th_s = round(1000 * th_s) / 1000\n    Ksat = round(10 * Ksat) / 10\n\n    return th_wp, th_fc, th_s, Ksat\n</code></pre>"},{"location":"entities/#aquacrop.entities.soilProfile","title":"<code>aquacrop.entities.soilProfile</code>","text":""},{"location":"entities/#aquacrop.entities.soilProfile.SoilProfile","title":"<code>SoilProfile</code>","text":"<p>Attributes:</p> <p><code>Comp</code> : <code>list</code> :</p> <p><code>Layer</code> : <code>list</code> :</p> <p><code>dz</code> : <code>list</code> :</p> <p><code>dzsum</code> : <code>list</code> :</p> <p><code>zBot</code> : <code>list</code> :</p> <p><code>z_top</code> : <code>list</code> :</p> <p><code>zMid</code> : <code>list</code> :</p> Source code in <code>aquacrop/entities/soilProfile.py</code> <pre><code>class SoilProfile:\n    \"\"\"\n\n    **Attributes:**\\n\n\n    `Comp` : `list` :\n\n    `Layer` : `list` :\n\n    `dz` : `list` :\n\n    `dzsum` : `list` :\n\n    `zBot` : `list` :\n\n    `z_top` : `list` :\n\n    `zMid` : `list` :\n\n    \"\"\"\n\n    def __init__(self, length):\n\n        self.Comp = np.zeros(length, dtype=np.int64)\n        self.dz = np.zeros(length, dtype=np.float64)\n        self.Layer = np.zeros(length, dtype=np.int64)\n        self.dzsum = np.zeros(length, dtype=np.float64)\n        self.th_fc = np.zeros(length, dtype=np.float64)\n        self.th_s = np.zeros(length, dtype=np.float64)\n        self.th_wp = np.zeros(length, dtype=np.float64)\n        self.Ksat = np.zeros(length, dtype=np.float64)\n        self.Penetrability = np.zeros(length, dtype=np.float64)\n        self.th_dry = np.zeros(length, dtype=np.float64)\n        self.tau = np.zeros(length, dtype=np.float64)\n        self.zBot = np.zeros(length, dtype=np.float64)\n        self.z_top = np.zeros(length, dtype=np.float64)\n        self.zMid = np.zeros(length, dtype=np.float64)\n        self.th_fc_Adj = np.zeros(length, dtype=np.float64)\n        self.aCR = np.zeros(length, dtype=np.float64)\n        self.bCR = np.zeros(length, dtype=np.float64)\n</code></pre>"},{"location":"entities/#aquacrop.entities.temperatureStressCoefficients","title":"<code>aquacrop.entities.temperatureStressCoefficients</code>","text":""},{"location":"entities/#aquacrop.entities.temperatureStressCoefficients.Kst","title":"<code>Kst</code>","text":"<p>               Bases: <code>object</code></p> <p>TODO: THIS CLASS IS NOT USED</p> <p>temperature stress coefficients</p> <p>Attributes:</p> <p><code>PolH</code> : <code>float</code> : heat stress</p> <p><code>PolC</code> : <code>float</code> : cold stress</p> Source code in <code>aquacrop/entities/temperatureStressCoefficients.py</code> <pre><code>class Kst(object):\n\n    \"\"\"\n\n    TODO: THIS CLASS IS NOT USED\n\n    temperature stress coefficients\n\n    **Attributes:**\\n\n\n\n    `PolH` : `float` : heat stress\n\n    `PolC` : `float` : cold stress\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.PolH = 1.0\n        self.PolC = 1.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.totalAvailableWater","title":"<code>aquacrop.entities.totalAvailableWater</code>","text":""},{"location":"entities/#aquacrop.entities.totalAvailableWater.TAW","title":"<code>TAW</code>","text":"<p>TODO: THIS CLASS IS NOT USED - seems to now be in use, CB 14.09.23 Attributes:</p> <p><code>Rz</code> : <code>float</code> : .</p> <p><code>Zt</code> : <code>float</code> : .</p> Source code in <code>aquacrop/entities/totalAvailableWater.py</code> <pre><code>class TAW:\n    \"\"\"\n    TODO: THIS CLASS IS NOT USED - seems to now be in use, CB 14.09.23\n    **Attributes:**\\n\n\n\n\n    `Rz` : `float` : .\n\n    `Zt` : `float` : .\n\n\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.Rz = 0.0\n        self.Zt = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.waterEvaporation","title":"<code>aquacrop.entities.waterEvaporation</code>","text":""},{"location":"entities/#aquacrop.entities.waterEvaporation.WaterEvaporation","title":"<code>WaterEvaporation</code>","text":"<p>               Bases: <code>object</code></p> <p>TODO: THIS CLASS IS NOT USED</p> <p>stores soil water contents in the evaporation layer</p> <p>Attributes:</p> <p><code>Sat</code> : <code>float</code> :  Water storage in evaporation layer at saturation (mm)</p> <p><code>Fc</code> : <code>float</code> :  Water storage in evaporation layer at Field Capacity (mm)</p> <p><code>Wp</code> : <code>float</code>:  Water storage in evaporation layer at Wilting Point (mm)</p> <p><code>Dry</code> : <code>float</code> : Water storage in evaporation layer at air dry (mm)</p> <p><code>Act</code> : <code>float</code> : Actual Water storage in evaporation layer (mm)</p> Source code in <code>aquacrop/entities/waterEvaporation.py</code> <pre><code>class WaterEvaporation(object):\n    \"\"\"\n    TODO: THIS CLASS IS NOT USED\n\n    stores soil water contents in the evaporation layer\n\n    **Attributes:**\\n\n\n\n    `Sat` : `float` :  Water storage in evaporation layer at saturation (mm)\n\n    `Fc` : `float` :  Water storage in evaporation layer at Field Capacity (mm)\n\n    `Wp` : `float`:  Water storage in evaporation layer at Wilting Point (mm)\n\n    `Dry` : `float` : Water storage in evaporation layer at air dry (mm)\n\n    `Act` : `float` : Actual Water storage in evaporation layer (mm)\n\n    \"\"\"\n\n    def __init__(self):\n        self.Sat = 0.0\n        self.Fc = 0.0\n        self.Wp = 0.0\n        self.Dry = 0.0\n        self.Act = 0.0\n</code></pre>"},{"location":"entities/#aquacrop.entities.waterStressCoefficients","title":"<code>aquacrop.entities.waterStressCoefficients</code>","text":""},{"location":"entities/#aquacrop.entities.waterStressCoefficients.Ksw","title":"<code>Ksw</code>","text":"<p>               Bases: <code>object</code></p> <p>water stress coefficients</p> <p>Attributes:</p> <p><code>exp</code> : <code>float</code> : .</p> <p><code>sto</code> : <code>float</code> : .</p> <p><code>sen</code> : <code>float</code> : .</p> <p><code>pol</code> : <code>float</code> : .</p> <p><code>sto_lin</code> : <code>float</code> : .</p> Source code in <code>aquacrop/entities/waterStressCoefficients.py</code> <pre><code>class Ksw(object):\n\n    \"\"\"\n    water stress coefficients\n\n    **Attributes:**\\n\n\n\n    `exp` : `float` : .\n\n    `sto` : `float` : .\n\n    `sen` : `float` : .\n\n    `pol` : `float` : .\n\n    `sto_lin` : `float` : .\n\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.exp = 1.0\n        self.sto = 1.0\n        self.sen = 1.0\n        self.pol = 1.0\n        self.sto_lin = 1.0\n</code></pre>"},{"location":"initialize/","title":"initialize","text":""},{"location":"initialize/#aquacrop.initialize","title":"<code>aquacrop.initialize</code>","text":""},{"location":"initialize/#aquacrop.initialize.calculate_HI_linear","title":"<code>aquacrop.initialize.calculate_HI_linear</code>","text":""},{"location":"initialize/#aquacrop.initialize.calculate_HI_linear.calculate_HI_linear","title":"<code>calculate_HI_linear(crop_YldFormCD, crop_HIini, crop_HI0, crop_HIGC)</code>","text":"<p>Function to calculate time to switch to linear harvest index build-up, and associated linear rate of build-up. Only for fruit/grain crops.</p> <p>Reference Manual (pg. 112)</p> <p>Arguments:</p> <pre><code>crop_YldFormCD (int):  length of yield formaiton period (calendar days)\n\ncrop_HIini (float):  initial harvest index\n\ncrop_HI0 (float):  reference harvest index\n\ncrop_HIGC (float):  harvest index growth coefficent\n</code></pre> <p>Returns:</p> <pre><code>crop_tLinSwitch (float): time to switch to linear harvest index build-up\n\ncrop_dHILinear (float): linear rate of HI build-up\n</code></pre> Source code in <code>aquacrop/initialize/calculate_HI_linear.py</code> <pre><code>def calculate_HI_linear(\n    crop_YldFormCD: int,\n    crop_HIini: float,\n    crop_HI0: float,\n    crop_HIGC: float,\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Function to calculate time to switch to linear harvest index build-up,\n    and associated linear rate of build-up. Only for fruit/grain crops.\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=121\" target=\"_blank\"&gt;Reference Manual&lt;/a&gt; (pg. 112)\n\n\n    Arguments:\n\n        crop_YldFormCD (int):  length of yield formaiton period (calendar days)\n\n        crop_HIini (float):  initial harvest index\n\n        crop_HI0 (float):  reference harvest index\n\n        crop_HIGC (float):  harvest index growth coefficent\n\n\n    Returns:\n\n        crop_tLinSwitch (float): time to switch to linear harvest index build-up\n\n        crop_dHILinear (float): linear rate of HI build-up\n\n\n    \"\"\"\n    # Determine linear switch point\n    # Initialise variables\n    ti = 0\n    tmax = crop_YldFormCD\n    HIest = 0\n    HIprev = crop_HIini\n    # Iterate to find linear switch point\n    while (HIest &lt;= crop_HI0) and (ti &lt; tmax):\n        ti = ti + 1\n        HInew = (crop_HIini * crop_HI0) / (\n            crop_HIini + (crop_HI0 - crop_HIini) * np.exp(-crop_HIGC * ti)\n        )\n        HIest = HInew + (tmax - ti) * (HInew - HIprev)\n        HIprev = HInew\n\n    tSwitch = ti - 1\n\n    # Determine linear build-up rate\n    if tSwitch &gt; 0:\n        HIest = (crop_HIini * crop_HI0) / (\n            crop_HIini + (crop_HI0 - crop_HIini) * np.exp(-crop_HIGC * tSwitch)\n        )\n    else:\n        HIest = 0\n\n    dHILin = (crop_HI0 - HIest) / (tmax - tSwitch)\n\n    crop_tLinSwitch = tSwitch\n    crop_dHILinear = dHILin\n\n    return crop_tLinSwitch, crop_dHILinear\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.calculate_HIGC","title":"<code>aquacrop.initialize.calculate_HIGC</code>","text":""},{"location":"initialize/#aquacrop.initialize.calculate_HIGC.calculate_HIGC","title":"<code>calculate_HIGC(crop_YldFormCD, crop_HI0, crop_HIini)</code>","text":"<p>Function to calculate harvest index growth coefficient</p> <p>Reference Manual (pg. 110)</p> <p>Arguments:</p> <pre><code>crop_YldFormCD (int):  length of yield formation period (calendar days)\n\ncrop_HI0 (float):  reference harvest index\n\ncrop_HIini (float):  initial harvest index\n</code></pre> <p>Returns:</p> <pre><code>crop_HIGC (float): harvest index growth coefficient\n</code></pre> Source code in <code>aquacrop/initialize/calculate_HIGC.py</code> <pre><code>def calculate_HIGC(\n    crop_YldFormCD: int,\n    crop_HI0: float,\n    crop_HIini: float,\n) -&gt; float:\n    \"\"\"\n    Function to calculate harvest index growth coefficient\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual&lt;/a&gt; (pg. 110)\n\n\n    Arguments:\n\n        crop_YldFormCD (int):  length of yield formation period (calendar days)\n\n        crop_HI0 (float):  reference harvest index\n\n        crop_HIini (float):  initial harvest index\n\n\n    Returns:\n\n        crop_HIGC (float): harvest index growth coefficient\n\n\n    \"\"\"\n    # Determine HIGC\n    # Total yield_ formation days\n    tHI = crop_YldFormCD\n    # Iteratively estimate HIGC\n    HIGC = 0.001\n    HIest = 0\n    while HIest &lt;= (0.98 * crop_HI0):\n        HIGC = HIGC + 0.001\n        HIest = (crop_HIini * crop_HI0) / (\n            crop_HIini + (crop_HI0 - crop_HIini) * np.exp(-HIGC * tHI)\n        )\n\n    if HIest &gt;= crop_HI0:\n        HIGC = HIGC - 0.001\n\n    crop_HIGC = HIGC\n\n    return crop_HIGC\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.compute_crop_calendar","title":"<code>aquacrop.initialize.compute_crop_calendar</code>","text":""},{"location":"initialize/#aquacrop.initialize.compute_crop_calendar.compute_crop_calendar","title":"<code>compute_crop_calendar(crop, clock_struct_planting_dates, clock_struct_simulation_start_date, clock_struct_simulation_end_date, clock_struct_time_span, weather_df)</code>","text":"<p>Function to compute additional parameters needed to define crop phenological calendar</p> <p>Reference Manual (pg. 19-20)</p> <p>Arguments:</p> <pre><code>crop (Crop):  Crop object containing crop paramaters\n\nclock_struct_planting_dates (DatetimeIndex):  list of planting dates\n\nclock_struct_simulation_start_date (str):  sim start date\n\nclock_struct_time_span (DatetimeIndex):  all dates between sim start and end dates\n\nweather_df (DataFrame):  weather data for simulation period\n</code></pre> <p>Returns:</p> <pre><code>crop (Crop): updated Crop object\n</code></pre> Source code in <code>aquacrop/initialize/compute_crop_calendar.py</code> <pre><code>def compute_crop_calendar(\n    crop: \"Crop\",\n    clock_struct_planting_dates: \"DatetimeIndex\",\n    clock_struct_simulation_start_date: str,\n    clock_struct_simulation_end_date: str,\n    clock_struct_time_span: \"DatetimeIndex\",\n    weather_df: \"DataFrame\",\n) -&gt; \"Crop\":\n    \"\"\"\n    Function to compute additional parameters needed to define crop phenological calendar\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=28\" target=\"_blank\"&gt;Reference Manual&lt;/a&gt; (pg. 19-20)\n\n\n    Arguments:\n\n        crop (Crop):  Crop object containing crop paramaters\n\n        clock_struct_planting_dates (DatetimeIndex):  list of planting dates\n\n        clock_struct_simulation_start_date (str):  sim start date\n\n        clock_struct_time_span (DatetimeIndex):  all dates between sim start and end dates\n\n        weather_df (DataFrame):  weather data for simulation period\n\n\n    Returns:\n\n        crop (Crop): updated Crop object\n\n\n\n    \"\"\"\n\n    if len(clock_struct_planting_dates) == 0:\n        plant_year = pd.DatetimeIndex([clock_struct_simulation_start_date]).year[0]\n        if (\n            pd.to_datetime(str(plant_year) + \"/\" + crop.planting_date)\n            &lt; clock_struct_simulation_start_date\n        ):\n            pl_date = str(plant_year + 1) + \"/\" + crop.planting_date\n        else:\n            pl_date = str(plant_year) + \"/\" + crop.planting_date\n    else:\n        pl_date = clock_struct_planting_dates[0]\n\n    # Define crop calendar mode\n    Mode = crop.CalendarType\n\n    # Calculate variables %%\n    if Mode == 1:  # Growth in calendar days\n\n        # Time from sowing to end of vegatative growth period\n        if crop.Determinant == 1:\n            crop.CanopyDevEndCD = round(crop.HIstartCD + (crop.FloweringCD / 2))\n        else:\n            crop.CanopyDevEndCD = crop.SenescenceCD\n\n        # Time from sowing to 10% canopy cover (non-stressed conditions)\n        crop.Canopy10PctCD = round(\n            crop.EmergenceCD + (np.log(0.1 / crop.CC0) / crop.CGC_CD)\n        )\n\n        # Time from sowing to maximum canopy cover (non-stressed conditions)\n        crop.MaxCanopyCD = round(\n            crop.EmergenceCD\n            + (\n                np.log(\n                    (0.25 * crop.CCx * crop.CCx / crop.CC0)\n                    / (crop.CCx - (0.98 * crop.CCx))\n                )\n                / crop.CGC_CD\n            )\n        )\n\n        # Time from sowing to end of yield_ formation\n        crop.HIendCD = crop.HIstartCD + crop.YldFormCD\n\n        # Duplicate calendar values (needed to minimise if\n        # statements when switching between gdd and CD runs)\n        crop.Emergence = crop.EmergenceCD\n        crop.Canopy10Pct = crop.Canopy10PctCD\n        crop.MaxRooting = crop.MaxRootingCD\n        crop.Senescence = crop.SenescenceCD\n        crop.Maturity = crop.MaturityCD\n        crop.MaxCanopy = crop.MaxCanopyCD\n        crop.CanopyDevEnd = crop.CanopyDevEndCD\n        crop.HIstart = crop.HIstartCD\n        crop.HIend = crop.HIendCD\n        crop.YldForm = crop.YldFormCD\n        if crop.CropType == 3:\n            crop.FloweringEndCD = crop.HIstartCD + crop.FloweringCD\n            # crop.FloweringEndCD = crop.FloweringEnd\n            # crop.FloweringCD = crop.Flowering\n        else:\n            crop.FloweringEnd = ModelConstants.NO_VALUE\n            crop.FloweringEndCD = ModelConstants.NO_VALUE\n            crop.FloweringCD = ModelConstants.NO_VALUE\n\n        # Check if converting crop calendar to gdd mode\n        if crop.SwitchGDD == 1:\n            #             # Extract weather data for first growing season that crop is planted\n            #             for i,n in enumerate(ParamStruct.CropChoices):\n            #                 if n == crop.Name:\n            #                     idx = i\n            #                     break\n            #                 else:\n            #                     idx = -1\n            #             assert idx &gt; -1\n\n            date_range = pd.date_range(pl_date, clock_struct_time_span[-1])\n            weather_df = weather_df.copy()\n            weather_df.index = weather_df.Date\n            weather_df = weather_df.loc[date_range]\n            temp_min = weather_df.MinTemp\n            temp_max = weather_df.MaxTemp\n\n            # Calculate gdd's\n            if crop.GDDmethod == 1:\n\n                Tmean = (temp_max + temp_min) / 2\n                Tmean = Tmean.clip(lower=crop.Tbase, upper=crop.Tupp)\n                gdd = Tmean - crop.Tbase\n\n            elif crop.GDDmethod == 2:\n\n                temp_max = temp_max.clip(lower=crop.Tbase, upper=crop.Tupp)\n                temp_min = temp_min.clip(lower=crop.Tbase, upper=crop.Tupp)\n                Tmean = (temp_max + temp_min) / 2\n                gdd = Tmean - crop.Tbase\n\n            elif crop.GDDmethod == 3:\n\n                temp_max = temp_max.clip(lower=crop.Tbase, upper=crop.Tupp)\n                temp_min = temp_min.clip(upper=crop.Tupp)\n                Tmean = (temp_max + temp_min) / 2\n                Tmean = Tmean.clip(lower=crop.Tbase)\n                gdd = Tmean - crop.Tbase\n\n            crop = prepare_gdd(weather_df, \n                               clock_struct_simulation_start_date,\n                               clock_struct_simulation_end_date, \n                               gdd, crop, crop.SwitchGDDType)\n\n            # Convert CGC to gdd mode\n            # crop.CGC_CD = crop.CGC\n            crop.CGC = (\n                np.log(\n                    (((0.98 * crop.CCx) - crop.CCx) * crop.CC0)\n                    / (-0.25 * (crop.CCx**2))\n                )\n            ) / (-(crop.MaxCanopy - crop.Emergence))\n\n            # Convert CDC to gdd mode\n            # crop.CDC_CD = crop.CDC\n            tCD = crop.MaturityCD - crop.SenescenceCD\n            if tCD &lt;= 0:\n                tCD = 1\n\n            CCi = crop.CCx * (1 - 0.05 * (np.exp(((3.33 * crop.CDC_CD) / (crop.CCx + 2.29)) * tCD) - 1))\n            if CCi &lt; 0:\n                CCi = 0\n\n            tGDD = crop.Maturity - crop.Senescence\n            if tGDD &lt;= 0:\n                tGDD = 5\n\n            crop.CDC = ((crop.CCx + 2.29) * np.log((((CCi/crop.CCx) - 1) / -0.05) + 1)) / (3.33 * tGDD) \n            # Set calendar type to gdd mode\n            crop.CalendarType = 2\n\n        else:\n            crop.CDC = crop.CDC_CD\n            crop.CGC = crop.CGC_CD\n\n    elif Mode == 2:\n        # Growth in growing degree days\n        # Time from sowing to end of vegatative growth period\n        if crop.Determinant == 1:\n            crop.CanopyDevEnd = round(crop.HIstart + (crop.Flowering / 2))\n        else:\n            crop.CanopyDevEnd = crop.Senescence\n\n        # Time from sowing to 10# canopy cover (non-stressed conditions)\n        crop.Canopy10Pct = round(crop.Emergence + (np.log(0.1 / crop.CC0) / crop.CGC))\n\n        # Time from sowing to maximum canopy cover (non-stressed conditions)\n        crop.MaxCanopy = round(\n            crop.Emergence\n            + (\n                np.log(\n                    (0.25 * crop.CCx * crop.CCx / crop.CC0)\n                    / (crop.CCx - (0.98 * crop.CCx))\n                )\n                / crop.CGC\n            )\n        )\n\n        # Time from sowing to end of yield_ formation\n        crop.HIend = crop.HIstart + crop.YldForm\n\n        # Time from sowing to end of flowering (if fruit/grain crop)\n        if crop.CropType == 3:\n            crop.FloweringEnd = crop.HIstart + crop.Flowering\n\n        # Extract weather data for first growing season that crop is planted\n        #         for i,n in enumerate(ParamStruct.CropChoices):\n        #             if n == crop.Name:\n        #                 idx = i\n        #                 break\n        #             else:\n        #                 idx = -1\n        #         assert idx&gt; -1\n        date_range = pd.date_range(pl_date, clock_struct_time_span[-1])\n        weather_df = weather_df.copy()\n        weather_df.index = weather_df.Date\n\n        weather_df = weather_df.loc[date_range]\n        temp_min = weather_df.MinTemp\n        temp_max = weather_df.MaxTemp\n\n        # Calculate gdd's\n        if crop.GDDmethod == 1:\n\n            Tmean = (temp_max + temp_min) / 2\n            Tmean = Tmean.clip(lower=crop.Tbase, upper=crop.Tupp)\n            gdd = Tmean - crop.Tbase\n\n        elif crop.GDDmethod == 2:\n\n            temp_max = temp_max.clip(lower=crop.Tbase, upper=crop.Tupp)\n            temp_min = temp_min.clip(lower=crop.Tbase, upper=crop.Tupp)\n            Tmean = (temp_max + temp_min) / 2\n            gdd = Tmean - crop.Tbase\n\n        elif crop.GDDmethod == 3:\n\n            temp_max = temp_max.clip(lower=crop.Tbase, upper=crop.Tupp)\n            temp_min = temp_min.clip(upper=crop.Tupp)\n            Tmean = (temp_max + temp_min) / 2\n            Tmean = Tmean.clip(lower=crop.Tbase)\n            gdd = Tmean - crop.Tbase\n\n        gdd_cum = np.cumsum(gdd).reset_index(drop=True)\n\n        assert (\n            gdd_cum.values[-1] &gt; crop.Maturity\n        ), f\"not enough growing degree days in simulation ({gdd_cum.values[-1]}) to reach maturity ({crop.Maturity})\"\n\n        crop.MaturityCD = (gdd_cum &gt; crop.Maturity).idxmax() + 1\n\n        assert crop.MaturityCD &lt; 365, \"crop will take longer than 1 year to mature\"\n\n        # 1. gdd's from sowing to maximum canopy cover\n        crop.MaxCanopyCD = (gdd_cum &gt; crop.MaxCanopy).idxmax() + 1\n        # 2. gdd's from sowing to end of vegetative growth\n        crop.CanopyDevEndCD = (gdd_cum &gt; crop.CanopyDevEnd).idxmax() + 1\n        # 3. Calendar days from sowing to start of yield_ formation\n        crop.HIstartCD = (gdd_cum &gt; crop.HIstart).idxmax() + 1\n        # 4. Calendar days from sowing to end of yield_ formation\n        crop.HIendCD = (gdd_cum &gt; crop.HIend).idxmax() + 1\n        # 5. Duration of yield_ formation in calendar days\n        crop.YldFormCD = crop.HIendCD - crop.HIstartCD\n        if crop.CropType == 3:\n            # 1. Calendar days from sowing to end of flowering\n            FloweringEnd = (gdd_cum &gt; crop.FloweringEnd).idxmax() + 1\n            # 2. Duration of flowering in calendar days\n            crop.FloweringCD = FloweringEnd - crop.HIstartCD\n        else:\n            crop.FloweringCD = ModelConstants.NO_VALUE\n\n    return crop\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.compute_variables","title":"<code>aquacrop.initialize.compute_variables</code>","text":""},{"location":"initialize/#aquacrop.initialize.compute_variables.compute_variables","title":"<code>compute_variables(param_struct, weather_df, clock_struct, acfp=dirname(dirname(abspath(__file__))))</code>","text":"<p>Function to compute additional variables needed to run the model eg. CO2</p> <p>Arguments:</p> <pre><code>param_struct (ParamStruct):  Contains model paramaters\n\nweather_df (DataFrame):  weather data\n\nclock_struct (ClockStruct):  time params\n\nacfp (Path):  path to aquacrop directory containing co2 data\n</code></pre> <p>Returns:</p> <pre><code>param_struct (ParamStruct):  updated model params\n</code></pre> Source code in <code>aquacrop/initialize/compute_variables.py</code> <pre><code>def compute_variables(\n    param_struct: \"ParamStruct\",\n    weather_df: \"DataFrame\",\n    clock_struct: \"ClockStruct\",\n    acfp: str = dirname(dirname(abspath(__file__))),\n) -&gt; \"ParamStruct\":\n    \"\"\"\n    Function to compute additional variables needed to run the model eg. CO2\n\n    Arguments:\n\n        param_struct (ParamStruct):  Contains model paramaters\n\n        weather_df (DataFrame):  weather data\n\n        clock_struct (ClockStruct):  time params\n\n        acfp (Path):  path to aquacrop directory containing co2 data\n\n    Returns:\n\n        param_struct (ParamStruct):  updated model params\n\n\n    \"\"\"\n\n    if param_struct.water_table == 1:\n\n        param_struct.Soil.add_capillary_rise_params()\n\n    # Calculate readily evaporable water in surface layer\n    if param_struct.Soil.adj_rew == 0:\n        param_struct.Soil.rew = round(\n            (\n                1000\n                * (\n                    param_struct.Soil.profile.th_fc.iloc[0]\n                    - param_struct.Soil.profile.th_dry.iloc[0]\n                )\n                * param_struct.Soil.evap_z_surf\n            ),\n            2,\n        )\n\n    if param_struct.Soil.calc_cn == 1:\n        # adjust curve number\n        ksat = param_struct.Soil.profile.Ksat.iloc[0]\n        if ksat &gt; 864:\n            param_struct.Soil.cn = 46\n        elif ksat &gt; 347:\n            param_struct.Soil.cn = 61\n        elif ksat &gt; 36:\n            param_struct.Soil.cn = 72\n        elif ksat &gt; 0:\n            param_struct.Soil.cn = 77\n\n        assert ksat &gt; 0\n\n    for i in range(param_struct.NCrops):\n\n        crop = param_struct.CropList[i]\n        # crop.calculate_additional_params()\n\n        # Crop calander\n        crop = compute_crop_calendar(\n            crop,\n            clock_struct.planting_dates,\n            clock_struct.simulation_start_date,\n            clock_struct.simulation_end_date,\n            clock_struct.time_span,\n            weather_df,\n        )\n\n        # Harvest index param_struct.Seasonal_Crop_List[clock_struct.season_counter].Paramsgrowth coefficient\n        crop.HIGC = calculate_HIGC(\n            crop.YldFormCD,\n            crop.HI0,\n            crop.HIini,\n        )\n\n        # Days to linear harvest_index switch point\n        if crop.CropType == 3:\n            # Determine linear switch point and HIGC rate for fruit/grain crops\n            crop.tLinSwitch, crop.dHILinear = calculate_HI_linear(\n                crop.YldFormCD, crop.HIini, crop.HI0, crop.HIGC\n            )\n        else:\n            # No linear switch for leafy vegetable or root/tiber crops\n            crop.tLinSwitch = 0\n            crop.dHILinear = 0.0\n\n        param_struct.CropList[i] = crop\n\n    # Calculate WP adjustment factor for elevation in CO2 concentration\n    # Load CO2 data\n    co2Data = param_struct.CO2.co2_data\n\n    # Years\n    start_year, end_year = pd.DatetimeIndex(\n        [clock_struct.simulation_start_date, clock_struct.simulation_end_date]\n    ).year\n    sim_years = np.arange(start_year, end_year + 1)\n\n    # Interpolate data\n    CO2conc_interp = np.interp(sim_years, co2Data.year, co2Data.ppm)\n\n    # Store data\n    param_struct.CO2.co2_data_processed = pd.Series(CO2conc_interp, index=sim_years)  # maybe get rid of this\n\n    # Get CO2 concentration for first year\n    CO2conc = param_struct.CO2.co2_data_processed.iloc[0]\n\n    # param_struct.CO2 = param_struct.co2_concentration_adj\n\n    # if user specified constant concentration\n    if  param_struct.CO2.constant_conc is True:\n        if param_struct.CO2.current_concentration &gt; 0.:\n            CO2conc = param_struct.CO2.current_concentration\n        else:\n            CO2conc = param_struct.CO2.co2_data_processed.iloc[0]\n\n    param_struct.CO2.current_concentration = CO2conc\n\n    CO2ref = param_struct.CO2.ref_concentration\n\n    # Get CO2 weighting factor for first year\n    if CO2conc &lt;= CO2ref:\n        fw = 0\n    else:\n        if CO2conc &gt;= 550:\n            fw = 1\n        else:\n            fw = 1 - ((550 - CO2conc) / (550 - CO2ref))\n\n    # Determine adjustment for each crop in first year of simulation\n    for i in range(param_struct.NCrops):\n        crop = param_struct.CropList[i]\n        # Determine initial adjustment\n        fCO2old = (CO2conc / CO2ref) / (\n            1\n            + (CO2conc - CO2ref)\n            * (\n                (1 - fw) * crop.bsted\n                + fw * ((crop.bsted * crop.fsink) + (crop.bface * (1 - crop.fsink)))\n            )\n        )\n        # New adjusted correction coefficient for CO2 (version 7 of AquaCrop)\n    if (CO2conc &gt; CO2ref):\n        # Calculate shape factor\n        fshape = -4.61824 - 3.43831*crop.fsink - 5.32587*crop.fsink*crop.fsink\n        # Determine adjustment for CO2\n        if (CO2conc &gt;= 2000):\n            fCO2new = 1.58  # Maximum CO2 adjustment \n        else:\n            CO2rel = (CO2conc-CO2ref)/(2000-CO2ref)\n            fCO2new = 1 + 0.58 * ((np.exp(CO2rel*fshape) - 1)/(np.exp(fshape) - 1))\n\n\n    # Select adjusted coefficient for CO2\n    if (CO2conc &lt;= CO2ref):\n        fCO2 = fCO2old\n    elif ((CO2conc &lt;= 550) and (fCO2old &lt; fCO2new)):\n        fCO2 = fCO2old\n    else:\n        fCO2 = fCO2new\n\n        # Consider crop type\n    if crop.WP &gt;= 40:\n        # No correction for C4 crops\n        ftype = 0\n    elif crop.WP &lt;= 20:\n        # Full correction for C3 crops\n        ftype = 1\n    else:\n        ftype = (40 - crop.WP) / (40 - 20)\n\n        # Total adjustment\n    crop.fCO2 = 1 + ftype * (fCO2 - 1)\n\n    param_struct.CropList[i] = crop\n\n\n    # change this later\n    if param_struct.NCrops == 1:\n        crop_list = [\n            deepcopy(param_struct.CropList[0])\n            for i in range(len(param_struct.CropChoices))\n        ]\n        # param_struct.Seasonal_Crop_List = [deepcopy(param_struct.CropList[0]) for i in range(len(param_struct.CropChoices))]\n\n    else:\n        crop_list = param_struct.CropList\n\n    # add crop for out of growing season\n    # param_struct.Fallow_Crop = deepcopy(param_struct.Seasonal_Crop_List[0])\n    Fallow_Crop = deepcopy(crop_list[0])\n\n    param_struct.Seasonal_Crop_List = []\n\n    for crop in crop_list:\n        #crop_struct = Crop(crop.Name, crop.planting_date) # changed from CropStruct to Crop during removal of numba AOT/JIT compilation\n        #for a, v in crop.__dict__.items():\n        #    if hasattr(crop_struct, a):\n        #        crop_struct.__setattr__(a, v)\n\n        param_struct.Seasonal_Crop_List.append(crop)\n\n    fallow_struct = Crop(crop.Name, crop.planting_date) # changed from CropStruct to Crop during removal of numba AOT/JIT compilation\n    for a, v in Fallow_Crop.__dict__.items():\n        if hasattr(fallow_struct, a):\n            fallow_struct.__setattr__(a, v)\n\n    param_struct.Fallow_Crop = fallow_struct\n\n    return param_struct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.create_soil_profile","title":"<code>aquacrop.initialize.create_soil_profile</code>","text":""},{"location":"initialize/#aquacrop.initialize.create_soil_profile.create_soil_profile","title":"<code>create_soil_profile(param_struct)</code>","text":"<p>funciton to create soil profile namedTuple to store soil info. Its much faster to access the info when its in a namedTuple compared to a dataframe</p> <p>Arguments:</p> <pre><code>param_struct (ParamStruct):  Contains model crop and soil paramaters\n</code></pre> <p>Returns:</p> <pre><code>param_struct (ParamStruct):  updated with soil profile\n</code></pre> Source code in <code>aquacrop/initialize/create_soil_profile.py</code> <pre><code>def create_soil_profile(param_struct: \"ParamStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    funciton to create soil profile namedTuple to store soil info.\n    Its much faster to access the info when its in a namedTuple\n    compared to a dataframe\n\n    Arguments:\n\n        param_struct (ParamStruct):  Contains model crop and soil paramaters\n\n    Returns:\n\n        param_struct (ParamStruct):  updated with soil profile\n\n\n    \"\"\"\n\n    profile = SoilProfile(int(param_struct.Soil.profile.shape[0]))\n\n    pdf = param_struct.Soil.profile.astype(\"float64\")\n\n    profile.dz = pdf.dz.values\n    profile.dzsum = pdf.dzsum.values\n    profile.zBot = pdf.zBot.values\n    profile.z_top = pdf.z_top.values\n    profile.zMid = pdf.zMid.values\n\n    profile.Comp = np.int64(pdf.Comp.values)\n    profile.Layer = np.int64(pdf.Layer.values)\n    # profile.Layer_dz = pdf.Layer_dz.values\n    profile.th_wp = pdf.th_wp.values\n    profile.th_fc = pdf.th_fc.values\n    profile.th_s = pdf.th_s.values\n\n    profile.Ksat = pdf.Ksat.values\n    profile.Penetrability = pdf.penetrability.values\n    profile.th_dry = pdf.th_dry.values\n    profile.tau = pdf.tau.values\n    profile.th_fc_Adj = pdf.th_fc_Adj.values\n\n    if param_struct.water_table == 1:\n        profile.aCR = pdf.aCR.values\n        profile.bCR = pdf.bCR.values\n    else:\n        profile.aCR = pdf.dz.values * 0.0\n        profile.bCR = pdf.dz.values * 0.0\n\n    # param_struct.Soil.profile = profile\n\n    param_struct.Soil.Profile = profile\n\n    return param_struct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_clocks_parameters","title":"<code>aquacrop.initialize.read_clocks_parameters</code>","text":"<p>Inititalize clocks parameters</p>"},{"location":"initialize/#aquacrop.initialize.read_clocks_parameters.check_max_simulation_days","title":"<code>check_max_simulation_days(sim_start_time, sim_end_time)</code>","text":"<p>Check that the date range of the simulation is less than 580 years. In pandas this cannot happen due to the size of the variable</p> <p>Arguments:</p> <pre><code>sim_start_time (str): simulation start date YYYY/MM/DD\n\nsim_end_time (str): simulation start date YYYY/MM/DD\n</code></pre> Source code in <code>aquacrop/initialize/read_clocks_parameters.py</code> <pre><code>def check_max_simulation_days(\n    sim_start_time: str,\n    sim_end_time: str):\n    \"\"\"\n    Check that the date range of the simulation is less than 580 years.\n    In pandas this cannot happen due to the size of the variable\n\n    Arguments:\n\n        sim_start_time (str): simulation start date YYYY/MM/DD\n\n        sim_end_time (str): simulation start date YYYY/MM/DD\n\n    \"\"\"\n    start_year = int(sim_start_time.split(\"/\")[0])\n    end_year = int(sim_end_time.split(\"/\")[0])\n    if (end_year - start_year) &gt; 580:\n        raise ValueError(\"Simulation period must be less than 580 years.\")\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_clocks_parameters.read_clock_parameters","title":"<code>read_clock_parameters(sim_start_time, sim_end_time, off_season=False)</code>","text":"<p>Function to read in start and end simulation time and return a ClockStruct object</p> <p>Arguments:</p> <pre><code>sim_start_time (str): simulation start date\n\nsim_end_time (str): simulation start date\n\noff_season (bool): True, simulate off season\n                  False, skip ahead to next season post-harvest\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct): simulation time paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_clocks_parameters.py</code> <pre><code>def read_clock_parameters(\n    sim_start_time: str,\n    sim_end_time: str,\n    off_season: bool=False) -&gt; ClockStruct:\n    \"\"\"\n    Function to read in start and end simulation time and return a ClockStruct object\n\n    Arguments:\n\n        sim_start_time (str): simulation start date\n\n        sim_end_time (str): simulation start date\n\n        off_season (bool): True, simulate off season\n                          False, skip ahead to next season post-harvest\n\n    Returns:\n\n        clock_struct (ClockStruct): simulation time paramaters\n\n\n    \"\"\"\n    check_max_simulation_days(sim_start_time, sim_end_time)\n\n    # Extract data and put into pandas datetime format\n    pandas_sim_start_time = pd.to_datetime(sim_start_time)\n    pandas_sim_end_time = pd.to_datetime(sim_end_time)\n\n    # create ClockStruct object\n    clock_struct = ClockStruct()\n\n    # Add variables\n    clock_struct.simulation_start_date = pandas_sim_start_time\n    clock_struct.simulation_end_date = pandas_sim_end_time\n\n    clock_struct.n_steps = (pandas_sim_end_time - pandas_sim_start_time).days + 1\n    clock_struct.time_span = pd.date_range(\n        freq=\"D\", start=pandas_sim_start_time, end=pandas_sim_end_time\n    )\n\n    clock_struct.step_start_time = clock_struct.time_span[0]\n    clock_struct.step_end_time = clock_struct.time_span[1]\n\n    clock_struct.sim_off_season = off_season\n\n    return clock_struct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_field_managment","title":"<code>aquacrop.initialize.read_field_managment</code>","text":""},{"location":"initialize/#aquacrop.initialize.read_field_managment.read_field_management","title":"<code>read_field_management(ParamStruct, FieldMngt, FallowFieldMngt)</code>","text":"<p>store field management variables as FieldMngtStruct object</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\nFieldMngt (FieldMngt):  field mngt params\n\nFallowFieldMngt (FieldMngt): fallow field mngt params\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated ParamStruct with field management info\n</code></pre> Source code in <code>aquacrop/initialize/read_field_managment.py</code> <pre><code>def read_field_management(\n    ParamStruct: \"ParamStruct\",\n    FieldMngt: \"FieldMngt\",\n    FallowFieldMngt: \"FieldMngt\") -&gt; \"ParamStruct\":\n\n    \"\"\"\n    store field management variables as FieldMngtStruct object\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\n        FieldMngt (FieldMngt):  field mngt params\n\n        FallowFieldMngt (FieldMngt): fallow field mngt params\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated ParamStruct with field management info\n\n\n    \"\"\"\n\n    field_mngt_struct = FieldMngtStruct()\n    for a, v in FieldMngt.__dict__.items():\n        if hasattr(field_mngt_struct, a):\n            field_mngt_struct.__setattr__(a, v)\n\n    fallow_field_mngt_struct = FieldMngtStruct()\n    for a, v in FallowFieldMngt.__dict__.items():\n        if hasattr(fallow_field_mngt_struct, a):\n            fallow_field_mngt_struct.__setattr__(a, v)\n\n    ParamStruct.FieldMngt = field_mngt_struct\n    ParamStruct.FallowFieldMngt = fallow_field_mngt_struct\n\n    return ParamStruct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_groundwater_table","title":"<code>aquacrop.initialize.read_groundwater_table</code>","text":""},{"location":"initialize/#aquacrop.initialize.read_groundwater_table.read_groundwater_table","title":"<code>read_groundwater_table(ParamStruct, GwStruct, ClockStruct)</code>","text":"<p>Function to initialise groundwater parameters</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct): Contains model paramaters\n\nGwStruct (GroundWater): groundwater params\n\nClockStruct (ClockStruct): time params\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct): updated with GW info\n</code></pre> Source code in <code>aquacrop/initialize/read_groundwater_table.py</code> <pre><code>def read_groundwater_table(\n    ParamStruct: \"ParamStruct\",\n    GwStruct: \"GroundWater\",\n    ClockStruct: \"ClockStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    Function to initialise groundwater parameters\n\n    Arguments:\n\n        ParamStruct (ParamStruct): Contains model paramaters\n\n        GwStruct (GroundWater): groundwater params\n\n        ClockStruct (ClockStruct): time params\n\n    Returns:\n\n        ParamStruct (ParamStruct): updated with GW info\n\n    \"\"\"\n\n    # assign water table value and method\n    WT = GwStruct.water_table\n    WTMethod = GwStruct.method\n\n    # check if water table present\n    if WT == \"N\":\n        ParamStruct.water_table = 0\n        ParamStruct.z_gw = 999 * np.ones(len(ClockStruct.time_span))\n        ParamStruct.zGW_dates = ClockStruct.time_span\n        ParamStruct.WTMethod = \"None\"\n    elif WT == \"Y\":\n        ParamStruct.water_table = 1\n\n        df = pd.DataFrame([GwStruct.dates, GwStruct.values]).T\n        df.columns = [\"Date\", \"Depth(mm)\"]\n\n        # get date in correct format\n        df.Date = pd.DatetimeIndex(df.Date)\n        # print(f'DF length: {len(df)}')\n        # print(f'Index length: {len(df.index)}')\n\n        if len(df) == 1:\n\n            # if only 1 watertable depth then set that value to be constant\n            # accross whole simulation            \n            z_gw = pd.DataFrame(\n                data=df[\"Depth(mm)\"].iloc[0]*np.ones(len(ClockStruct.time_span)),\n                index=pd.to_datetime(ClockStruct.time_span),\n                columns=['Depth(mm)']\n            )['Depth(mm)']\n\n        elif len(df) &gt; 1:\n            # check water table method\n            if WTMethod == \"Constant\":\n\n                # No interpolation between dates\n\n                # create daily depths for each simulation day\n                z_gw = pd.Series(\n                    np.nan * np.ones(len(ClockStruct.time_span)), index=ClockStruct.time_span\n                )\n\n                # assign constant depth for all dates in between\n                for row in range(len(df)):\n                    date = df.Date.iloc[row]\n                    depth = df[\"Depth(mm)\"].iloc[row]\n                    z_gw.loc[z_gw.index &gt;= date] = depth\n                    if row == 0:\n                        z_gw.loc[z_gw.index &lt;= date] = depth\n\n            elif WTMethod == \"Variable\":\n\n                # Linear interpolation between dates\n\n                # create daily depths for each simulation day\n                # fill unspecified days with NaN\n                z_gw = pd.Series(\n                    np.nan * np.ones(len(ClockStruct.time_span)), index=ClockStruct.time_span\n                )\n\n                for row in range(len(df)):\n                    date = df.Date.iloc[row]\n                    depth = df[\"Depth(mm)\"].iloc[row]\n                    z_gw.loc[date] = depth\n\n                # Interpolate daily groundwater depths\n                z_gw = z_gw.interpolate()\n\n        # assign values to Paramstruct object\n        ParamStruct.z_gw = z_gw.values\n        ParamStruct.zGW_dates = z_gw.index.values\n        ParamStruct.WTMethod = WTMethod\n\n    return ParamStruct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_irrigation_management","title":"<code>aquacrop.initialize.read_irrigation_management</code>","text":""},{"location":"initialize/#aquacrop.initialize.read_irrigation_management.read_irrigation_management","title":"<code>read_irrigation_management(ParamStruct, IrrMngt, ClockStruct)</code>","text":"<p>initilize irrigation management and store as IrrMngtStruct object</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\nIrrMngt (IrrigationManagement):  irr mngt params object\n\nClockStruct (ClockStruct):  time paramaters\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated model paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_irrigation_management.py</code> <pre><code>def read_irrigation_management(\n    ParamStruct: \"ParamStruct\",\n    IrrMngt: \"IrrigationManagement\",\n    ClockStruct: \"ClockStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    initilize irrigation management and store as IrrMngtStruct object\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\n        IrrMngt (IrrigationManagement):  irr mngt params object\n\n        ClockStruct (ClockStruct):  time paramaters\n\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated model paramaters\n\n\n\n    \"\"\"\n    # If specified, read input irrigation time-series\n    if IrrMngt.irrigation_method == 3:\n\n        df = IrrMngt.Schedule.copy()\n        # change the index to the date\n        df.index = pd.DatetimeIndex(df.Date)\n\n        try:\n            # create a dateframe containing the daily irrigation to\n            # be applied for every day in the simulation\n            df = df.reindex(ClockStruct.time_span, fill_value=0).drop(\"Date\", axis=1)\n\n            IrrMngt.Schedule = np.array(df.values, dtype=float).flatten()\n\n        except TypeError:\n            # older version of pandas with not reindex\n\n            # create new dataframe for whole simulation\n            # populate new dataframe with old values\n            new_df = pd.DataFrame(data=np.zeros(len(ClockStruct.time_span)),\n                index=pd.to_datetime(ClockStruct.time_span),\n                columns=['Depth']\n                )\n\n            # fill in the new dataframe with irrigation schedule\n            new_df.loc[df.index]=df.Depth.values\n\n            IrrMngt.Schedule = np.array(new_df.values, dtype=float).flatten()\n\n    else:\n\n        IrrMngt.Schedule = np.zeros(len(ClockStruct.time_span))\n\n    IrrMngt.SMT = np.array(IrrMngt.SMT, dtype=float)\n\n    irr_mngt_struct = IrrMngtStruct(len(ClockStruct.time_span))\n    for a, v in IrrMngt.__dict__.items():\n        if hasattr(irr_mngt_struct, a):\n            irr_mngt_struct.__setattr__(a, v)\n\n    ParamStruct.IrrMngt = irr_mngt_struct\n    ParamStruct.FallowIrrMngt = IrrMngtStruct(len(ClockStruct.time_span))\n\n    return ParamStruct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_model_initial_conditions","title":"<code>aquacrop.initialize.read_model_initial_conditions</code>","text":""},{"location":"initialize/#aquacrop.initialize.read_model_initial_conditions.read_model_initial_conditions","title":"<code>read_model_initial_conditions(ParamStruct, ClockStruct, InitWC, crop)</code>","text":"<p>Function to set up initial model conditions</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model paramaters\n\nClockStruct (ClockStruct):  time paramaters\n\nInitWC (InitialWaterContent):  initial water content\n\ncrop (Crop): crop parameters\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated ParamStruct object\n\nInitCond (InitialCondition):  containing initial model conditions/counters\n</code></pre> Source code in <code>aquacrop/initialize/read_model_initial_conditions.py</code> <pre><code>def read_model_initial_conditions(\n    ParamStruct: \"ParamStruct\",\n    ClockStruct: \"ClockStruct\",\n    InitWC: \"InitialWaterContent\",\n    crop: \"Crop\") -&gt; Tuple[\"ParamStruct\", \"InitialCondition\"]:\n    \"\"\"\n    Function to set up initial model conditions\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model paramaters\n\n        ClockStruct (ClockStruct):  time paramaters\n\n        InitWC (InitialWaterContent):  initial water content\n\n        crop (Crop): crop parameters\n\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated ParamStruct object\n\n        InitCond (InitialCondition):  containing initial model conditions/counters\n\n    \"\"\"\n\n    ###################\n    # creat initial condition class\n    ###################\n\n    InitCond = InitialCondition(len(ParamStruct.Soil.profile))\n\n    # class_args = {key:value for key, value in InitCond_class.__dict__.items() if not key.startswith('__') and not callable(key)}\n    # InitCond = InitCondStruct(**class_args)\n\n    if ClockStruct.season_counter == -1:\n        InitCond.z_root = 0.\n        InitCond.cc0_adj = 0.\n\n    elif ClockStruct.season_counter == 0:\n        InitCond.z_root = ParamStruct.Seasonal_Crop_List[0].Zmin\n        InitCond.cc0_adj = ParamStruct.Seasonal_Crop_List[0].CC0\n\n    # Set HIfinal to crop's reference harvest index\n    InitCond.HIfinal = crop.HI0\n\n    ##################\n    # save field management\n    ##################\n\n    # Initial surface storage between any soil bunds\n    if ClockStruct.season_counter == -1:\n        # First day of simulation is in fallow period\n        if (ParamStruct.FallowFieldMngt.bunds) and (\n            float(ParamStruct.FallowFieldMngt.z_bund) &gt; 0.001\n        ):\n            # Get initial storage between surface bunds\n            InitCond.surface_storage = float(ParamStruct.FallowFieldMngt.bund_water)\n            if InitCond.surface_storage &gt; float(ParamStruct.FallowFieldMngt.z_bund):\n                InitCond.surface_storage = float(ParamStruct.FallowFieldMngt.z_bund)\n        else:\n            # No surface bunds\n            InitCond.surface_storage = 0\n\n    elif ClockStruct.season_counter == 0:\n        # First day of simulation is in first growing season\n        # Get relevant field management structure parameters\n        FieldMngtTmp = ParamStruct.FieldMngt\n        if (FieldMngtTmp.bunds) and (float(FieldMngtTmp.z_bund) &gt; 0.001):\n            # Get initial storage between surface bunds\n            InitCond.surface_storage = float(FieldMngtTmp.bund_water)\n            if InitCond.surface_storage &gt; float(FieldMngtTmp.z_bund):\n                InitCond.surface_storage = float(FieldMngtTmp.z_bund)\n        else:\n            # No surface bunds\n            InitCond.surface_storage = 0\n\n    ############\n    # watertable\n    ############\n\n    profile = ParamStruct.Soil.profile\n\n    # Check for presence of groundwater table\n    if ParamStruct.water_table == 0:  # No water table present\n        # Set initial groundwater level to dummy value\n        InitCond.z_gw = ModelConstants.NO_VALUE\n        InitCond.wt_in_soil = False\n        # Set adjusted field capacity to default field capacity\n        InitCond.th_fc_Adj = profile.th_fc.values\n    elif ParamStruct.water_table == 1:  # Water table is present\n        # Set initial groundwater level\n        InitCond.z_gw = float(ParamStruct.z_gw[ClockStruct.time_step_counter])\n        # Find compartment mid-points\n        zMid = profile.zMid\n        # Check if water table is within modelled soil profile\n        if InitCond.z_gw &gt;= 0:\n            idx = zMid[zMid &gt;= InitCond.z_gw].index\n            if idx.shape[0] == 0:\n                InitCond.wt_in_soil = False\n            else:\n                InitCond.wt_in_soil = True\n        else:\n            InitCond.wt_in_soil = False\n\n        # Adjust compartment field capacity\n        compi = int(len(profile)) - 1\n        thfcAdj = np.zeros(compi + 1)\n        while compi &gt;= 0:\n            # get soil layer of compartment\n            compdf = profile.loc[compi]\n            if compdf.th_fc &lt;= 0.1:\n                Xmax = 1\n            else:\n                if compdf.th_fc &gt;= 0.3:\n                    Xmax = 2\n                else:\n                    pF = 2 + 0.3 * (compdf.th_fc - 0.1) / 0.2\n                    Xmax = (np.exp(pF * np.log(10))) / 100\n\n            if (InitCond.z_gw &lt; 0) or ((InitCond.z_gw - zMid.iloc[compi]) &gt;= Xmax):\n                for ii in range(compi+1):\n                    compdfii = profile.loc[ii]\n                    thfcAdj[ii] = compdfii.th_fc\n\n                compi = -1\n            else:\n                if compdf.th_fc &gt;= compdf.th_s:\n                    thfcAdj[compi] = compdf.th_fc\n                else:\n                    if zMid.iloc[compi] &gt;= InitCond.z_gw:\n                        thfcAdj[compi] = compdf.th_s\n                    else:\n                        dV = compdf.th_s - compdf.th_fc\n                        dFC = (dV / (Xmax ** 2)) * ((zMid.iloc[compi] - (InitCond.z_gw - Xmax)) ** 2)\n                        thfcAdj[compi] = compdf.th_fc + dFC\n\n                compi = compi - 1\n\n        # Store adjusted field capacity values\n        InitCond.th_fc_Adj = np.round(thfcAdj, 3)\n\n    profile[\"th_fc_Adj\"] = np.round(InitCond.th_fc_Adj, 3)\n\n    # create hydrology df to group by layer instead of compartment\n    ParamStruct.Soil.Hydrology = profile.groupby(\"Layer\").mean().drop([\"dz\", \"dzsum\"], axis=1)\n    ParamStruct.Soil.Hydrology[\"dz\"] = profile.groupby(\"Layer\").sum().dz\n\n    ###################\n    # initial water contents\n    ###################\n\n    typestr = InitWC.wc_type\n    methodstr = InitWC.method\n\n    depth_layer = InitWC.depth_layer\n    datapoints = InitWC.value\n\n    values = np.zeros(len(datapoints))\n\n    hydf = ParamStruct.Soil.Hydrology\n\n    # Assign data\n    if typestr == \"Num\":\n        # Values are defined as numbers (m3/m3) so no calculation required\n        depth_layer = np.array(depth_layer, dtype=float)\n        values = np.array(datapoints, dtype=float)\n\n    elif typestr == \"Pct\":\n        # Values are defined as percentage of taw. Extract and assign value for\n        # each soil layer based on calculated/input soil hydraulic properties\n        depth_layer = np.array(depth_layer, dtype=float)\n        datapoints = np.array(datapoints, dtype=float)\n\n        for ii in range(len(values)):\n            if methodstr == \"Depth\":\n                depth = depth_layer[ii]\n                value = datapoints[ii]\n\n                # Find layer at specified depth\n                if depth &lt; profile.dzsum.iloc[-1]:\n                    layer = profile.query(f\"{depth}&lt;dzsum\").Layer.iloc[0]\n                else:\n                    layer = profile.Layer.iloc[-1]\n\n                compdf = hydf.loc[layer]\n\n                # Calculate moisture content at specified depth\n                values[ii] = compdf.th_wp + ((value / 100) * (compdf.th_fc - compdf.th_wp))\n            elif methodstr == \"Layer\":\n                # Calculate moisture content at specified layer\n                layer = depth_layer[ii]\n                value = datapoints[ii]\n\n                compdf = hydf.loc[layer]\n\n                values[ii] = compdf.th_wp + ((value / 100) * (compdf.th_fc - compdf.th_wp))\n\n    elif typestr == \"Prop\":\n        # Values are specified as soil hydraulic properties (SAT, FC, or WP).\n        # Extract and assign value for each soil layer\n        depth_layer = np.array(depth_layer, dtype=float)\n        datapoints = np.array(datapoints, dtype=str)\n\n        for ii in range(len(values)):\n            if methodstr == \"Depth\":\n                # Find layer at specified depth\n                depth = depth_layer[ii]\n                value = datapoints[ii]\n\n                # Find layer at specified depth\n                if depth &lt; profile.dzsum.iloc[-1]:\n                    layer = profile.query(f\"{depth}&lt;dzsum\").Layer.iloc[0]\n                else:\n                    layer = profile.Layer.iloc[-1]\n\n                compdf = hydf.loc[layer]\n\n                # Calculate moisture content at specified depth\n                if value == \"SAT\":\n                    values[ii] = compdf.th_s\n                if value == \"FC\":\n                    values[ii] = compdf.th_fc\n                if value == \"WP\":\n                    values[ii] = compdf.th_wp\n\n            elif methodstr == \"Layer\":\n                # Calculate moisture content at specified layer\n                layer = depth_layer[ii]\n                value = datapoints[ii]\n\n                compdf = hydf.loc[layer]\n\n                if value == \"SAT\":\n                    values[ii] = compdf.th_s\n                if value == \"FC\":\n                    values[ii] = compdf.th_fc\n                if value == \"WP\":\n                    values[ii] = compdf.th_wp\n\n    # Interpolate values to all soil compartments\n\n    thini = np.zeros(int(profile.shape[0]))\n    if methodstr == \"Layer\":\n        for ii in range(len(values)):\n            layer = depth_layer[ii]\n            value = values[ii]\n\n            idx = profile.query(f\"Layer=={int(layer)}\").index\n\n            thini[idx] = value\n\n        InitCond.th = thini\n\n    elif methodstr == \"Depth\":\n        depths = depth_layer\n\n        # Add zero point\n        if depths[0] &gt; 0:\n            depths = np.append([0], depths)\n            values = np.append([values[0]], values)\n\n        # Add end point (bottom of soil profile)\n        if depths[-1] &lt; ParamStruct.Soil.zSoil:\n            depths = np.append(depths, [ParamStruct.Soil.zSoil])\n            values = np.append(values, [values[-1]])\n\n        # Find centroids of compartments\n        SoilDepths = profile.dzsum.values\n        comp_top = np.append([0], SoilDepths[:-1])\n        comp_bot = SoilDepths\n        comp_mid = (comp_top + comp_bot) / 2\n        # Interpolate initial water contents to each compartment\n        thini = np.interp(comp_mid, depths, values)\n        InitCond.th = thini\n\n    # If groundwater table is present and calculating water contents based on\n    # field capacity, then reset value to account for possible changes in field\n    # capacity caused by capillary rise effects\n    if ParamStruct.water_table == 1:\n        if (typestr == \"Prop\") and (datapoints[-1] == \"FC\"):\n            InitCond.th = InitCond.th_fc_Adj\n\n    # If groundwater table is present in soil profile then set all water\n    # contents below the water table to saturation\n    if InitCond.wt_in_soil is True:\n        # Find compartment mid-points\n        SoilDepths = profile.dzsum.values\n        comp_top = np.append([0], SoilDepths[:-1])\n        comp_bot = SoilDepths\n        comp_mid = (comp_top + comp_bot) / 2\n        idx = np.where(comp_mid &gt;= InitCond.z_gw)[0][0]\n        for ii in range(idx, len(profile)):\n            layeri = profile.loc[ii].Layer\n            InitCond.th[ii] = hydf.th_s.loc[layeri]\n\n    InitCond.thini = InitCond.th\n\n    ParamStruct.Soil.profile = profile\n    ParamStruct.Soil.Hydrology = hydf\n\n    return ParamStruct, InitCond\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_model_parameters","title":"<code>aquacrop.initialize.read_model_parameters</code>","text":""},{"location":"initialize/#aquacrop.initialize.read_model_parameters.read_model_parameters","title":"<code>read_model_parameters(clock_struct, soil, crop, weather_df)</code>","text":"<p>Finalise soil and crop paramaters including planting and harvest dates save to new object param_struct</p> <p>Arguments:</p> <pre><code>clock_struct (ClockStruct):  time params\n\nsoil (Soil):  soil object\n\ncrop (Crop):  crop object\n\nweather_df (DataFrame): list of datetimes\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct): updated time paramaters\n\nparam_struct (ParamStruct):  Contains model crop and soil paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_model_parameters.py</code> <pre><code>def read_model_parameters(\n    clock_struct: \"ClockStruct\",\n    soil: \"Soil\",\n    crop: \"Crop\",\n    weather_df: \"DataFrame\"):\n\n    \"\"\"\n    Finalise soil and crop paramaters including planting and harvest dates\n    save to new object param_struct\n\n\n    Arguments:\n\n        clock_struct (ClockStruct):  time params\n\n        soil (Soil):  soil object\n\n        crop (Crop):  crop object\n\n        weather_df (DataFrame): list of datetimes\n\n    Returns:\n\n        clock_struct (ClockStruct): updated time paramaters\n\n        param_struct (ParamStruct):  Contains model crop and soil paramaters\n\n    \"\"\"\n    # create param_struct object\n    param_struct = ParamStruct()\n\n    soil.fill_nan()\n\n    # Assign soil object to param_struct\n    param_struct.Soil = soil\n\n    while soil.zSoil &lt; crop.Zmax + 0.1:\n        for i in soil.profile.index[::-1]:\n            if soil.profile.loc[i, \"dz\"] &lt; 0.25:\n                soil.profile.loc[i, \"dz\"] += 0.1\n                soil.fill_nan()\n                break\n\n    # TODO: Why all these commented lines? The model does not allow rotations now?\n    ###########\n    # crop\n    ###########\n\n    #     if isinstance(crop, Iterable):\n    #         cropList=list(crop)\n    #     else:\n    #         cropList = [crop]\n\n    #     # assign variables to paramstruct\n    #     paramStruct.nCrops = len(cropList)\n    #     if paramStruct.nCrops &gt; 1:\n    #         paramStruct.SpecifiedPlantcalendar = 'yield_'\n    #     else:\n    #         paramStruct.SpecifiedPlantcalendar = 'N'\n\n    #     # add crop list to paramStruct\n    #     paramStruct.cropList = cropList\n\n    ############################\n    # plant and harvest times\n    ############################\n\n    #     # find planting and harvest dates\n    #     # check if there is more than 1 crop or multiple plant dates in sim year\n    #     if paramStruct.SpecifiedPlantcalendar == \"yield_\":\n    #         # if here than crop rotation occours during same period\n\n    #         # create variables from dataframe\n    #         plantingDates = pd.to_datetime(planting_dates)\n    #         harvestDates = pd.to_datetime(harvest_dates)\n\n    #         if (paramStruct.nCrops &gt; 1):\n\n    #             cropChoices = [crop.name for crop in paramStruct.cropList]\n\n    #         assert len(cropChoices) == len(plantingDates) == len(harvestDates)\n\n    # elif paramStruct.nCrops == 1:\n    # Only one crop type considered during simulation - i.e. no rotations\n    # either within or between years\n    crop_list = [crop]\n    param_struct.CropList = crop_list\n    param_struct.NCrops = 1\n\n    # Get start and end years for full simulation\n    sim_start_date = clock_struct.simulation_start_date\n    sim_end_date = clock_struct.simulation_end_date\n\n    if crop.harvest_date is None:\n        crop = compute_crop_calendar(\n            crop,\n            clock_struct.planting_dates,\n            clock_struct.simulation_start_date,\n            clock_struct.simulation_end_date,\n            clock_struct.time_span,\n            weather_df,\n        )\n        mature = int(crop.MaturityCD + 30)\n        plant = pd.to_datetime(\"1990/\" + crop.planting_date)\n        harv = plant + np.timedelta64(mature, \"D\")\n        new_harvest_date = str(harv.month) + \"/\" + str(harv.day)\n        crop.harvest_date = new_harvest_date\n\n    # extract years from simulation start and end date\n    start_end_years = [sim_start_date.year, sim_end_date.year]\n\n    # check if crop growing season runs over calander year\n    # Planting and harvest dates are in days/months format so just add arbitrary year\n    single_year = pd.to_datetime(\"1990/\" + crop.planting_date) &lt; pd.to_datetime(\n        \"1990/\" + crop.harvest_date\n    )\n\n    if single_year:\n        # if normal year\n\n        # Check if the simulation in the following year does not exceed planting date.\n        mock_simulation_end_date = pd.to_datetime(\"1990/\" + f'{sim_end_date.month}' + \"/\" + f'{sim_end_date.day}')\n        mock_simulation_start_date = pd.to_datetime(\"1990/\" + crop.planting_date)\n        last_simulation_year_does_not_start = mock_simulation_end_date &lt;= mock_simulation_start_date\n\n        if last_simulation_year_does_not_start:\n            start_end_years[1] = start_end_years[1] - 1\n\n        # specify the planting and harvest years as normal\n        plant_years = list(range(start_end_years[0], start_end_years[1] + 1))\n        harvest_years = plant_years\n    else:\n        # if it takes over a year then the plant year finishes 1 year before end of sim\n        # and harvest year starts 1 year after sim start\n\n        if (\n            pd.to_datetime(str(start_end_years[1] + 2) + \"/\" + crop.harvest_date)\n            &lt; sim_end_date\n        ):\n\n            # specify shifted planting and harvest years\n            plant_years = list(range(start_end_years[0], start_end_years[1] + 1))\n            harvest_years = list(range(start_end_years[0] + 1, start_end_years[1] + 2))\n        else:\n\n            plant_years = list(range(start_end_years[0], start_end_years[1]))\n            harvest_years = list(range(start_end_years[0] + 1, start_end_years[1] + 1))\n\n    # Correct for partial first growing season (may occur when simulating\n    # off-season soil water balance)\n    if (\n        pd.to_datetime(str(plant_years[0]) + \"/\" + crop.planting_date)\n        &lt; clock_struct.simulation_start_date\n    ):\n        # shift everything by 1 year\n        plant_years = plant_years[1:]\n        harvest_years = harvest_years[1:]\n\n    # ensure number of planting and harvest years are the same\n    assert len(plant_years) == len(harvest_years)\n\n    # create lists to hold variables\n    planting_dates = []\n    harvest_dates = []\n    crop_choices = []\n\n    # save full harvest/planting dates and crop choices to lists\n    for i, _ in enumerate(plant_years):\n        planting_dates.append(\n            str(plant_years[i]) + \"/\" + param_struct.CropList[0].planting_date\n        )\n        harvest_dates.append(\n            str(harvest_years[i]) + \"/\" + param_struct.CropList[0].harvest_date\n        )\n        crop_choices.append(param_struct.CropList[0].Name)\n\n    # save crop choices\n    param_struct.CropChoices = list(crop_choices)\n\n    # save clock paramaters\n    clock_struct.planting_dates = pd.to_datetime(planting_dates)\n    clock_struct.harvest_dates = pd.to_datetime(harvest_dates)\n    clock_struct.n_seasons = len(planting_dates)\n\n    # Initialise growing season counter\n    if pd.to_datetime(clock_struct.step_start_time) == clock_struct.planting_dates[0]:\n        clock_struct.season_counter = 0\n    else:\n        clock_struct.season_counter = -1\n\n    # return the FileLocations object as i have added some elements\n    return clock_struct, param_struct\n</code></pre>"},{"location":"initialize/#aquacrop.initialize.read_weather_inputs","title":"<code>aquacrop.initialize.read_weather_inputs</code>","text":"<p>Initialize weather data</p>"},{"location":"initialize/#aquacrop.initialize.read_weather_inputs.read_weather_inputs","title":"<code>read_weather_inputs(clock_sctruct, weather_df)</code>","text":"<p>Clip weather to start and end simulation dates</p> <p>Arguments:</p> <pre><code>clock_sctruct (ClockStruct): ClockStruct object\n\nweather_df (DataFrame): weather dataframe\n</code></pre> <p>Returns:</p> <pre><code>weather_df (DataFrame): clipped weather dataframe\n</code></pre> Source code in <code>aquacrop/initialize/read_weather_inputs.py</code> <pre><code>def read_weather_inputs(\n    clock_sctruct: \"ClockStruct\",\n    weather_df: \"DataFrame\") -&gt; \"DataFrame\":\n    \"\"\"\n    Clip weather to start and end simulation dates\n\n    Arguments:\n\n        clock_sctruct (ClockStruct): ClockStruct object\n\n        weather_df (DataFrame): weather dataframe\n\n    Returns:\n\n        weather_df (DataFrame): clipped weather dataframe\n\n    \"\"\"\n\n    # get the start and end dates of simulation\n    start_date = clock_sctruct.simulation_start_date\n    end_date = clock_sctruct.simulation_end_date\n\n    if weather_df.Date.iloc[0] &gt; start_date:\n        raise ValueError(\n            \"The first date of the climate data cannot be longer than the start date of the model.\"\n        )\n\n    if weather_df.Date.iloc[-1] &lt; end_date:\n        raise ValueError(\n            \"The model end date cannot be longer than the last date of climate data.\"\n        )\n\n    # remove weather data outside of simulation dates\n    weather_df = weather_df[weather_df.Date &gt;= start_date]\n    weather_df = weather_df[weather_df.Date &lt;= end_date]\n\n    return weather_df\n</code></pre>"},{"location":"solution/","title":"solution","text":""},{"location":"solution/#aquacrop.solution","title":"<code>aquacrop.solution</code>","text":""},{"location":"solution/#aquacrop.solution.adjust_CCx","title":"<code>aquacrop.solution.adjust_CCx</code>","text":""},{"location":"solution/#aquacrop.solution.adjust_CCx.adjust_CCx","title":"<code>adjust_CCx(cc_prev, CCo, CCx, CGC, CDC, dt, tSum, Crop_CanopyDevEnd, Crop_CCx)</code>","text":"<p>Function to adjust CCx value for changes in CGC due to water stress during the growing season</p> <p>Reference Manual: canopy_cover stress response (pg. 27-33)</p> <p>Arguments:</p> <pre><code>cc_prev (float): Canopy Cover at previous timestep.\n\nCCo (float): Fractional canopy cover size at emergence\n\nCCx (float): Maximum canopy cover (fraction of soil cover)\n\nCGC (float): Canopy growth coefficient (fraction per gdd)\n\nCDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\ndt (float): Time delta of canopy growth (1 calander day or ... gdd)\n\ntSum (float): time since germination (CD or gdd)\n\nCrop_CanopyDevEnd (float): time that Canopy developement ends\n\nCrop_CCx (float): Maximum canopy cover (fraction of soil cover)\n</code></pre> <p>Returns:</p> <pre><code>CCxAdj (float): Adjusted CCx\n</code></pre> Source code in <code>aquacrop/solution/adjust_CCx.py</code> <pre><code>def adjust_CCx(\n    cc_prev: float,\n    CCo: float,\n    CCx: float,\n    CGC: float,\n    CDC: float,\n    dt: float,\n    tSum: float,\n    Crop_CanopyDevEnd: float,\n    Crop_CCx: float\n    ) -&gt; float:\n    \"\"\"\n    Function to adjust CCx value for changes in CGC due to water stress during the growing season\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=36\" target=\"_blank\"&gt;Reference Manual: canopy_cover stress response&lt;/a&gt; (pg. 27-33)\n\n\n    Arguments:\n\n        cc_prev (float): Canopy Cover at previous timestep.\n\n        CCo (float): Fractional canopy cover size at emergence\n\n        CCx (float): Maximum canopy cover (fraction of soil cover)\n\n        CGC (float): Canopy growth coefficient (fraction per gdd)\n\n        CDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\n        dt (float): Time delta of canopy growth (1 calander day or ... gdd)\n\n        tSum (float): time since germination (CD or gdd)\n\n        Crop_CanopyDevEnd (float): time that Canopy developement ends\n\n        Crop_CCx (float): Maximum canopy cover (fraction of soil cover)\n\n    Returns:\n\n        CCxAdj (float): Adjusted CCx\n\n\n\n    \"\"\"\n\n    ## Get time required to reach canopy_cover on previous day ##\n    tCCtmp = cc_required_time(cc_prev, CCo, CCx, CGC, CDC, \"CGC\")\n\n    ## Determine CCx adjusted ##\n    if tCCtmp &gt; 0:\n        tCCtmp = tCCtmp + (Crop_CanopyDevEnd - tSum) + dt\n        CCxAdj = cc_development(CCo, CCx, CGC, CDC, tCCtmp, \"Growth\", Crop_CCx)\n    else:\n        CCxAdj = 0\n\n    return CCxAdj\n</code></pre>"},{"location":"solution/#aquacrop.solution.aeration_stress","title":"<code>aquacrop.solution.aeration_stress</code>","text":""},{"location":"solution/#aquacrop.solution.aeration_stress.aeration_stress","title":"<code>aeration_stress(NewCond_AerDays, Crop_LagAer, thRZ)</code>","text":"<p>Function to calculate aeration stress coefficient</p> <p>Reference Manual: aeration stress (pg. 89-90)</p> <p>Arguments:</p> <pre><code>NewCond_AerDays (int): number aeration stress days\n\nCrop_LagAer (int): lag days before aeration stress\n\nthRZ (NamedTuple): object that contains information on the total water in the root zone\n</code></pre> <p>Returns:</p> <pre><code>Ksa_Aer (float): aeration stress coefficient\n\nNewCond_AerDays (float): updated aer days\n</code></pre> Source code in <code>aquacrop/solution/aeration_stress.py</code> <pre><code>def aeration_stress(\n    NewCond_AerDays: float,\n    Crop_LagAer: float,\n    thRZ: NamedTuple,\n    ) -&gt; Tuple[float, float]:\n    \"\"\"\n    Function to calculate aeration stress coefficient\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=90\" target=\"_blank\"&gt;Reference Manual: aeration stress&lt;/a&gt; (pg. 89-90)\n\n\n    Arguments:\n\n        NewCond_AerDays (int): number aeration stress days\n\n        Crop_LagAer (int): lag days before aeration stress\n\n        thRZ (NamedTuple): object that contains information on the total water in the root zone\n\n\n    Returns:\n\n        Ksa_Aer (float): aeration stress coefficient\n\n        NewCond_AerDays (float): updated aer days\n\n\n\n    \"\"\"\n\n    ## Determine aeration stress (root zone) ##\n    if thRZ.Act &gt; thRZ.Aer:\n        # Calculate aeration stress coefficient\n        if NewCond_AerDays &lt; Crop_LagAer:\n            stress = 1 - ((thRZ.S - thRZ.Act) / (thRZ.S - thRZ.Aer))\n            Ksa_Aer = 1 - ((NewCond_AerDays / 3) * stress)\n        elif NewCond_AerDays &gt;= Crop_LagAer:\n            Ksa_Aer = (thRZ.S - thRZ.Act) / (thRZ.S - thRZ.Aer)\n\n        # Increment aeration days counter\n        NewCond_AerDays = NewCond_AerDays + 1\n        if NewCond_AerDays &gt; Crop_LagAer:\n            NewCond_AerDays = Crop_LagAer\n\n    else:\n        # Set aeration stress coefficient to one (no stress value)\n        Ksa_Aer = 1\n        # Reset aeration days counter\n        NewCond_AerDays = 0\n\n    return Ksa_Aer, NewCond_AerDays\n</code></pre>"},{"location":"solution/#aquacrop.solution.biomass_accumulation","title":"<code>aquacrop.solution.biomass_accumulation</code>","text":""},{"location":"solution/#aquacrop.solution.biomass_accumulation.biomass_accumulation","title":"<code>biomass_accumulation(Crop, NewCond_DAP, NewCond_DelayedCDs, NewCond_HIref, NewCond_PctLagPhase, NewCond_B, NewCond_B_NS, Tr, TrPot, et0, growing_season)</code>","text":"<p>Function to calculate biomass accumulation</p> <p>Reference Manual: biomass accumulaiton (pg. 98-108)</p> <p>Arguments:</p> <pre><code>Crop (NamedTuple): Crop object\n\nNewCond_DAP (int): days since planting\n\nNewCond_DelayedCDs (int): Delayed calendar days\n\nNewCond_HIref (float): reference harvest index\n\nNewCond_PctLagPhase (float): percentage of way through early HI development stage\n\nNewCond_B (float): Current biomass growth\n\nNewCond_B_NS (float): current no stress biomass growth\n\nTrPot (float): Daily crop transpiration\n\nTrPot (float): Daily potential transpiration\n\net0 (float): Daily reference evapotranspiration\n\ngrowing_season (bool): is Growing season? (True, False)\n</code></pre> <p>Returns:</p> <pre><code>NewCond_B (float): new biomass growth\n\nNewCond_B_NS (float): new (No stress) biomass growth\n</code></pre> Source code in <code>aquacrop/solution/biomass_accumulation.py</code> <pre><code>def biomass_accumulation(\n    Crop: NamedTuple,\n    NewCond_DAP: int,\n    NewCond_DelayedCDs: int,\n    NewCond_HIref: float,\n    NewCond_PctLagPhase: float,\n    NewCond_B: float,\n    NewCond_B_NS: float,\n    Tr: float,\n    TrPot: float,\n    et0: float,\n    growing_season: bool,\n    ) -&gt; Tuple[float, float]:\n    \"\"\"\n    Function to calculate biomass accumulation\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=107\" target=\"_blank\"&gt;Reference Manual: biomass accumulaiton&lt;/a&gt; (pg. 98-108)\n\n\n    Arguments:\n\n        Crop (NamedTuple): Crop object\n\n        NewCond_DAP (int): days since planting\n\n        NewCond_DelayedCDs (int): Delayed calendar days\n\n        NewCond_HIref (float): reference harvest index\n\n        NewCond_PctLagPhase (float): percentage of way through early HI development stage\n\n        NewCond_B (float): Current biomass growth\n\n        NewCond_B_NS (float): current no stress biomass growth\n\n        TrPot (float): Daily crop transpiration\n\n        TrPot (float): Daily potential transpiration\n\n        et0 (float): Daily reference evapotranspiration\n\n        growing_season (bool): is Growing season? (True, False)\n\n    Returns:\n\n        NewCond_B (float): new biomass growth\n\n        NewCond_B_NS (float): new (No stress) biomass growth\n\n\n    \"\"\"\n\n    ## Store initial conditions in a new structure for updating ##\n    # NewCond = InitCond\n\n    ## Calculate biomass accumulation (if in growing season) ##\n    if growing_season == True:\n        # Get time for harvest index build-up\n        HIt = NewCond_DAP - NewCond_DelayedCDs - Crop.HIstartCD - 1\n\n        if ((Crop.CropType == 2) or (Crop.CropType == 3)) and (NewCond_HIref &gt; 0):\n            # Adjust WP for reproductive stage\n            if Crop.Determinant == 1:\n                fswitch = NewCond_PctLagPhase / 100\n            else:\n                if HIt &lt; (Crop.YldFormCD / 3):\n                    fswitch = HIt / (Crop.YldFormCD / 3)\n                else:\n                    fswitch = 1\n\n            WPadj = Crop.WP * (1 - (1 - Crop.WPy / 100) * fswitch)\n        else:\n            WPadj = Crop.WP\n\n        # Adjust WP for CO2 effects\n        WPadj = WPadj * Crop.fCO2\n\n        # Calculate biomass accumulation on current day\n        # No water stress\n        dB_NS = WPadj * (TrPot / et0)\n        # With water stress\n        dB = WPadj * (Tr / et0)\n        if np.isnan(dB) == True:\n            dB = 0\n\n        # Update biomass accumulation\n        NewCond_B = NewCond_B + dB\n        NewCond_B_NS = NewCond_B_NS + dB_NS\n    else:\n        # No biomass accumulation outside of growing season\n        NewCond_B = 0\n        NewCond_B_NS = 0\n\n    return (NewCond_B,\n            NewCond_B_NS)\n</code></pre>"},{"location":"solution/#aquacrop.solution.canopy_cover","title":"<code>aquacrop.solution.canopy_cover</code>","text":""},{"location":"solution/#aquacrop.solution.canopy_cover.canopy_cover","title":"<code>canopy_cover(Crop, prof, Soil_zTop, InitCond, gdd, et0, growing_season)</code>","text":"<p>Function to simulate canopy growth/decline</p> <p>Reference Manual: canopy_cover equations (pg. 21-33)</p> <p>Arguments:</p> <pre><code>Crop (CropStruct): Crop object\n\nprof (SoilProfile): SoilProfile object\n\nSoil_zTop (float): top soil depth\n\nInitCond (InitialCondition): InitCond object\n\ngdd (float): Growing Degree Days\n\net0 (float): reference evapotranspiration\n\ngrowing_season (bool): is it currently within the growing season (True, Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): updated InitCond object\n</code></pre> Source code in <code>aquacrop/solution/canopy_cover.py</code> <pre><code>def canopy_cover(\n    Crop: \"CropStruct\",\n    prof: \"SoilProfile\",\n    Soil_zTop: float,\n    InitCond: \"InitialCondition\",\n    gdd: float,\n    et0: float,\n    growing_season: bool,\n    ):\n    # def CCCrop,Soil_Profile,Soil_zTop,InitCond,gdd,et0,growing_season):\n\n    \"\"\"\n    Function to simulate canopy growth/decline\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=30\" target=\"_blank\"&gt;Reference Manual: canopy_cover equations&lt;/a&gt; (pg. 21-33)\n\n\n    Arguments:\n\n        Crop (CropStruct): Crop object\n\n        prof (SoilProfile): SoilProfile object\n\n        Soil_zTop (float): top soil depth\n\n        InitCond (InitialCondition): InitCond object\n\n        gdd (float): Growing Degree Days\n\n        et0 (float): reference evapotranspiration\n\n        growing_season (bool): is it currently within the growing season (True, Flase)\n\n    Returns:\n\n        NewCond (InitialCondition): updated InitCond object\n\n\n    \"\"\"\n\n    # Function to simulate canopy growth/decline\n\n    InitCond_CC_NS = InitCond.canopy_cover_ns\n    InitCond_CC = InitCond.canopy_cover\n    InitCond_ProtectedSeed = InitCond.protected_seed\n    InitCond_CCxAct = InitCond.ccx_act\n    InitCond_CropDead = InitCond.crop_dead\n    InitCond_tEarlySen = InitCond.t_early_sen\n    InitCond_CCxW = InitCond.ccx_w\n\n    ## Store initial conditions in a new structure for updating ##\n    NewCond = InitCond\n    NewCond.cc_prev = InitCond.canopy_cover\n\n    ## Calculate canopy development (if in growing season) ##\n    if growing_season == True:\n        # Calculate root zone water content\n        taw = TAW()\n        root_zone_depletion = Dr()\n        # thRZ = RootZoneWater()\n        _, root_zone_depletion.Zt, root_zone_depletion.Rz, taw.Zt, taw.Rz, _,_,_,_,_,_ = root_zone_water(\n            prof,\n            float(NewCond.z_root),\n            NewCond.th,\n            Soil_zTop,\n            float(Crop.Zmin),\n            Crop.Aer,\n        )\n\n        # _,root_zone_depletion,taw,_ = root_zone_water(Soil_Profile,float(NewCond.z_root),NewCond.th,Soil_zTop,float(Crop.Zmin),Crop.Aer)\n        # Check whether to use root zone or top soil depletions for calculating\n        # water stress\n        if (root_zone_depletion.Rz / taw.Rz) &lt;= (root_zone_depletion.Zt / taw.Zt):\n            # Root zone is wetter than top soil, so use root zone value\n            root_zone_depletion = root_zone_depletion.Rz\n            taw = taw.Rz\n        else:\n            # Top soil is wetter than root zone, so use top soil values\n            root_zone_depletion = root_zone_depletion.Zt\n            taw = taw.Zt\n\n        # Determine if water stress is occurring\n        beta = True\n        water_stress_coef = Ksw()\n        water_stress_coef.exp, water_stress_coef.sto, water_stress_coef.sen, water_stress_coef.pol, water_stress_coef.sto_lin = water_stress(\n            Crop.p_up,\n            Crop.p_lo,\n            Crop.ETadj,\n            Crop.beta,\n            Crop.fshape_w,\n            NewCond.t_early_sen,\n            root_zone_depletion,\n            taw,\n            et0,\n            beta,\n        )\n\n        # water_stress(Crop, NewCond, root_zone_depletion, taw, et0, beta)\n\n        # Get canopy cover growth time\n        if Crop.CalendarType == 1:\n            dtCC = 1\n            tCCadj = NewCond.dap - NewCond.delayed_cds\n        elif Crop.CalendarType == 2:\n            dtCC = gdd\n            tCCadj = NewCond.gdd_cum - NewCond.delayed_gdds\n\n        ## Canopy development (potential) ##\n        if (tCCadj &lt; Crop.Emergence) or (round(tCCadj) &gt; Crop.Maturity):\n            # No canopy development before emergence/germination or after\n            # maturity\n            NewCond.canopy_cover_ns = 0\n\n        elif tCCadj &lt; Crop.CanopyDevEnd:\n            # Canopy growth can occur\n            if InitCond_CC_NS &lt;= Crop.CC0:\n                # Very small initial canopy_cover.\n                NewCond.canopy_cover_ns = Crop.CC0 * np.exp(Crop.CGC * dtCC)\n                # print(Crop.CC0,np.exp(Crop.CGC*dtCC))\n            else:\n                # Canopy growing\n                tmp_tCC = tCCadj - Crop.Emergence\n                NewCond.canopy_cover_ns = cc_development(\n                    Crop.CC0, 0.98 * Crop.CCx, Crop.CGC, Crop.CDC, tmp_tCC, \"Growth\", Crop.CCx\n                )\n\n            # Update maximum canopy cover size in growing season\n            NewCond.ccx_act_ns = NewCond.canopy_cover_ns\n        elif tCCadj &gt; Crop.CanopyDevEnd:\n            # No more canopy growth is possible or canopy in decline\n            # Set CCx for calculation of withered canopy effects\n            NewCond.ccx_w_ns = NewCond.ccx_act_ns\n            if tCCadj &lt; Crop.Senescence:\n                # Mid-season stage - no canopy growth\n                NewCond.canopy_cover_ns = InitCond_CC_NS\n                # Update maximum canopy cover size in growing season\n                NewCond.ccx_act_ns = NewCond.canopy_cover_ns\n            else:\n                # Late-season stage - canopy decline\n                tmp_tCC = tCCadj - Crop.Senescence\n                NewCond.canopy_cover_ns = cc_development(\n                    Crop.CC0,\n                    NewCond.ccx_act_ns,\n                    Crop.CGC,\n                    Crop.CDC,\n                    tmp_tCC,\n                    \"Decline\",\n                    NewCond.ccx_act_ns,\n                )\n\n        ## Canopy development (actual) ##\n        if (tCCadj &lt; Crop.Emergence) or (round(tCCadj) &gt; Crop.Maturity):\n            # No canopy development before emergence/germination or after\n            # maturity\n            NewCond.canopy_cover = 0\n            NewCond.cc0_adj = Crop.CC0\n        elif tCCadj &lt; Crop.CanopyDevEnd:\n            # Canopy growth can occur\n            if InitCond_CC &lt;= NewCond.cc0_adj or (\n                (InitCond_ProtectedSeed == True) and (InitCond_CC &lt;= (1.25 * NewCond.cc0_adj))\n            ):\n                # Very small initial canopy_cover or seedling in protected phase of\n                # growth. In this case, assume no leaf water expansion stress\n                if InitCond_ProtectedSeed == True:\n                    tmp_tCC = tCCadj - Crop.Emergence\n                    NewCond.canopy_cover = cc_development(\n                        Crop.CC0, Crop.CCx, Crop.CGC, Crop.CDC, tmp_tCC, \"Growth\", Crop.CCx\n                    )\n                    # Check if seed protection should be turned off\n                    if NewCond.canopy_cover &gt; (1.25 * NewCond.cc0_adj):\n                        # Turn off seed protection - lead expansion stress can\n                        # occur on future time steps.\n                        NewCond.protected_seed = False\n\n                else:\n                    NewCond.canopy_cover = NewCond.cc0_adj * np.exp(Crop.CGC * dtCC)\n\n            else:\n                # Canopy growing\n                if InitCond_CC &lt; (0.9799 * Crop.CCx):\n                    # Adjust canopy growth coefficient for leaf expansion water\n                    # stress effects\n                    CGCadj = Crop.CGC * water_stress_coef.exp\n                    if CGCadj &gt; 0:\n\n                        # Adjust CCx for change in CGC\n                        CCXadj = adjust_CCx(\n                            InitCond_CC,\n                            NewCond.cc0_adj,\n                            Crop.CCx,\n                            CGCadj,\n                            Crop.CDC,\n                            dtCC,\n                            tCCadj,\n                            Crop.CanopyDevEnd,\n                            Crop.CCx,\n                        )\n                        if CCXadj &lt; 0:\n\n                            NewCond.canopy_cover = InitCond_CC\n                        elif abs(InitCond_CC - (0.9799 * Crop.CCx)) &lt; 0.001:\n\n                            # Approaching maximum canopy cover size\n                            tmp_tCC = tCCadj - Crop.Emergence\n                            NewCond.canopy_cover = cc_development(\n                                Crop.CC0, Crop.CCx, Crop.CGC, Crop.CDC, tmp_tCC, \"Growth\", Crop.CCx\n                            )\n                        else:\n\n                            # Determine time required to reach canopy_cover on previous,\n                            # day, given CGCAdj value\n                            tReq = cc_required_time(\n                                InitCond_CC, NewCond.cc0_adj, CCXadj, CGCadj, Crop.CDC, \"CGC\"\n                            )\n                            if tReq &gt; 0:\n\n                                # Calclate gdd's for canopy growth\n                                tmp_tCC = tReq + dtCC\n                                # Determine new canopy size\n                                NewCond.canopy_cover = cc_development(\n                                    NewCond.cc0_adj,\n                                    CCXadj,\n                                    CGCadj,\n                                    Crop.CDC,\n                                    tmp_tCC,\n                                    \"Growth\",\n                                    Crop.CCx,\n                                )\n                                # print(NewCond.dap,CCXadj,tReq)\n\n                            else:\n                                # No canopy growth\n                                NewCond.canopy_cover = InitCond_CC\n\n                    else:\n                        # No canopy growth\n                        NewCond.canopy_cover = InitCond_CC\n                        # Update CC0\n                        if NewCond.canopy_cover &gt; NewCond.cc0_adj:\n                            NewCond.cc0_adj = Crop.CC0\n                        else:\n                            NewCond.cc0_adj = NewCond.canopy_cover\n\n                else:\n                    # Canopy approaching maximum size\n                    tmp_tCC = tCCadj - Crop.Emergence\n                    NewCond.canopy_cover = cc_development(\n                        Crop.CC0, Crop.CCx, Crop.CGC, Crop.CDC, tmp_tCC, \"Growth\", Crop.CCx\n                    )\n                    NewCond.cc0_adj = Crop.CC0\n\n            if NewCond.canopy_cover &gt; InitCond_CCxAct:\n                # Update actual maximum canopy cover size during growing season\n                NewCond.ccx_act = NewCond.canopy_cover\n\n        elif tCCadj &gt; Crop.CanopyDevEnd:\n            # No more canopy growth is possible or canopy is in decline\n            if tCCadj &lt; Crop.Senescence:\n                # Mid-season stage - no canopy growth\n                NewCond.canopy_cover = InitCond_CC\n                if NewCond.canopy_cover &gt; InitCond_CCxAct:\n                    # Update actual maximum canopy cover size during growing\n                    # season\n                    NewCond.ccx_act = NewCond.canopy_cover\n\n            else:\n                # Late-season stage - canopy decline\n                # Adjust canopy decline coefficient for difference between actual\n                # and potential CCx\n                CDCadj = Crop.CDC * ((NewCond.ccx_act + 2.29) / (Crop.CCx + 2.29))\n                # Determine new canopy size\n                tmp_tCC = tCCadj - Crop.Senescence\n                NewCond.canopy_cover = cc_development(\n                    NewCond.cc0_adj,\n                    NewCond.ccx_act,\n                    Crop.CGC,\n                    CDCadj,\n                    tmp_tCC,\n                    \"Decline\",\n                    NewCond.ccx_act,\n                )\n\n            # Check for crop growth termination\n            if (NewCond.canopy_cover &lt; 0.001) and (InitCond_CropDead == False):\n                # Crop has died\n                NewCond.canopy_cover = 0\n                NewCond.crop_dead = True\n\n        ## Canopy senescence due to water stress (actual) ##\n        if tCCadj &gt;= Crop.Emergence:\n            if (tCCadj &lt; Crop.Senescence) or (InitCond_tEarlySen &gt; 0):\n                # Check for early canopy senescence  due to severe water\n                # stress.\n                if (water_stress_coef.sen &lt; 1) and (InitCond_ProtectedSeed == False):\n\n                    # Early canopy senescence\n                    NewCond.premat_senes = True\n                    if InitCond_tEarlySen == 0:\n                        # No prior early senescence\n                        NewCond.ccx_early_sen = InitCond_CC\n\n                    # Increment early senescence gdd counter\n                    NewCond.t_early_sen = InitCond_tEarlySen + dtCC\n                    # Adjust canopy decline coefficient for water stress\n                    beta = False\n\n                    water_stress_coef = Ksw()\n                    water_stress_coef.exp, water_stress_coef.sto, water_stress_coef.sen, water_stress_coef.pol, water_stress_coef.sto_lin = water_stress(\n                        Crop.p_up,\n                        Crop.p_lo,\n                        Crop.ETadj,\n                        Crop.beta,\n                        Crop.fshape_w,\n                        NewCond.t_early_sen,\n                        root_zone_depletion,\n                        taw,\n                        et0,\n                        beta,\n                    )\n\n                    # water_stress_coef = water_stress(Crop, NewCond, root_zone_depletion, taw, et0, beta)\n                    if water_stress_coef.sen &gt; 0.99999:\n                        CDCadj = 0.0001\n                    else:\n                        CDCadj = (1 - (water_stress_coef.sen ** 8)) * Crop.CDC\n\n                    # Get new canpy cover size after senescence\n                    if NewCond.ccx_early_sen &lt; 0.001:\n                        CCsen = 0\n                    else:\n                        # Get time required to reach canopy_cover at end of previous day, given\n                        # CDCadj\n                        tReq = (np.log(1 + (1 - InitCond_CC / NewCond.ccx_early_sen) / 0.05)) / (\n                            (CDCadj * 3.33) / (NewCond.ccx_early_sen + 2.29)\n                        )\n                        # Calculate gdd's for canopy decline\n                        tmp_tCC = tReq + dtCC\n                        # Determine new canopy size\n                        CCsen = NewCond.ccx_early_sen * (\n                            1\n                            - 0.05\n                            * (\n                                np.exp(tmp_tCC * ((CDCadj * 3.33) / (NewCond.ccx_early_sen + 2.29)))\n                                - 1\n                            )\n                        )\n                        if CCsen &lt; 0:\n                            CCsen = 0\n\n                    # Update canopy cover size\n                    if tCCadj &lt; Crop.Senescence:\n                        # Limit canopy_cover to CCx\n                        if CCsen &gt; Crop.CCx:\n                            CCsen = Crop.CCx\n\n                        # canopy_cover cannot be greater than value on previous day\n                        NewCond.canopy_cover = CCsen\n                        if NewCond.canopy_cover &gt; InitCond_CC:\n                            NewCond.canopy_cover = InitCond_CC\n\n                        # Update maximum canopy cover size during growing\n                        # season\n                        NewCond.ccx_act = NewCond.canopy_cover\n                        # Update CC0 if current canopy_cover is less than initial canopy\n                        # cover size at planting\n                        if NewCond.canopy_cover &lt; Crop.CC0:\n                            NewCond.cc0_adj = NewCond.canopy_cover\n                        else:\n                            NewCond.cc0_adj = Crop.CC0\n\n                    else:\n                        # Update canopy_cover to account for canopy cover senescence due\n                        # to water stress\n                        if CCsen &lt; NewCond.canopy_cover:\n                            NewCond.canopy_cover = CCsen\n\n                    # Check for crop growth termination\n                    if (NewCond.canopy_cover &lt; 0.001) and (InitCond_CropDead == False):\n                        # Crop has died\n                        NewCond.canopy_cover = 0\n                        NewCond.crop_dead = True\n\n                else:\n                    # No water stress\n                    NewCond.premat_senes = False\n                    if (tCCadj &gt; Crop.Senescence) and (InitCond_tEarlySen &gt; 0):\n                        # Rewatering of canopy in late season\n                        # Get new values for CCx and CDC\n                        tmp_tCC = tCCadj - dtCC - Crop.Senescence\n                        CCXadj, CDCadj = update_CCx_CDC(InitCond_CC, Crop.CDC, Crop.CCx, tmp_tCC)\n                        NewCond.ccx_act = CCXadj\n                        # Get new canopy_cover value for end of current day\n                        tmp_tCC = tCCadj - Crop.Senescence\n                        NewCond.canopy_cover = cc_development(\n                            NewCond.cc0_adj, CCXadj, Crop.CGC, CDCadj, tmp_tCC, \"Decline\", CCXadj\n                        )\n                        # Check for crop growth termination\n                        if (NewCond.canopy_cover &lt; 0.001) and (InitCond_CropDead == False):\n                            NewCond.canopy_cover = 0\n                            NewCond.crop_dead = True\n\n                    # Reset early senescence counter\n                    NewCond.t_early_sen = 0\n\n                # Adjust CCx for effects of withered canopy\n                if NewCond.canopy_cover &gt; InitCond_CCxW:\n                    NewCond.ccx_w = NewCond.canopy_cover\n\n        ## Calculate canopy size adjusted for micro-advective effects ##\n        # Check to ensure potential canopy_cover is not slightly lower than actual\n        if NewCond.canopy_cover_ns &lt; NewCond.canopy_cover:\n            NewCond.canopy_cover_ns = NewCond.canopy_cover\n            if tCCadj &lt; Crop.CanopyDevEnd:\n                NewCond.ccx_act_ns = NewCond.canopy_cover_ns\n\n        # Actual (with water stress)\n        NewCond.canopy_cover_adj = (1.72 * NewCond.canopy_cover) - (NewCond.canopy_cover ** 2) + (0.3 * (NewCond.canopy_cover ** 3))\n        # Potential (without water stress)\n        NewCond.canopy_cover_adj_ns = (\n            (1.72 * NewCond.canopy_cover_ns) - (NewCond.canopy_cover_ns ** 2) + (0.3 * (NewCond.canopy_cover_ns ** 3))\n        )\n\n    else:\n        # No canopy outside growing season - set various values to zero\n        NewCond.canopy_cover = 0\n        NewCond.canopy_cover_adj = 0\n        NewCond.canopy_cover_ns = 0\n        NewCond.canopy_cover_adj_ns = 0\n        NewCond.ccx_w = 0\n        NewCond.ccx_act = 0\n        NewCond.ccx_w_ns = 0\n        NewCond.ccx_act_ns = 0\n\n    return NewCond\n</code></pre>"},{"location":"solution/#aquacrop.solution.capillary_rise","title":"<code>aquacrop.solution.capillary_rise</code>","text":""},{"location":"solution/#aquacrop.solution.capillary_rise.capillary_rise","title":"<code>capillary_rise(prof, Soil_nLayer, Soil_fshape_cr, NewCond, FluxOut, water_table_presence)</code>","text":"<p>Function to calculate capillary rise from a shallow groundwater table</p> <p>Reference Manual: capillary rise calculations (pg. 52-61)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): Soil profile named tuple\n\nSoil_nLayer (int): number of soil layers\n\nSoil_fshape_cr (float): Capillary rise shape factor\n\nNewCond (InitialCondition): InitialCondition object containing model paramaters\n\nFluxOut (numpy.array): Flux of water out of each soil compartment\n\nwater_table_presence (int): water_table present (1:yes, 0:no)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n\nCrTot (float): Total Capillary rise\n</code></pre> Source code in <code>aquacrop/solution/capillary_rise.py</code> <pre><code>def capillary_rise(\n    prof: \"SoilProfile\",\n    Soil_nLayer: int,\n    Soil_fshape_cr: float,\n    NewCond: \"InitialCondition\",\n    FluxOut: \"ndarray\",\n    water_table_presence: int,\n    ) -&gt; Tuple[\"InitialCondition\", float]:\n    \"\"\"\n    Function to calculate capillary rise from a shallow groundwater table\n\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=61\" target=\"_blank\"&gt;Reference Manual: capillary rise calculations&lt;/a&gt; (pg. 52-61)\n\n\n    Arguments:\n\n\n        prof (SoilProfile): Soil profile named tuple\n\n        Soil_nLayer (int): number of soil layers\n\n        Soil_fshape_cr (float): Capillary rise shape factor\n\n        NewCond (InitialCondition): InitialCondition object containing model paramaters\n\n        FluxOut (numpy.array): Flux of water out of each soil compartment\n\n        water_table_presence (int): water_table present (1:yes, 0:no)\n\n\n    Returns:\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n        CrTot (float): Total Capillary rise\n\n\n\n\n\n    \"\"\"\n\n    ## Get groundwater table elevation on current day ##\n    z_gw = NewCond.z_gw\n\n    ## Calculate capillary rise ##\n    if water_table_presence == 0:  # No water table present\n        # Capillary rise is zero\n        CrTot = 0\n    elif water_table_presence == 1:  # Water table present\n        # Get maximum capillary rise for bottom compartment\n        zBot = prof.dzsum[-1]\n        zBotMid = prof.zMid[-1]\n        prof = prof\n        if (prof.Ksat[-1] &gt; 0) and (z_gw &gt; 0) and ((z_gw - zBotMid) &lt; 4):\n            if zBotMid &gt;= z_gw:\n                MaxCR = 99\n            else:\n                MaxCR = np.exp((np.log(z_gw - zBotMid) - prof.bCR[-1]) / prof.aCR[-1])\n                if MaxCR &gt; 99:\n                    MaxCR = 99\n\n        else:\n            MaxCR = 0\n\n        ######################### this needs fixing, will currently break####################\n\n        # # Find top of next soil layer that is not within modelled soil profile\n        zTopLayer = 0\n        for layeri in np.sort(np.unique(prof.Layer)):\n            # Calculate layer thickness\n            l_idx = np.argwhere(prof.Layer==layeri).flatten()\n\n            LayThk = prof.dz[l_idx].sum()\n            zTopLayer = zTopLayer+LayThk\n\n        # Check for restrictions on upward flow caused by properties of\n        # compartments that are not modelled in the soil water balance\n        layeri = prof.Layer[-1]\n\n        assert layeri == Soil_nLayer\n\n        while (zTopLayer &lt; z_gw) and (layeri &lt; Soil_nLayer):\n            # this needs fixing, will currently break\n\n\n            compdf = prof.Layer[layeri]\n            if (compdf.Ksat &gt; 0) and (z_gw &gt; 0) and ((z_gw-zTopLayer) &lt; 4):\n                if zTopLayer &gt;= z_gw:\n                    LimCR = 99\n                else:\n                    LimCR = np.exp((np.log(z_gw-zTopLayer)-compdf.bCR)/compdf.aCR)\n                    if LimCR &gt; 99:\n                        LimCR = 99\n\n            else:\n                LimCR = 0\n\n            if MaxCR &gt; LimCR:\n                MaxCR = LimCR\n\n            zTopLayer = zTopLayer+compdf.dz\n\n            layeri = layeri+1 # could be that the increment should be at the end of the loop rather than at the start (bad indexing otherwise)\n\n        #####################################################################################\n\n        # Calculate capillary rise\n        compi = len(prof.Comp) - 1  # Start at bottom of root zone\n        WCr = 0  # Capillary rise counter\n        while (round(MaxCR * 1000) &gt; 0) and (compi &gt; -1) and (round(FluxOut[compi] * 1000) == 0):\n            # Proceed upwards until maximum capillary rise occurs, soil surface\n            # is reached, or encounter a compartment where downward\n            # drainage/infiltration has already occurred on current day\n            # Find layer of current compartment\n            # Calculate driving force\n            if (NewCond.th[compi] &gt;= prof.th_wp[compi]) and (Soil_fshape_cr &gt; 0):\n                Df = 1 - (\n                    (\n                        (NewCond.th[compi] - prof.th_wp[compi])\n                        / (NewCond.th_fc_Adj[compi] - prof.th_wp[compi])\n                    )\n                    ** Soil_fshape_cr\n                )\n                if Df &gt; 1:\n                    Df = 1\n                elif Df &lt; 0:\n                    Df = 0\n\n            else:\n                Df = 1\n\n            # Calculate relative hydraulic conductivity\n            thThr = (prof.th_wp[compi] + prof.th_fc[compi]) / 2\n            if NewCond.th[compi] &lt; thThr:\n                if (NewCond.th[compi] &lt;= prof.th_wp[compi]) or (thThr &lt;= prof.th_wp[compi]):\n                    Krel = 0\n                else:\n                    Krel = (NewCond.th[compi] - prof.th_wp[compi]) / (thThr - prof.th_wp[compi])\n\n            else:\n                Krel = 1\n\n            # Check if room is available to store water from capillary rise\n            dth = round(NewCond.th_fc_Adj[compi] - NewCond.th[compi],4)\n\n            # Store water if room is available\n            if (dth &gt; 0) and ((zBot - prof.dz[compi] / 2) &lt; z_gw):\n                dthMax = Krel * Df * MaxCR / (1000 * prof.dz[compi])\n                if dth &gt;= dthMax:\n                    NewCond.th[compi] = NewCond.th[compi] + dthMax\n                    CRcomp = dthMax * 1000 * prof.dz[compi]\n                    MaxCR = 0\n                else:\n                    NewCond.th[compi] = NewCond.th_fc_Adj[compi]\n                    CRcomp = dth * 1000 * prof.dz[compi]\n                    MaxCR = (Krel * MaxCR) - CRcomp\n\n                WCr = WCr + CRcomp\n\n            # Update bottom elevation of compartment\n            zBot = zBot - prof.dz[compi]\n            # Update compartment and layer counters\n            compi = compi - 1\n            # Update restriction on maximum capillary rise\n            if compi &gt; -1:\n\n                zBotMid = zBot - (prof.dz[compi] / 2)\n                if (prof.Ksat[compi] &gt; 0) and (z_gw &gt; 0) and ((z_gw - zBotMid) &lt; 4):\n                    if zBotMid &gt;= z_gw:\n                        LimCR = 99\n                    else:\n                        LimCR = np.exp((np.log(z_gw - zBotMid) - prof.bCR[compi]) / prof.aCR[compi])\n                        if LimCR &gt; 99:\n                            LimCR = 99\n\n                else:\n                    LimCR = 0\n\n                if MaxCR &gt; LimCR:\n                    MaxCR = LimCR\n\n        # Store total depth of capillary rise\n        CrTot = WCr\n\n    return NewCond, CrTot\n</code></pre>"},{"location":"solution/#aquacrop.solution.cc_development","title":"<code>aquacrop.solution.cc_development</code>","text":""},{"location":"solution/#aquacrop.solution.cc_development.cc_development","title":"<code>cc_development(CCo, CCx, CGC, CDC, dt, Mode, CCx0)</code>","text":"<p>Function to calculate canopy cover development by end of the current simulation day</p> <p>Reference Manual: canopy_cover devlopment (pg. 21-24)</p> <p>Arguments:</p> <pre><code>CCo (float): Fractional canopy cover size at emergence\n\nCCx (float): Maximum canopy cover (fraction of soil cover)\n\nCGC (float): Canopy growth coefficient (fraction per gdd)\n\nCDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\ndt (float): Time delta of canopy growth (1 calander day or ... gdd)\n\nMode (str): stage of Canopy developement (Growth or Decline)\n\nCCx0 (float): Maximum canopy cover (fraction of soil cover)\n</code></pre> <p>Returns:</p> <pre><code>canopy_cover (float): Canopy Cover\n</code></pre> Source code in <code>aquacrop/solution/cc_development.py</code> <pre><code>def cc_development(\n    CCo: float,\n    CCx: float,\n    CGC: float,\n    CDC: float,\n    dt: float,\n    Mode: str,\n    CCx0: float,\n    ) -&gt; float:\n\n    \"\"\"\n    Function to calculate canopy cover development by end of the current simulation day\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=30\" target=\"_blank\"&gt;Reference Manual: canopy_cover devlopment&lt;/a&gt; (pg. 21-24)\n\n\n    Arguments:\n\n\n        CCo (float): Fractional canopy cover size at emergence\n\n        CCx (float): Maximum canopy cover (fraction of soil cover)\n\n        CGC (float): Canopy growth coefficient (fraction per gdd)\n\n        CDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\n        dt (float): Time delta of canopy growth (1 calander day or ... gdd)\n\n        Mode (str): stage of Canopy developement (Growth or Decline)\n\n        CCx0 (float): Maximum canopy cover (fraction of soil cover)\n\n    Returns:\n\n        canopy_cover (float): Canopy Cover\n\n\n\n    \"\"\"\n\n    ## Initialise output ##\n\n    ## Calculate new canopy cover ##\n    if Mode == \"Growth\":\n        # Calculate canopy growth\n        # Exponential growth stage\n        canopy_cover = CCo * np.exp(CGC * dt)\n        if canopy_cover &gt; (CCx / 2):\n            # Exponential decay stage\n            canopy_cover = CCx - 0.25 * (CCx / CCo) * CCx * np.exp(-CGC * dt)\n\n        # Limit canopy_cover to CCx\n        if canopy_cover &gt; CCx:\n            canopy_cover = CCx\n\n    elif Mode == \"Decline\":\n        # Calculate canopy decline\n        if CCx &lt; 0.001:\n            canopy_cover = 0\n        else:\n            canopy_cover = CCx * (\n                1\n                - 0.05\n                * (np.exp(dt * CDC * 3.33 * ((CCx + 2.29) / (CCx0 + 2.29)) / (CCx + 2.29)) - 1)\n            )\n\n    ## Limit canopy cover to between 0 and 1 ##\n    if canopy_cover &gt; 1:\n        canopy_cover = 1\n    elif canopy_cover &lt; 0:\n        canopy_cover = 0\n\n    return canopy_cover\n</code></pre>"},{"location":"solution/#aquacrop.solution.cc_required_time","title":"<code>aquacrop.solution.cc_required_time</code>","text":""},{"location":"solution/#aquacrop.solution.cc_required_time.cc_required_time","title":"<code>cc_required_time(cc_prev, CCo, CCx, CGC, CDC, Mode)</code>","text":"<p>Function to find time required to reach canopy_cover at end of previous day, given current CGC or CDC</p> <p>Reference Manual: canopy_cover devlopment (pg. 21-24)</p> <p>Arguments:</p> <pre><code>cc_prev (float): Canopy Cover at previous timestep.\n\nCCo (float): Fractional canopy cover size at emergence\n\nCCx (float): Maximum canopy cover (fraction of soil cover)\n\nCGC (float): Canopy growth coefficient (fraction per gdd)\n\nCDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\nMode (str): Canopy growth/decline coefficient (fraction per gdd/calendar day)\n</code></pre> <p>Returns:</p> <pre><code>tReq (float): time required to reach canopy_cover at end of previous day\n</code></pre> Source code in <code>aquacrop/solution/cc_required_time.py</code> <pre><code>def cc_required_time(\n    cc_prev: float,\n    CCo: float,\n    CCx: float,\n    CGC: float,\n    CDC: float,\n    Mode: str,\n    ) -&gt; float:\n    \"\"\"\n    Function to find time required to reach canopy_cover at end of previous day, given current CGC or CDC\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=30\" target=\"_blank\"&gt;Reference Manual: canopy_cover devlopment&lt;/a&gt; (pg. 21-24)\n\n\n    Arguments:\n\n        cc_prev (float): Canopy Cover at previous timestep.\n\n        CCo (float): Fractional canopy cover size at emergence\n\n        CCx (float): Maximum canopy cover (fraction of soil cover)\n\n        CGC (float): Canopy growth coefficient (fraction per gdd)\n\n        CDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\n        Mode (str): Canopy growth/decline coefficient (fraction per gdd/calendar day)\n\n\n    Returns:\n\n        tReq (float): time required to reach canopy_cover at end of previous day\n\n\n\n\n\n    \"\"\"\n\n    ## Get CGC and/or time (gdd or CD) required to reach canopy_cover on previous day ##\n    if Mode == \"CGC\":\n        if cc_prev &lt;= (CCx / 2):\n\n            # print(cc_prev,CCo,(tSum-dt),tSum,dt)\n            CGCx = np.log(cc_prev / CCo)\n            # print(np.log(cc_prev/CCo),(tSum-dt),CGCx)\n        else:\n            # print(CCx,CCo,cc_prev)\n            CGCx = np.log((0.25 * CCx * CCx / CCo) / (CCx - cc_prev))\n\n        tReq = CGCx / CGC\n\n    elif Mode == \"CDC\":\n        tReq = (np.log(1 + (1 - cc_prev / CCx) / 0.05)) / (CDC / CCx)\n\n    return tReq\n</code></pre>"},{"location":"solution/#aquacrop.solution.check_groundwater_table","title":"<code>aquacrop.solution.check_groundwater_table</code>","text":""},{"location":"solution/#aquacrop.solution.check_groundwater_table.check_groundwater_table","title":"<code>check_groundwater_table(prof, NewCond_zGW, NewCond_th, NewCond_th_fc_Adj, water_table_presence, z_gw)</code>","text":"<p>Function to check for presence of a groundwater table, and, if present, to adjust compartment water contents and field capacities where necessary</p> <p>Reference manual: water table adjustment equations (pg. 52-57)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): soil profile paramaters\n\nNewCond_zGW (float): groundwater depth\n\nNewCond_th (ndarray): water content in each soil commpartment\n\nNewCond_th_fc_Adj (ndarray): adjusted water content at field capacity\n\nwater_table_presence (int): indicates if water table is present or not\n\nz_gw (float): groundwater depth\n</code></pre> <p>Returns:</p> <pre><code>NewCond_th_fc_Adj (ndarray): adjusted water content at field capacity\n\nthfcAdj (ndarray): adjusted water content at field capacity\n</code></pre> Source code in <code>aquacrop/solution/check_groundwater_table.py</code> <pre><code>def check_groundwater_table(\n    prof: \"SoilProfile\",\n    NewCond_zGW: float,\n    NewCond_th: \"ndarray\",\n    NewCond_th_fc_Adj: \"ndarray\",\n    water_table_presence: int,\n    z_gw: float,\n) -&gt; \"ndarray\":\n    \"\"\"\n    Function to check for presence of a groundwater table, and, if present,\n    to adjust compartment water contents and field capacities where necessary\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=61\" target=\"_blank\"&gt;Reference manual: water table adjustment equations&lt;/a&gt; (pg. 52-57)\n\n\n    Arguments:\n\n        prof (SoilProfile): soil profile paramaters\n\n        NewCond_zGW (float): groundwater depth\n\n        NewCond_th (ndarray): water content in each soil commpartment\n\n        NewCond_th_fc_Adj (ndarray): adjusted water content at field capacity\n\n        water_table_presence (int): indicates if water table is present or not\n\n        z_gw (float): groundwater depth\n\n    Returns:\n\n        NewCond_th_fc_Adj (ndarray): adjusted water content at field capacity\n\n        thfcAdj (ndarray): adjusted water content at field capacity\n\n\n\n    \"\"\"\n\n    ## Perform calculations (if variable water table is present) ##\n    if water_table_presence == 1:\n\n        # Update groundwater conditions for current day\n        NewCond_zGW = z_gw\n\n        # Find compartment mid-points\n        zMid = prof.zMid\n\n        # Check if water table is within modelled soil profile\n        if NewCond_zGW &gt;= 0:\n            if len(zMid[zMid &gt;= NewCond_zGW]) == 0:\n                NewCond_WTinSoil = False\n            else:\n                NewCond_WTinSoil = True\n\n        # If water table is in soil profile, adjust water contents\n        # if NewCond_WTinSoil == True:\n        #     idx = np.argwhere(zMid &gt;= NewCond_zGW).flatten()[0]\n        #     for ii in range(idx, len(prof.Comp)):\n        #         NewCond_th[ii] = prof.th_s[ii]\n\n        # Adjust compartment field capacity\n        compi = len(prof.Comp) - 1\n        thfcAdj = np.zeros(compi + 1)\n        # Find thFCadj for all compartments\n        while compi &gt;= 0:\n            if prof.th_fc[compi] &lt;= 0.1:\n                Xmax = 1\n            else:\n                if prof.th_fc[compi] &gt;= 0.3:\n                    Xmax = 2\n                else:\n                    pF = 2 + 0.3 * (prof.th_fc[compi] - 0.1) / 0.2\n                    Xmax = (np.exp(pF * np.log(10))) / 100\n\n            if (NewCond_zGW &lt; 0) or ((NewCond_zGW - zMid[compi]) &gt;= Xmax):\n                for ii in range(compi + 1):\n\n                    thfcAdj[ii] = prof.th_fc[ii]\n\n                compi = -1\n            else:\n                if prof.th_fc[compi] &gt;= prof.th_s[compi]:\n                    thfcAdj[compi] = prof.th_fc[compi]\n                else:\n                    if zMid[compi] &gt;= NewCond_zGW:\n                        thfcAdj[compi] = prof.th_s[compi]\n                    else:\n                        dV = prof.th_s[compi] - prof.th_fc[compi]\n                        dFC = (dV / (Xmax * Xmax)) * ((zMid[compi] - (NewCond_zGW - Xmax)) ** 2)\n                        thfcAdj[compi] = prof.th_fc[compi] + dFC\n\n                compi = compi - 1\n\n        # Store adjusted field capacity values\n        NewCond_th_fc_Adj = thfcAdj\n        # prof.th_fc_Adj = thfcAdj\n        return (NewCond_th_fc_Adj, NewCond_WTinSoil, NewCond_zGW)\n\n    return (NewCond_th_fc_Adj, None, None)\n</code></pre>"},{"location":"solution/#aquacrop.solution.drainage","title":"<code>aquacrop.solution.drainage</code>","text":""},{"location":"solution/#aquacrop.solution.drainage.drainage","title":"<code>drainage(prof, th_init, th_fc_Adj_init)</code>","text":"<p>Function to redistribute stored soil water</p> <p>Reference Manual: drainage calculations (pg. 42-65)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): jit class object object containing soil paramaters\n\nth_init (numpy.array): initial water content\n\nth_fc_Adj_init (numpy.array): adjusted water content at field capacity\n</code></pre> <p>Returns:</p> <pre><code>thnew (numpy.array): updated water content in each compartment\n\nDeepPerc (float): Total Deep Percolation\n\nFluxOut (numpy.array): flux of water out of each compartment\n</code></pre> Source code in <code>aquacrop/solution/drainage.py</code> <pre><code>def drainage(\n    prof: \"SoilProfile\",\n    th_init: \"ndarray\",\n    th_fc_Adj_init: \"ndarray\",\n    ) -&gt; Tuple[\"ndarray\", float, float]:\n    \"\"\"\n    Function to redistribute stored soil water\n\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=51\" target=\"_blank\"&gt;Reference Manual: drainage calculations&lt;/a&gt; (pg. 42-65)\n\n\n    Arguments:\n\n        prof (SoilProfile): jit class object object containing soil paramaters\n\n        th_init (numpy.array): initial water content\n\n        th_fc_Adj_init (numpy.array): adjusted water content at field capacity\n\n\n    Returns:\n\n        thnew (numpy.array): updated water content in each compartment\n\n        DeepPerc (float): Total Deep Percolation\n\n        FluxOut (numpy.array): flux of water out of each compartment\n\n\n\n\n    \"\"\"\n\n    # Store initial conditions in new structure for updating %%\n    #     NewCond = InitCond\n\n    #     th_init = InitCond.th\n    #     th_fc_Adj_init = InitCond.th_fc_Adj\n\n    #  Preallocate arrays %%\n    thnew = np.zeros(th_init.shape[0])\n    FluxOut = np.zeros(th_init.shape[0])\n\n    # Initialise counters and states %%\n    drainsum = 0\n\n    # Calculate drainage and updated water contents %%\n    for ii in range(th_init.shape[0]):\n        # Specify layer for compartment\n        cth_fc = prof.th_fc[ii]\n        cth_s = prof.th_s[ii]\n        ctau = prof.tau[ii]\n        cdz = prof.dz[ii]\n        cdzsum = prof.dzsum[ii]\n        cKsat = prof.Ksat[ii]\n\n        # Calculate drainage ability of compartment ii\n        if th_init[ii] &lt;= th_fc_Adj_init[ii]:\n            dthdt = 0\n\n        elif th_init[ii] &gt;= cth_s:\n            dthdt = ctau * (cth_s - cth_fc)\n\n            if (th_init[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                dthdt = th_init[ii] - th_fc_Adj_init[ii]\n\n        else:\n            dthdt = (\n                ctau\n                * (cth_s - cth_fc)\n                * ((np.exp(th_init[ii] - cth_fc) - 1) / (np.exp(cth_s - cth_fc) - 1))\n            )\n\n            if (th_init[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                dthdt = th_init[ii] - th_fc_Adj_init[ii]\n\n        # Drainage from compartment ii (mm)\n        draincomp = dthdt * cdz * 1000\n\n        # Check drainage ability of compartment ii against cumulative drainage\n        # from compartments above\n        excess = 0\n        prethick = cdzsum - cdz\n        drainmax = dthdt * 1000 * prethick\n        if drainsum &lt;= drainmax:\n            drainability = True\n        else:\n            drainability = False\n\n        # Drain compartment ii\n        if drainability == True:\n            # No storage needed. Update water content in compartment ii\n            thnew[ii] = th_init[ii] - dthdt\n\n            # Update cumulative drainage (mm)\n            drainsum = drainsum + draincomp\n\n            # Restrict cumulative drainage to saturated hydraulic\n            # conductivity and adjust excess drainage flow\n            if drainsum &gt; cKsat:\n                excess = excess + drainsum - cKsat\n                drainsum = cKsat\n\n        elif drainability == False:\n            # Storage is needed\n            dthdt = drainsum / (1000 * prethick)\n\n            # Calculate value of theta (thX) needed to provide a\n            # drainage ability equal to cumulative drainage\n            if dthdt &lt;= 0:\n                thX = th_fc_Adj_init[ii]\n            elif ctau &gt; 0:\n                A = 1 + (\n                    (dthdt * (np.exp(cth_s - cth_fc) - 1)) / (ctau * (cth_s - cth_fc))\n                )\n                thX = cth_fc + np.log(A)\n                if thX &lt; th_fc_Adj_init[ii]:\n                    thX = th_fc_Adj_init[ii]\n\n            else:\n                thX = cth_s + 0.01\n\n            # Check thX against hydraulic properties of current soil layer\n            if thX &lt;= cth_s:\n                # Increase compartment ii water content with cumulative\n                # drainage\n                thnew[ii] = th_init[ii] + (drainsum / (1000 * cdz))\n                # Check updated water content against thX\n                if thnew[ii] &gt; thX:\n                    # Cumulative drainage is the drainage difference\n                    # between theta_x and new theta plus drainage ability\n                    # at theta_x.\n                    drainsum = (thnew[ii] - thX) * 1000 * cdz\n                    # Calculate drainage ability for thX\n                    if thX &lt;= th_fc_Adj_init[ii]:\n                        dthdt = 0\n                    elif thX &gt;= cth_s:\n                        dthdt = ctau * (cth_s - cth_fc)\n                        if (thX - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thX - th_fc_Adj_init[ii]\n\n                    else:\n                        dthdt = (\n                            ctau\n                            * (cth_s - cth_fc)\n                            * (\n                                (np.exp(thX - cth_fc) - 1)\n                                / (np.exp(cth_s - cth_fc) - 1)\n                            )\n                        )\n\n                        if (thX - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thX - th_fc_Adj_init[ii]\n\n                    # Update drainage total\n                    drainsum = drainsum + (dthdt * 1000 * cdz)\n                    # Restrict cumulative drainage to saturated hydraulic\n                    # conductivity and adjust excess drainage flow\n                    if drainsum &gt; cKsat:\n                        excess = excess + drainsum - cKsat\n                        drainsum = cKsat\n\n                    # Update water content\n                    thnew[ii] = thX - dthdt\n\n                elif thnew[ii] &gt; th_fc_Adj_init[ii]:\n                    # Calculate drainage ability for updated water content\n                    if thnew[ii] &lt;= th_fc_Adj_init[ii]:\n                        dthdt = 0\n                    elif thnew[ii] &gt;= cth_s:\n                        dthdt = ctau * (cth_s - cth_fc)\n                        if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                    else:\n                        dthdt = (\n                            ctau\n                            * (cth_s - cth_fc)\n                            * (\n                                (np.exp(thnew[ii] - cth_fc) - 1)\n                                / (np.exp(cth_s - cth_fc) - 1)\n                            )\n                        )\n                        if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                    # Update water content in compartment ii\n                    thnew[ii] = thnew[ii] - dthdt\n                    # Update cumulative drainage\n                    drainsum = dthdt * 1000 * cdz\n                    # Restrict cumulative drainage to saturated hydraulic\n                    # conductivity and adjust excess drainage flow\n                    if drainsum &gt; cKsat:\n                        excess = excess + drainsum - cKsat\n                        drainsum = cKsat\n\n                else:\n                    # Drainage and cumulative drainage are zero as water\n                    # content has not risen above field capacity in\n                    # compartment ii.\n                    drainsum = 0\n\n            elif thX &gt; cth_s:\n                # Increase water content in compartment ii with cumulative\n                # drainage from above\n                thnew[ii] = th_init[ii] + (drainsum / (1000 * cdz))\n                # Check new water content against hydraulic properties of soil\n                # layer\n                if thnew[ii] &lt;= cth_s:\n                    if thnew[ii] &gt; th_fc_Adj_init[ii]:\n                        # Calculate new drainage ability\n                        if thnew[ii] &lt;= th_fc_Adj_init[ii]:\n                            dthdt = 0\n                        elif thnew[ii] &gt;= cth_s:\n                            dthdt = ctau * (cth_s - cth_fc)\n                            if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                                dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                        else:\n                            dthdt = (\n                                ctau\n                                * (cth_s - cth_fc)\n                                * (\n                                    (np.exp(thnew[ii] - cth_fc) - 1)\n                                    / (np.exp(cth_s - cth_fc) - 1)\n                                )\n                            )\n                            if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                                dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                        # Update water content in compartment ii\n                        thnew[ii] = thnew[ii] - dthdt\n                        # Update cumulative drainage\n                        drainsum = dthdt * 1000 * cdz\n                        # Restrict cumulative drainage to saturated hydraulic\n                        # conductivity and adjust excess drainage flow\n                        if drainsum &gt; cKsat:\n                            excess = excess + drainsum - cKsat\n                            drainsum = cKsat\n\n                    else:\n                        drainsum = 0\n\n                elif thnew[ii] &gt; cth_s:\n                    # Calculate excess drainage above saturation\n                    excess = (thnew[ii] - cth_s) * 1000 * cdz\n                    # Calculate drainage ability for updated water content\n                    if thnew[ii] &lt;= th_fc_Adj_init[ii]:\n                        dthdt = 0\n                    elif thnew[ii] &gt;= cth_s:\n                        dthdt = ctau * (cth_s - cth_fc)\n                        if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                    else:\n                        dthdt = (\n                            ctau\n                            * (cth_s - cth_fc)\n                            * (\n                                (np.exp(thnew[ii] - cth_fc) - 1)\n                                / (np.exp(cth_s - cth_fc) - 1)\n                            )\n                        )\n                        if (thnew[ii] - dthdt) &lt; th_fc_Adj_init[ii]:\n                            dthdt = thnew[ii] - th_fc_Adj_init[ii]\n\n                    # Update water content in compartment ii\n                    thnew[ii] = cth_s - dthdt\n\n                    # Update drainage from compartment ii\n                    draincomp = dthdt * 1000 * cdz\n                    # Update maximum drainage\n                    drainmax = dthdt * 1000 * prethick\n\n                    # Update excess drainage\n                    if drainmax &gt; excess:\n                        drainmax = excess\n\n                    excess = excess - drainmax\n                    # Update drainsum and restrict to saturated hydraulic\n                    # conductivity of soil layer\n                    drainsum = draincomp + drainmax\n                    if drainsum &gt; cKsat:\n                        excess = excess + drainsum - cKsat\n                        drainsum = cKsat\n\n        # Store output flux from compartment ii\n        FluxOut[ii] = drainsum\n\n        # Redistribute excess in compartment above\n        if excess &gt; 0:\n            precomp = ii + 1\n            while (excess &gt; 0) and (precomp != 0):\n                # Update compartment counter\n                precomp = precomp - 1\n                # Update layer counter\n                # precompdf = Soil.Profile.Comp[precomp]\n\n                # Update flux from compartment\n                if precomp &lt; ii:\n                    FluxOut[precomp] = FluxOut[precomp] - excess\n\n                # Increase water content to store excess\n                thnew[precomp] = thnew[precomp] + (excess / (1000 * prof.dz[precomp]))\n\n                # Limit water content to saturation and adjust excess counter\n                if thnew[precomp] &gt; prof.th_s[precomp]:\n                    excess = (\n                        (thnew[precomp] - prof.th_s[precomp]) * 1000 * prof.dz[precomp]\n                    )\n                    thnew[precomp] = prof.th_s[precomp]\n                else:\n                    excess = 0\n\n    ## Update conditions and outputs ##\n    # Total deep percolation (mm)\n    DeepPerc = drainsum\n    # Water contents\n    # NewCond.th = thnew\n\n    return thnew, DeepPerc, FluxOut\n</code></pre>"},{"location":"solution/#aquacrop.solution.evap_layer_water_content","title":"<code>aquacrop.solution.evap_layer_water_content</code>","text":""},{"location":"solution/#aquacrop.solution.evap_layer_water_content.evap_layer_water_content","title":"<code>evap_layer_water_content(InitCond_th, InitCond_EvapZ, prof)</code>","text":"<p>Function to get water contents in the evaporation layer</p> <p>Reference Manual: evaporation equations (pg. 73-81)</p> <p>Arguments:</p> <pre><code>InitCond_th (numpy.array): Initial water content\n\nInitCond_EvapZ (float): evaporation depth\n\nprof (SoilProfile): Soil object containing soil paramaters\n</code></pre> <p>Returns:</p> <pre><code>Wevap_Sat (float): Water storage in evaporation layer at saturation (mm)\n\nWevap_Fc (float): Water storage in evaporation layer at field capacity (mm)\n\nWevap_Wp (float): Water storage in evaporation layer at permanent wilting point (mm)\n\nWevap_Dry (float): Water storage in evaporation layer at air dry (mm)\n\nWevap_Act (float): Actual water storage in evaporation layer (mm)\n</code></pre> Source code in <code>aquacrop/solution/evap_layer_water_content.py</code> <pre><code>def evap_layer_water_content(\n    InitCond_th: \"ndarray\",\n    InitCond_EvapZ: float,\n    prof: \"SoilProfile\",\n) -&gt; Tuple[float, float, float, float, float]:\n    \"\"\"\n    Function to get water contents in the evaporation layer\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=82\" target=\"_blank\"&gt;Reference Manual: evaporation equations&lt;/a&gt; (pg. 73-81)\n\n\n    Arguments:\n\n        InitCond_th (numpy.array): Initial water content\n\n        InitCond_EvapZ (float): evaporation depth\n\n        prof (SoilProfile): Soil object containing soil paramaters\n\n\n    Returns:\n\n\n        Wevap_Sat (float): Water storage in evaporation layer at saturation (mm)\n\n        Wevap_Fc (float): Water storage in evaporation layer at field capacity (mm)\n\n        Wevap_Wp (float): Water storage in evaporation layer at permanent wilting point (mm)\n\n        Wevap_Dry (float): Water storage in evaporation layer at air dry (mm)\n\n        Wevap_Act (float): Actual water storage in evaporation layer (mm)\n\n\n\n    \"\"\"\n\n    # Find soil compartments covered by evaporation layer\n    comp_sto = np.sum(prof.dzsum &lt; InitCond_EvapZ) + 1\n\n    Wevap_Sat = 0\n    Wevap_Fc = 0\n    Wevap_Wp = 0\n    Wevap_Dry = 0\n    Wevap_Act = 0\n\n    for ii in range(int(comp_sto)):\n\n        # Determine fraction of soil compartment covered by evaporation layer\n        if prof.dzsum[ii] &gt; InitCond_EvapZ:\n            factor = 1 - ((prof.dzsum[ii] - InitCond_EvapZ) / prof.dz[ii])\n        else:\n            factor = 1\n\n        # Actual water storage in evaporation layer (mm)\n        Wevap_Act += factor * 1000 * InitCond_th[ii] * prof.dz[ii]\n        # Water storage in evaporation layer at saturation (mm)\n        Wevap_Sat += factor * 1000 * prof.th_s[ii] * prof.dz[ii]\n        # Water storage in evaporation layer at field capacity (mm)\n        Wevap_Fc += factor * 1000 * prof.th_fc[ii] * prof.dz[ii]\n        # Water storage in evaporation layer at permanent wilting point (mm)\n        Wevap_Wp += factor * 1000 * prof.th_wp[ii] * prof.dz[ii]\n        # Water storage in evaporation layer at air dry (mm)\n        Wevap_Dry += factor * 1000 * prof.th_dry[ii] * prof.dz[ii]\n\n    if Wevap_Act &lt; 0:\n        Wevap_Act = 0\n\n    return Wevap_Sat, Wevap_Fc, Wevap_Wp, Wevap_Dry, Wevap_Act\n</code></pre>"},{"location":"solution/#aquacrop.solution.germination","title":"<code>aquacrop.solution.germination</code>","text":""},{"location":"solution/#aquacrop.solution.germination.germination","title":"<code>germination(InitCond, Soil_zGerm, prof, Crop_GermThr, Crop_PlantMethod, gdd, growing_season)</code>","text":"<p>Function to check if crop has germinated</p> <p>Reference Manual: germination condition (pg. 23)</p> <p>Arguments:</p> <pre><code>InitCond (InitialCondition): InitCond object containing model paramaters\n\nSoil_zGerm (float): Soil depth affecting germination\n\nprof (SoilProfile): Soil object containing soil paramaters\n\nCrop_GermThr (float): Crop germination threshold\n\nCrop_PlantMethod (bool): sown as seedling True or False\n\ngdd (float): Number of Growing Degree Days on current day\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n</code></pre> Source code in <code>aquacrop/solution/germination.py</code> <pre><code>def germination(\n    InitCond: \"InitialCondition\",\n    Soil_zGerm: float,\n    prof: \"SoilProfile\",\n    Crop_GermThr: float,\n    Crop_PlantMethod: bool,\n    gdd: float,\n    growing_season: bool,\n    ) -&gt; \"InitialCondition\":\n    \"\"\"\n    Function to check if crop has germinated\n\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=32\" target=\"_blank\"&gt;Reference Manual: germination condition&lt;/a&gt; (pg. 23)\n\n\n    Arguments:\n\n\n        InitCond (InitialCondition): InitCond object containing model paramaters\n\n        Soil_zGerm (float): Soil depth affecting germination\n\n        prof (SoilProfile): Soil object containing soil paramaters\n\n        Crop_GermThr (float): Crop germination threshold\n\n        Crop_PlantMethod (bool): sown as seedling True or False\n\n        gdd (float): Number of Growing Degree Days on current day\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n\n\n\n\n\n\n    \"\"\"\n\n    ## Store initial conditions in new structure for updating ##\n    NewCond = InitCond\n\n    ## Check for germination (if in growing season) ##\n    if growing_season == True:\n\n        if (NewCond.germination == False):\n            # Find compartments covered by top soil layer affecting germination\n            comp_sto = np.argwhere(prof.dzsum &gt;= Soil_zGerm).flatten()[0]\n            # Calculate water content in top soil layer\n            Wr = 0\n            WrFC = 0\n            WrWP = 0\n            for ii in range(comp_sto + 1):\n                # Get soil layer\n                # Determine fraction of compartment covered by top soil layer\n                if prof.dzsum[ii] &gt; Soil_zGerm:\n                    factor = 1 - ((prof.dzsum[ii] - Soil_zGerm) / prof.dz[ii])\n                else:\n                    factor = 1\n\n                # Increment actual water storage (mm)\n                Wr = Wr + round(factor * 1000 * InitCond.th[ii] * prof.dz[ii], 3)\n                # Increment water storage at field capacity (mm)\n                WrFC = WrFC + round(factor * 1000 * prof.th_fc[ii] * prof.dz[ii], 3)\n                # Increment water storage at permanent wilting point (mm)\n                WrWP = WrWP + round(factor * 1000 * prof.th_wp[ii] * prof.dz[ii], 3)\n\n            # Limit actual water storage to not be less than zero\n            if Wr &lt; 0:\n                Wr = 0\n\n            # Calculate proportional water content\n            WcProp = 1 - ((WrFC - Wr) / (WrFC - WrWP))\n\n            # Check if water content is above germination threshold\n            if (WcProp &gt;= Crop_GermThr):\n                # Crop has germinated\n                NewCond.germination = True\n                # If crop sown as seedling, turn on seedling protection\n                if Crop_PlantMethod == True:\n                    NewCond.protected_seed = True\n                else:\n                    # Crop is transplanted so no protection\n                    NewCond.protected_seed = False\n\n            # Increment delayed growth time counters if germination is yet to\n            # occur, and also set seed protection to False if yet to germinate\n            else:\n                NewCond.delayed_cds = InitCond.delayed_cds + 1\n                NewCond.delayed_gdds = InitCond.delayed_gdds + gdd\n                NewCond.protected_seed = False\n\n    else:\n        # Not in growing season so no germination calculation is performed.\n        NewCond.germination = False\n        NewCond.protected_seed = False\n        NewCond.delayed_cds = 0\n        NewCond.delayed_gdds = 0\n\n    return NewCond\n</code></pre>"},{"location":"solution/#aquacrop.solution.groundwater_inflow","title":"<code>aquacrop.solution.groundwater_inflow</code>","text":""},{"location":"solution/#aquacrop.solution.groundwater_inflow.groundwater_inflow","title":"<code>groundwater_inflow(prof, NewCond)</code>","text":"<p>Function to calculate capillary rise in the presence of a shallow groundwater table</p> <p>Reference Manual: capillary rise calculations (pg. 52-61)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): Soil profile parameters\n\nNewCond (InitialCondition): model parameters\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model parameters\n\nGwIn (float): Groundwater inflow\n</code></pre> Source code in <code>aquacrop/solution/groundwater_inflow.py</code> <pre><code>def groundwater_inflow(\n    prof: \"SoilProfile\",\n    NewCond: \"InitialCondition\"\n    ) -&gt; Tuple[\"InitialCondition\",float]:\n    \"\"\"\n    Function to calculate capillary rise in the presence of a shallow groundwater table\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=61\" target=\"_blank\"&gt;Reference Manual: capillary rise calculations&lt;/a&gt; (pg. 52-61)\n\n\n    Arguments:\n\n        prof (SoilProfile): Soil profile parameters\n\n        NewCond (InitialCondition): model parameters\n\n\n    Returns:\n\n\n        NewCond (InitialCondition): InitCond object containing updated model parameters\n\n        GwIn (float): Groundwater inflow\n\n\n    \"\"\"\n\n    ## Store initial conditions for updating ##\n    GwIn = 0\n\n    ## Perform calculations ##\n    if NewCond.wt_in_soil == True:\n        # Water table in soil profile. Calculate horizontal inflow.\n        # Get groundwater table elevation on current day\n        # print(f'Setting z_gw in groundwater_inflow.py as: {NewCond.z_gw}')\n        z_gw = NewCond.z_gw\n\n        # Find compartment mid-points\n        zMid = prof.zMid\n\n        idx = np.argwhere(zMid &gt;= z_gw).flatten()[0]\n\n        for ii in range(idx, len(prof.Comp)):\n            # Get soil layer\n            if NewCond.th[ii] &lt; prof.th_s[ii]:\n                # Update water content\n                dth = prof.th_s[ii] - NewCond.th[ii]\n                NewCond.th[ii] = prof.th_s[ii]\n                # Update groundwater inflow\n                GwIn = GwIn + (dth * 1000 * prof.dz[ii])\n\n    return NewCond, GwIn\n</code></pre>"},{"location":"solution/#aquacrop.solution.growing_degree_day","title":"<code>aquacrop.solution.growing_degree_day</code>","text":""},{"location":"solution/#aquacrop.solution.growing_degree_day.growing_degree_day","title":"<code>growing_degree_day(GDDmethod, Tupp, Tbase, temp_max, temp_min)</code>","text":"<p>Function to calculate number of growing degree days on current day</p> <p>Reference manual: growing degree day calculations (pg. 19-20)</p> <p>Arguments:</p> <pre><code>GDDmethod (int): gdd calculation method\n\nTupp (float): Upper temperature (degC) above which crop development no longer increases\n\nTbase (float): Base temperature (degC) below which growth does not progress\n\ntemp_max (float): Maximum tempature on current day (celcius)\n\ntemp_min (float): Minimum tempature on current day (celcius)\n</code></pre> <p>Returns:</p> <pre><code>gdd (float): Growing degree days for current day\n</code></pre> Source code in <code>aquacrop/solution/growing_degree_day.py</code> <pre><code>def growing_degree_day(\n    GDDmethod: int,\n    Tupp: float,\n    Tbase: float,\n    temp_max: float,\n    temp_min: float,\n    ):\n    \"\"\"\n    Function to calculate number of growing degree days on current day\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=28\" target=\"_blank\"&gt;Reference manual: growing degree day calculations&lt;/a&gt; (pg. 19-20)\n\n\n    Arguments:\n\n        GDDmethod (int): gdd calculation method\n\n        Tupp (float): Upper temperature (degC) above which crop development no longer increases\n\n        Tbase (float): Base temperature (degC) below which growth does not progress\n\n        temp_max (float): Maximum tempature on current day (celcius)\n\n        temp_min (float): Minimum tempature on current day (celcius)\n\n\n    Returns:\n\n        gdd (float): Growing degree days for current day\n\n\n\n    \"\"\"\n\n    ## Calculate GDDs ##\n    if GDDmethod == 1:\n        # method 1\n        Tmean = (temp_max + temp_min) / 2\n        Tmean = min(Tmean, Tupp)\n        Tmean = max(Tmean, Tbase)\n        gdd = Tmean - Tbase\n    elif GDDmethod == 2:\n        # method 2\n        temp_max = min(temp_max, Tupp)\n        temp_max = max(temp_max, Tbase)\n\n        temp_min = min(temp_min, Tupp)\n        temp_min = max(temp_min, Tbase)\n\n        Tmean = (temp_max + temp_min) / 2\n        gdd = Tmean - Tbase\n    elif GDDmethod == 3:\n        # method 3\n        temp_max = min(temp_max, Tupp)\n        temp_max = max(temp_max, Tbase)\n\n        temp_min = min(temp_min, Tupp)\n        Tmean = (temp_max + temp_min) / 2\n        Tmean = max(Tmean, Tbase)\n        gdd = Tmean - Tbase\n\n    return gdd\n</code></pre>"},{"location":"solution/#aquacrop.solution.growth_stage","title":"<code>aquacrop.solution.growth_stage</code>","text":""},{"location":"solution/#aquacrop.solution.growth_stage.growth_stage","title":"<code>growth_stage(Crop, InitCond, growing_season)</code>","text":"<p>Function to determine current growth stage of crop</p> <p>(used only for irrigation soil moisture thresholds)</p> <p>Arguments:</p> <pre><code>Crop (Crop): Crop object containing Crop paramaters\n\nInitCond (InitialCondition): InitCond object containing model paramaters\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n</code></pre> Source code in <code>aquacrop/solution/growth_stage.py</code> <pre><code>def growth_stage(\n    Crop: \"Crop\",\n    InitCond: \"InitialCondition\",\n    growing_season: bool,\n    ) -&gt; \"InitialCondition\":\n    \"\"\"\n    Function to determine current growth stage of crop\n\n    (used only for irrigation soil moisture thresholds)\n\n    Arguments:\n\n        Crop (Crop): Crop object containing Crop paramaters\n\n        InitCond (InitialCondition): InitCond object containing model paramaters\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n\n\n    \"\"\"\n\n    ## Store initial conditions in new structure for updating ##\n    NewCond = InitCond\n    ## Get growth stage (if in growing season) ##\n    if growing_season == True:\n        # Adjust time for any delayed growth\n        if Crop.CalendarType == 1:\n            tAdj = NewCond.dap - NewCond.delayed_cds\n        elif Crop.CalendarType == 2:\n            tAdj = NewCond.gdd_cum - NewCond.delayed_gdds\n\n        # Update growth stage\n        if tAdj &lt;= Crop.Canopy10Pct:\n            NewCond.growth_stage = 1\n        elif tAdj &lt;= Crop.MaxCanopy:\n            NewCond.growth_stage = 2\n        elif tAdj &lt;= Crop.Senescence:\n            NewCond.growth_stage = 3\n        elif tAdj &gt; Crop.Senescence:\n            NewCond.growth_stage = 4\n\n    else:\n        # Not in growing season so growth stage is set to dummy value\n        NewCond.growth_stage = 0\n\n    return NewCond\n</code></pre>"},{"location":"solution/#aquacrop.solution.harvest_index","title":"<code>aquacrop.solution.harvest_index</code>","text":""},{"location":"solution/#aquacrop.solution.harvest_index.harvest_index","title":"<code>harvest_index(prof, Soil_zTop, Crop, InitCond, et0, temp_max, temp_min, growing_season)</code>","text":"<p>Function to simulate build up of harvest index</p> <p>Reference Manual: harvest index calculations (pg. 110-126)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): Soil profile paramaters\n\nSoil_zTop (float): topsoil depth\n\nCrop (Crop): Crop parameters\n\nInitCond (InitialCondition): InitCond object containing model paramaters\n\net0 (float): reference evapotranspiration on current day\n\ntemp_max (float): maximum tempature on current day (celcius)\n\ntemp_min (float): minimum tempature on current day (celcius)\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n</code></pre> Source code in <code>aquacrop/solution/harvest_index.py</code> <pre><code>def harvest_index(\n    prof: \"SoilProfile\",\n    Soil_zTop: float,\n    Crop: \"Crop\",\n    InitCond: \"InitialCondition\",\n    et0: float,\n    temp_max: float,\n    temp_min: float,\n    growing_season: bool,\n    ) -&gt; \"InitialCondition\":\n\n    \"\"\"\n    Function to simulate build up of harvest index\n\n\n     &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual: harvest index calculations&lt;/a&gt; (pg. 110-126)\n\n    Arguments:\n\n\n        prof (SoilProfile): Soil profile paramaters\n\n        Soil_zTop (float): topsoil depth\n\n        Crop (Crop): Crop parameters\n\n        InitCond (InitialCondition): InitCond object containing model paramaters\n\n        et0 (float): reference evapotranspiration on current day\n\n        temp_max (float): maximum tempature on current day (celcius)\n\n        temp_min (float): minimum tempature on current day (celcius)\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n\n\n    \"\"\"\n\n    ## Store initial conditions for updating ##\n    NewCond = InitCond\n\n    InitCond_HI = InitCond.harvest_index\n    InitCond_HIadj = InitCond.harvest_index_adj\n    InitCond_PreAdj = InitCond.pre_adj\n\n    ## Calculate harvest index build up (if in growing season) ##\n    if growing_season == True:\n        # Calculate root zone water content\n\n        taw = TAW()\n        water_root_depletion = Dr()\n        # thRZ = RootZoneWater()\n        _, water_root_depletion.Zt, water_root_depletion.Rz, taw.Zt, taw.Rz, _,_,_,_,_,_, = root_zone_water(\n            prof,\n            float(NewCond.z_root),\n            NewCond.th,\n            Soil_zTop,\n            float(Crop.Zmin),\n            Crop.Aer,\n        )\n\n        # _,water_root_depletion,taw,_ = root_zone_water(Soil_Profile,float(NewCond.z_root),NewCond.th,Soil_zTop,float(Crop.Zmin),Crop.Aer)\n        # Check whether to use root zone or top soil depletions for calculating\n        # water stress\n        if (water_root_depletion.Rz / taw.Rz) &lt;= (water_root_depletion.Zt / taw.Zt):\n            # Root zone is wetter than top soil, so use root zone value\n            water_root_depletion = water_root_depletion.Rz\n            taw = taw.Rz\n        else:\n            # Top soil is wetter than root zone, so use top soil values\n            water_root_depletion = water_root_depletion.Zt\n            taw = taw.Zt\n\n        # Calculate water stress\n        beta = True\n        # Ksw = water_stress(Crop, NewCond, water_root_depletion, taw, et0, beta)\n        Ksw_Exp, Ksw_Sto, Ksw_Sen, Ksw_Pol, Ksw_StoLin = water_stress(\n            Crop.p_up,\n            Crop.p_lo,\n            Crop.ETadj,\n            Crop.beta,\n            Crop.fshape_w,\n            NewCond.t_early_sen,\n            water_root_depletion,\n            taw,\n            et0,\n            beta,\n        )\n        ksw = Ksw()\n        ksw.exp, ksw.sto, ksw.sen, ksw.pol, ksw.sto_lin = Ksw_Exp, Ksw_Sto, Ksw_Sen, Ksw_Pol, Ksw_StoLin\n        #Ksw = Ksw(exp=Ksw_Exp, sto=Ksw_Sto, sen=Ksw_Sen, pol=Ksw_Pol, sto_lin=Ksw_StoLin )\n        # Calculate temperature stress\n        (Kst_PolH,Kst_PolC) = temperature_stress(Crop, temp_max, temp_min)\n        kst = Kst()\n        kst.PolH, kst.PolC = Kst_PolH, Kst_PolC\n        #Kst = Kst(PolH=Kst_PolH,PolC=Kst_PolC)\n        # Get reference harvest index on current day\n        HIi = NewCond.hi_ref\n\n        # Get time for harvest index build-up\n        HIt = NewCond.dap - NewCond.delayed_cds - Crop.HIstartCD - 1\n\n        # Calculate harvest index\n        if (NewCond.yield_form == True) and (HIt &gt;= 0):\n            # print(NewCond.dap)\n            # Root/tuber or fruit/grain crops\n            if (Crop.CropType == 2) or (Crop.CropType == 3):\n                # Detemine adjustment for water stress before anthesis\n                if InitCond_PreAdj == False:\n                    InitCond.pre_adj = True\n                    NewCond.f_pre = HIadj_pre_anthesis(NewCond.biomass,\n                                                NewCond.biomass_ns,\n                                                NewCond.canopy_cover,\n                                                Crop.dHI_pre)\n\n                # Determine adjustment for crop pollination failure\n                if Crop.CropType == 3:  # Adjustment only for fruit/grain crops\n                    if (HIt &gt; 0) and (HIt &lt;= Crop.FloweringCD):\n\n                        NewCond.f_pol = HIadj_pollination(\n                            NewCond.canopy_cover,\n                            NewCond.f_pol,\n                            Crop.FloweringCD,\n                            Crop.CCmin,\n                            Crop.exc,\n                            ksw,\n                            kst,\n                            HIt,\n                        )\n\n                    HImax = NewCond.f_pol * Crop.HI0\n                else:\n                    # No pollination adjustment for root/tuber crops\n                    HImax = Crop.HI0\n\n                # Determine adjustments for post-anthesis water stress\n                if HIt &gt; 0:\n                    (NewCond.s_cor1,\n                    NewCond.s_cor2,\n                    NewCond.fpost_upp,\n                    NewCond.fpost_dwn,\n                    NewCond.f_post) = HIadj_post_anthesis(NewCond.delayed_cds,\n                                                        NewCond.s_cor1,\n                                                        NewCond.s_cor2,\n                                                        NewCond.dap,\n                                                        NewCond.f_pre,\n                                                        NewCond.canopy_cover,\n                                                        NewCond.fpost_upp,\n                                                        NewCond.fpost_dwn,\n                                                        Crop, \n                                                        ksw)\n\n                # Limit harvest_index to maximum allowable increase due to pre- and\n                # post-anthesis water stress combinations\n                HImult = NewCond.f_pre * NewCond.f_post\n                if HImult &gt; 1 + (Crop.dHI0 / 100):\n                    HImult = 1 + (Crop.dHI0 / 100)\n\n                # Determine harvest index on current day, adjusted for stress\n                # effects\n                if HImax &gt;= HIi:\n                    harvest_index_adj = HImult * HIi\n                else:\n                    harvest_index_adj = HImult * HImax\n\n            elif Crop.CropType == 1:\n                # Leafy vegetable crops - no adjustment, harvest index equal to\n                # reference value for current day\n                harvest_index_adj = HIi\n\n        else:\n\n            # No build-up of harvest index if outside yield_ formation period\n            HIi = InitCond_HI\n            harvest_index_adj = InitCond_HIadj\n\n        # Store final values for current time step\n        NewCond.harvest_index = HIi\n        NewCond.harvest_index_adj = harvest_index_adj\n\n    else:\n        # No harvestable crop outside of a growing season\n        NewCond.harvest_index = 0\n        NewCond.harvest_index_adj = 0\n\n    # print([NewCond.dap , Crop.YldFormCD])\n    return NewCond\n</code></pre>"},{"location":"solution/#aquacrop.solution.HIadj_pollination","title":"<code>aquacrop.solution.HIadj_pollination</code>","text":""},{"location":"solution/#aquacrop.solution.HIadj_pollination.HIadj_pollination","title":"<code>HIadj_pollination(NewCond_CC, NewCond_Fpol, Crop_FloweringCD, Crop_CCmin, Crop_exc, Ksw, Kst, HIt)</code>","text":"<p>Function to calculate adjustment to harvest index for failure of pollination due to water or temperature stress</p> <p>Reference Manual: harvest index calculations (pg. 110-126)</p> <p>Arguments:</p> <pre><code>NewCond_CC (float): InitCond object containing model paramaters\n\nNewCond_Fpol (float): InitCond object containing model paramaters\n\nCrop_FloweringCD (float): Length of flowering stage\n\nCrop_CCmin (float): minimum canopy cover\n\nCrop_exc (float):\n\nKsw (KswNT): Ksw object containing water stress paramaters\n\nKst (KstNT): Kst object containing tempature stress paramaters\n\nHIt (float): time for harvest index build-up (calander days)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n</code></pre> Source code in <code>aquacrop/solution/HIadj_pollination.py</code> <pre><code>def HIadj_pollination(\n    NewCond_CC: float,\n    NewCond_Fpol: float,\n    Crop_FloweringCD: float, \n    Crop_CCmin: float, \n    Crop_exc: float, \n    Ksw: \"Ksw\", \n    Kst: \"Kst\", \n    HIt: float,\n) -&gt; float:\n    \"\"\"\n    Function to calculate adjustment to harvest index for failure of\n    pollination due to water or temperature stress\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual: harvest index calculations&lt;/a&gt; (pg. 110-126)\n\n\n    Arguments:\n\n\n        NewCond_CC (float): InitCond object containing model paramaters\n\n        NewCond_Fpol (float): InitCond object containing model paramaters\n\n        Crop_FloweringCD (float): Length of flowering stage\n\n        Crop_CCmin (float): minimum canopy cover\n\n        Crop_exc (float): \n\n        Ksw (KswNT): Ksw object containing water stress paramaters\n\n        Kst (KstNT): Kst object containing tempature stress paramaters\n\n        HIt (float): time for harvest index build-up (calander days)\n\n\n    Returns:\n\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n\n\n    \"\"\"\n\n    ## Caclulate harvest index adjustment for pollination ##\n    # Get fractional flowering\n    if HIt == 0:\n        # No flowering yet\n        FracFlow = 0\n    elif HIt &gt; 0:\n        # Fractional flowering on previous day\n        t1 = HIt - 1\n        if t1 == 0:\n            F1 = 0\n        else:\n            t1Pct = 100 * (t1 / Crop_FloweringCD)\n            if t1Pct &gt; 100:\n                t1Pct = 100\n\n            F1 = 0.00558 * np.exp(0.63 * np.log(t1Pct)) - (0.000969 * t1Pct) - 0.00383\n\n        if F1 &lt; 0:\n            F1 = 0\n\n        # Fractional flowering on current day\n        t2 = HIt\n        if t2 == 0:\n            F2 = 0\n        else:\n            t2Pct = 100 * (t2 / Crop_FloweringCD)\n            if t2Pct &gt; 100:\n                t2Pct = 100\n\n            F2 = 0.00558 * np.exp(0.63 * np.log(t2Pct)) - (0.000969 * t2Pct) - 0.00383\n\n        if F2 &lt; 0:\n            F2 = 0\n\n        # Weight values\n        if abs(F1 - F2) &lt; 0.0000001:\n            F = 0\n        else:\n            F = 100 * ((F1 + F2) / 2) / Crop_FloweringCD\n\n        FracFlow = F\n\n    # Calculate pollination adjustment for current day\n    if NewCond_CC &lt; Crop_CCmin:\n        # No pollination can occur as canopy cover is smaller than minimum\n        # threshold\n        dFpol = 0\n    else:\n        Ks = min([Ksw.pol, Kst.PolC, Kst.PolH])\n        dFpol = Ks * FracFlow * (1 + (Crop_exc / 100))\n\n    # Calculate pollination adjustment to date\n    NewCond_Fpol = NewCond_Fpol + dFpol\n    if NewCond_Fpol &gt; 1:\n        # Crop has fully pollinated\n        NewCond_Fpol = 1\n\n    return NewCond_Fpol\n</code></pre>"},{"location":"solution/#aquacrop.solution.HIadj_post_anthesis","title":"<code>aquacrop.solution.HIadj_post_anthesis</code>","text":""},{"location":"solution/#aquacrop.solution.HIadj_post_anthesis.HIadj_post_anthesis","title":"<code>HIadj_post_anthesis(NewCond_DelayedCDs, NewCond_sCor1, NewCond_sCor2, NewCond_DAP, NewCond_Fpre, NewCond_CC, NewCond_fpost_upp, NewCond_fpost_dwn, Crop, Ksw)</code>","text":"<p>Function to calculate adjustment to harvest index for post-anthesis water stress</p> <p>Reference Manual: harvest index calculations (pg. 110-126)</p> <p>Arguments:</p> <pre><code>NewCond_DelayedCDs (int): delayed calendar days\n\nNewCond_sCor1 (float): canopy exapnsion\n\nNewCond_sCor2 (float): stomatal closure\n\nNewCond_DAP (int): days since planting\n\nNewCond_Fpre (float): delayed calendar days\n\nNewCond_CC (float): current canopy cover\n\nNewCond_fpost_upp (float): delayed calendar days\n\nNewCond_fpost_dwn (float): delayed calendar days\n\nCrop (CropStructNT): Crop paramaters\n\nKsw (KswNT): water stress paramaters\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n</code></pre> Source code in <code>aquacrop/solution/HIadj_post_anthesis.py</code> <pre><code>def HIadj_post_anthesis(\n    NewCond_DelayedCDs: int,\n    NewCond_sCor1: float,\n    NewCond_sCor2: float,\n    NewCond_DAP: int,\n    NewCond_Fpre: float,\n    NewCond_CC: float,\n    NewCond_fpost_upp: float,\n    NewCond_fpost_dwn: float,\n    Crop: \"Crop\", \n    Ksw: \"Ksw\",\n    ) -&gt; Tuple[float, float, float, float, float]:\n    \"\"\"\n    Function to calculate adjustment to harvest index for post-anthesis water\n    stress\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual: harvest index calculations&lt;/a&gt; (pg. 110-126)\n\n\n    Arguments:\n\n\n        NewCond_DelayedCDs (int): delayed calendar days\n\n        NewCond_sCor1 (float): canopy exapnsion\n\n        NewCond_sCor2 (float): stomatal closure\n\n        NewCond_DAP (int): days since planting\n\n        NewCond_Fpre (float): delayed calendar days\n\n        NewCond_CC (float): current canopy cover\n\n        NewCond_fpost_upp (float): delayed calendar days\n\n        NewCond_fpost_dwn (float): delayed calendar days\n\n        Crop (CropStructNT): Crop paramaters\n\n        Ksw (KswNT): water stress paramaters\n\n    Returns:\n\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n\n    \"\"\"\n\n    ## Store initial conditions in a structure for updating ##\n    # NewCond = InitCond\n\n    InitCond_DelayedCDs = NewCond_DelayedCDs*1\n    InitCond_sCor1 = NewCond_sCor1*1\n    InitCond_sCor2 = NewCond_sCor2*1\n\n    ## Calculate harvest index adjustment ##\n    # 1. Adjustment for leaf expansion\n    tmax1 = Crop.CanopyDevEndCD - Crop.HIstartCD\n    dap = NewCond_DAP - InitCond_DelayedCDs\n    if (\n        (dap &lt;= (Crop.CanopyDevEndCD + 1))\n        and (tmax1 &gt; 0)\n        and (NewCond_Fpre &gt; 0.99)\n        and (NewCond_CC &gt; 0.001)\n        and (Crop.a_HI &gt; 0)\n    ):\n        dCor = 1 + (1 - Ksw.exp) / Crop.a_HI\n        NewCond_sCor1 = InitCond_sCor1 + (dCor / tmax1)\n        DayCor = dap - 1 - Crop.HIstartCD\n        NewCond_fpost_upp = (tmax1 / DayCor) * NewCond_sCor1\n\n    # 2. Adjustment for stomatal closure\n    tmax2 = Crop.YldFormCD\n    dap = NewCond_DAP - InitCond_DelayedCDs\n    if (\n        (dap &lt;= (Crop.HIendCD + 1))\n        and (tmax2 &gt; 0)\n        and (NewCond_Fpre &gt; 0.99)\n        and (NewCond_CC &gt; 0.001)\n        and (Crop.b_HI &gt; 0)\n    ):\n        # print(Ksw.sto)\n        dCor = np.power(Ksw.sto, 0.1) * (1 - (1 - Ksw.sto) / Crop.b_HI)\n        NewCond_sCor2 = InitCond_sCor2 + (dCor / tmax2)\n        DayCor = dap - 1 - Crop.HIstartCD\n        NewCond_fpost_dwn = (tmax2 / DayCor) * NewCond_sCor2\n\n    # Determine total multiplier\n    if (tmax1 == 0) and (tmax2 == 0):\n        NewCond_Fpost = 1\n    else:\n        if tmax2 == 0:\n            NewCond_Fpost = NewCond_fpost_upp\n        else:\n            if tmax1 == 0:\n                NewCond_Fpost = NewCond_fpost_dwn\n            elif tmax1 &lt;= tmax2:\n                NewCond_Fpost = NewCond_fpost_dwn * (\n                    ((tmax1 * NewCond_fpost_upp) + (tmax2 - tmax1)) / tmax2\n                )\n            else:\n                NewCond_Fpost = NewCond_fpost_upp * (\n                    ((tmax2 * NewCond_fpost_dwn) + (tmax1 - tmax2)) / tmax1\n                )\n\n    return (\n            NewCond_sCor1,\n            NewCond_sCor2,\n            NewCond_fpost_upp,\n            NewCond_fpost_dwn,\n            NewCond_Fpost)\n</code></pre>"},{"location":"solution/#aquacrop.solution.HIadj_pre_anthesis","title":"<code>aquacrop.solution.HIadj_pre_anthesis</code>","text":""},{"location":"solution/#aquacrop.solution.HIadj_pre_anthesis.HIadj_pre_anthesis","title":"<code>HIadj_pre_anthesis(NewCond_B, NewCond_B_NS, NewCond_CC, Crop_dHI_pre)</code>","text":"<p>Function to calculate adjustment to harvest index for pre-anthesis water stress</p> <p>Reference Manual: harvest index calculations (pg. 110-126)</p> <p>Arguments:</p> <pre><code>NewCond_B (float): biomass growth\n\nNewCond_B_NS (float): biomass growth (no stress)\n\nNewCond_CC (float): canopy cover\n\nCrop_dHI_pre (float): Crop_dHI_pre\n</code></pre> <p>Returns:</p> <pre><code>NewCond_Fpre (float): adjustment to harvest index for pre-anthesis water stress\n</code></pre> Source code in <code>aquacrop/solution/HIadj_pre_anthesis.py</code> <pre><code>def HIadj_pre_anthesis(\n    NewCond_B: float,\n    NewCond_B_NS: float,\n    NewCond_CC: float,\n    Crop_dHI_pre: float\n    ) -&gt; float:\n    \"\"\"\n    Function to calculate adjustment to harvest index for pre-anthesis water\n    stress\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual: harvest index calculations&lt;/a&gt; (pg. 110-126)\n\n\n    Arguments:\n\n        NewCond_B (float): biomass growth\n\n        NewCond_B_NS (float): biomass growth (no stress)\n\n        NewCond_CC (float): canopy cover\n\n        Crop_dHI_pre (float): Crop_dHI_pre\n\n\n    Returns:\n\n\n        NewCond_Fpre (float): adjustment to harvest index for pre-anthesis water stress\n\n\n    \"\"\"\n\n    ## Store initial conditions in structure for updating ##\n    # NewCond = InitCond\n\n    # check that there is an adjustment to be made\n    if Crop_dHI_pre &gt; 0:\n        ## Calculate adjustment ##\n        # Get parameters\n        Br = NewCond_B / NewCond_B_NS\n        Br_range = np.log(Crop_dHI_pre) / 5.62\n        Br_upp = 1\n        Br_low = 1 - Br_range\n        Br_top = Br_upp - (Br_range / 3)\n\n        # Get biomass ratios\n        ratio_low = (Br - Br_low) / (Br_top - Br_low)\n        ratio_upp = (Br - Br_top) / (Br_upp - Br_top)\n\n        # Calculate adjustment factor\n        if (Br &gt;= Br_low) and (Br &lt; Br_top):\n            NewCond_Fpre = 1 + (\n                ((1 + np.sin((1.5 - ratio_low) * np.pi)) / 2) * (Crop_dHI_pre / 100)\n            )\n        elif (Br &gt; Br_top) and (Br &lt;= Br_upp):\n            NewCond_Fpre = 1 + (\n                ((1 + np.sin((0.5 + ratio_upp) * np.pi)) / 2) * (Crop_dHI_pre / 100)\n            )\n        else:\n            NewCond_Fpre = 1\n    else:\n        NewCond_Fpre = 1\n\n    if NewCond_CC &lt;= 0.01:\n        # No green canopy cover left at start of flowering so no harvestable\n        # crop will develop\n        NewCond_Fpre = 0\n\n    return NewCond_Fpre\n</code></pre>"},{"location":"solution/#aquacrop.solution.HIref_current_day","title":"<code>aquacrop.solution.HIref_current_day</code>","text":""},{"location":"solution/#aquacrop.solution.HIref_current_day.HIref_current_day","title":"<code>HIref_current_day(NewCond_HIref, NewCond_HIfinal, NewCond_DAP, NewCond_DelayedCDs, NewCond_YieldForm, NewCond_PctLagPhase, NewCond_CC, NewCond_CC_prev, NewCond_CCxW, Crop, growing_season)</code>","text":"<p>Function to calculate reference (no adjustment for stress effects) harvest index on current day</p> <p>Reference Manual: harvest index calculations (pg. 110-126)</p> <p>Arguments:</p> <pre><code>NewCond_HIref (float): reference harvest index\n\nNewCond_HIfinal (float): final harvest index to track effects of early canopy decline\n\nNewCond_DAP (int): days after planting\n\nNewCond_DelayedCDs (int): delayed calendar days\n\nNewCond_YieldForm (bool): yield formation stage\n\nNewCond_PctLagPhase (float): percent through eraly development phase\n\nNewCond_CC (float): canopy cover on current day\n\nNewCond_CCxW (float): max canopy cover during season accounting for any early senescence\n\nCrop (CropStructNT): Crop paramaters\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond (NewCond_HIref): reference harvest index\n\nNewCond (NewCond_YieldForm): yield formation stage\n\nNewCond (NewCond_PctLagPhase): percent through early development phase\n\nNewCond (NewCond_HIfinal): final harvest index to track effects of early canopy decline\n</code></pre> Source code in <code>aquacrop/solution/HIref_current_day.py</code> <pre><code>def HIref_current_day(\n    NewCond_HIref: float,\n    NewCond_HIfinal: float,\n    NewCond_DAP: int,\n    NewCond_DelayedCDs: int,\n    NewCond_YieldForm: bool,\n    NewCond_PctLagPhase: float,\n    NewCond_CC: float,\n    NewCond_CC_prev: float,\n    NewCond_CCxW: float,\n    Crop: \"CropStructNT\",\n    growing_season: bool,\n    ) -&gt; Tuple[float, bool, float]: #, float\n    \"\"\"\n    Function to calculate reference (no adjustment for stress effects)\n    harvest index on current day\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=119\" target=\"_blank\"&gt;Reference Manual: harvest index calculations&lt;/a&gt; (pg. 110-126)\n\n\n\n    Arguments:\n\n\n        NewCond_HIref (float): reference harvest index\n\n        NewCond_HIfinal (float): final harvest index to track effects of early canopy decline\n\n        NewCond_DAP (int): days after planting\n\n        NewCond_DelayedCDs (int): delayed calendar days\n\n        NewCond_YieldForm (bool): yield formation stage\n\n        NewCond_PctLagPhase (float): percent through eraly development phase\n\n        NewCond_CC (float): canopy cover on current day\n\n        NewCond_CCxW (float): max canopy cover during season accounting for any early senescence\n\n        Crop (CropStructNT): Crop paramaters\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n\n        NewCond (NewCond_HIref): reference harvest index\n\n        NewCond (NewCond_YieldForm): yield formation stage\n\n        NewCond (NewCond_PctLagPhase): percent through early development phase\n\n        NewCond (NewCond_HIfinal): final harvest index to track effects of early canopy decline\n\n\n    \"\"\"\n\n    ## Store initial conditions for updating ##\n    # NewCond = InitCond\n\n    InitCond_HIref = NewCond_HIref*1\n\n    # NewCond.hi_ref = 0.\n\n    ## Calculate reference harvest index (if in growing season) ##\n    if growing_season == True:\n        # Check if in yield_ formation period\n        tAdj = NewCond_DAP - NewCond_DelayedCDs\n        if tAdj &gt; Crop.HIstartCD:\n\n            NewCond_YieldForm = True\n        else:\n            NewCond_YieldForm = False\n\n        # Get time for harvest index calculation\n        HIt = NewCond_DAP - NewCond_DelayedCDs - Crop.HIstartCD - 1\n\n        if HIt &lt;= 0:\n            # Yet to reach time for harvest_index build-up\n            NewCond_HIref = 0\n            NewCond_PctLagPhase = 0\n        else:\n            # Check crop type\n            if (Crop.CropType == 1) or (Crop.CropType == 2):\n                # If crop type is leafy vegetable or root/tuber, then proceed with\n                # logistic growth (i.e. no linear switch)\n                NewCond_PctLagPhase = 100  # No lag phase\n                # Calculate reference harvest index for current day\n                NewCond_HIref = (Crop.HIini * Crop.HI0) / (\n                    Crop.HIini + (Crop.HI0 - Crop.HIini) * np.exp(-Crop.HIGC * HIt))\n                # Harvest index apprAOSP_hing maximum limit\n                if NewCond_HIref &gt;= (0.9799 * Crop.HI0):\n                    NewCond_HIref = Crop.HI0\n\n            elif Crop.CropType == 3:\n                # If crop type is fruit/grain producing, check for linear switch\n                if HIt &lt; Crop.tLinSwitch:\n                    # Not yet reached linear switch point, therefore proceed with\n                    # logistic build-up\n                    NewCond_PctLagPhase = 100 * (HIt / Crop.tLinSwitch)\n                    # Calculate reference harvest index for current day\n                    # (logistic build-up)\n                    NewCond_HIref = (Crop.HIini * Crop.HI0) / (\n                        Crop.HIini + (Crop.HI0 - Crop.HIini) * np.exp(-Crop.HIGC * HIt))\n                else:\n                    # Linear switch point has been reached\n                    NewCond_PctLagPhase = 100\n                    # Calculate reference harvest index for current day\n                    # (logistic portion)\n                    NewCond_HIref = (Crop.HIini * Crop.HI0) / (Crop.HIini\n                        + (Crop.HI0 - Crop.HIini) * np.exp(-Crop.HIGC * Crop.tLinSwitch))\n                    # Calculate reference harvest index for current day\n                    # (total - logistic portion + linear portion)\n                    NewCond_HIref = NewCond_HIref + (Crop.dHILinear * (HIt - Crop.tLinSwitch))\n\n            # Limit hi_ref and round off computed value\n            if NewCond_HIref &gt; Crop.HI0:\n                NewCond_HIref = Crop.HI0\n            elif NewCond_HIref &lt;= (Crop.HIini + 0.004):\n                NewCond_HIref = 0\n            elif (Crop.HI0 - NewCond_HIref) &lt; 0.004:\n                NewCond_HIref = Crop.HI0\n\n            # Adjust hi_ref for inadequate photosynthesis\n            if (NewCond_HIfinal == Crop.HI0) and (HIt &lt;= Crop.YldFormCD) and (NewCond_CC &lt;= 0.05) and (\n                NewCond_CCxW &gt; 0) and (NewCond_CC &lt; NewCond_CCxW) and (Crop.CropType==2 or Crop.CropType==3):\n\n                NewCond_HIfinal = NewCond_HIref\n\n            if NewCond_HIref &gt; NewCond_HIfinal:\n                NewCond_HIref = NewCond_HIfinal\n\n    else:\n        # Reference harvest index is zero outside of growing season\n        NewCond_HIref = 0\n\n    return (NewCond_HIref,\n            NewCond_YieldForm,\n            NewCond_PctLagPhase,\n            #NewCond_HIfinal,\n            )\n</code></pre>"},{"location":"solution/#aquacrop.solution.infiltration","title":"<code>aquacrop.solution.infiltration</code>","text":""},{"location":"solution/#aquacrop.solution.infiltration.infiltration","title":"<code>infiltration(prof, NewCond_SurfaceStorage, NewCond_th_fc_Adj, NewCond_th, Infl, Irr, IrrMngt_AppEff, FieldMngt_Bunds, FieldMngt_zBund, FluxOut, DeepPerc0, Runoff0, growing_season)</code>","text":"<p>Function to infiltrate incoming water (rainfall and irrigation)</p> <p>Reference Manual: drainage calculations (pg. 42-65)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): Soil object containing soil paramaters\n\nNewCond_SurfaceStorage (float): surface storage\n\nNewCond_th_fc_Adj (ndarray): water content at field capacity\n\nNewCond_th (ndarray): soil water content\n\nInfl (float): Infiltration so far\n\nIrr (float): Irrigation on current day\n\nIrrMngt_AppEff (float`: irrigation application efficiency\n\nFieldMngt (FieldMngtStruct): field management params\n\nFluxOut (np.array): flux of water out of each compartment\n\nDeepPerc0 (float): initial Deep Percolation\n\nRunoff0 (float): initial Surface Runoff\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond_th (nunpy.darray): updated soil water content\n\nNewCond_SurfaceStorage (float): updated surface storage\n\nDeepPerc (float): Total Deep Percolation\n\nRunoffTot (float): Total surface Runoff\n\nInfl (float): Infiltration on current day\n\nFluxOut (numpy.array): flux of water out of each compartment\n</code></pre> Source code in <code>aquacrop/solution/infiltration.py</code> <pre><code>def infiltration(\n     prof: \"SoilProfile\",\n     NewCond_SurfaceStorage: float, \n     NewCond_th_fc_Adj: \"ndarray\", \n     NewCond_th: \"ndarray\", \n     Infl: float, \n     Irr: float, \n     IrrMngt_AppEff: float, \n     FieldMngt_Bunds: bool,\n     FieldMngt_zBund: float,\n     FluxOut: \"ndarray\", \n     DeepPerc0: float, \n     Runoff0: float, \n     growing_season: bool,\n) -&gt; Tuple[\"ndarray\", float, float, float, float, \"ndarray\"]:\n    \"\"\"\n    Function to infiltrate incoming water (rainfall and irrigation)\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=51\" target=\"_blank\"&gt;Reference Manual: drainage calculations&lt;/a&gt; (pg. 42-65)\n\n\n\n    Arguments:\n\n\n\n        prof (SoilProfile): Soil object containing soil paramaters\n\n        NewCond_SurfaceStorage (float): surface storage\n\n        NewCond_th_fc_Adj (ndarray): water content at field capacity\n\n        NewCond_th (ndarray): soil water content\n\n        Infl (float): Infiltration so far\n\n        Irr (float): Irrigation on current day\n\n        IrrMngt_AppEff (float`: irrigation application efficiency\n\n        FieldMngt (FieldMngtStruct): field management params\n\n        FluxOut (np.array): flux of water out of each compartment\n\n        DeepPerc0 (float): initial Deep Percolation\n\n        Runoff0 (float): initial Surface Runoff\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n        NewCond_th (nunpy.darray): updated soil water content\n\n        NewCond_SurfaceStorage (float): updated surface storage\n\n        DeepPerc (float): Total Deep Percolation\n\n        RunoffTot (float): Total surface Runoff\n\n        Infl (float): Infiltration on current day\n\n        FluxOut (numpy.array): flux of water out of each compartment\n\n\n\n\n    \"\"\"\n    ## Store initial conditions in new structure for updating ##\n    # NewCond = InitCond\n\n    InitCond_SurfaceStorage = NewCond_SurfaceStorage*1\n    InitCond_th_fc_Adj = NewCond_th_fc_Adj*1\n    InitCond_th = NewCond_th*1\n\n    thnew = NewCond_th*1.\n\n    Soil_nComp = thnew.shape[0]\n\n    Infl = max(Infl,0.)\n\n    ## Update infiltration rate for irrigation ##\n    # Note: irrigation amount adjusted for specified application efficiency\n    if growing_season == True:\n        Infl = Infl + (Irr * (IrrMngt_AppEff / 100))\n\n    assert Infl &gt;= 0\n\n    ## Determine surface storage (if bunds are present) ##\n    if FieldMngt_Bunds:\n        # bunds on field\n        if FieldMngt_zBund &gt; 0.001:\n            # Bund height too small to be considered\n            InflTot = Infl + NewCond_SurfaceStorage\n            if InflTot &gt; 0:\n                # Update surface storage and infiltration storage\n                if InflTot &gt; prof.Ksat[0]:\n                    # Infiltration limited by saturated hydraulic conductivity\n                    # of surface soil layer\n                    ToStore = prof.Ksat[0]\n                    # Additional water ponds on surface\n                    NewCond_SurfaceStorage = InflTot - prof.Ksat[0]\n                else:\n                    # All water infiltrates\n                    ToStore = InflTot\n                    # Reset surface storage depth to zero\n                    NewCond_SurfaceStorage = 0\n\n                # Calculate additional runoff\n                if NewCond_SurfaceStorage &gt; FieldMngt_zBund:\n                    # Water overtops bunds and runs off\n                    RunoffIni = NewCond_SurfaceStorage - FieldMngt_zBund\n                    # Surface storage equal to bund height\n                    NewCond_SurfaceStorage = FieldMngt_zBund * 1\n                else:\n                    # No overtopping of bunds\n                    RunoffIni = 0\n\n            else:\n                # No storage or runoff\n                ToStore = 0\n                RunoffIni = 0\n\n    elif FieldMngt_Bunds == False:\n        # No bunds on field\n        if Infl &gt; prof.Ksat[0]:\n            # Infiltration limited by saturated hydraulic conductivity of top\n            # soil layer\n            ToStore = prof.Ksat[0]\n            # Additional water runs off\n            RunoffIni = Infl - prof.Ksat[0]\n        else:\n            # All water infiltrates\n            ToStore = Infl\n            RunoffIni = 0\n\n        # Update surface storage\n        NewCond_SurfaceStorage = 0\n        # Add any water remaining behind bunds to surface runoff (needed for\n        # days when bunds are removed to maintain water balance)\n        RunoffIni = RunoffIni + InitCond_SurfaceStorage\n\n    ## Initialise counters\n    ii = -1\n    Runoff = 0\n    ## Infiltrate incoming water ##\n    if ToStore &gt; 0:\n        while (ToStore &gt; 0) and (ii &lt; Soil_nComp - 1):\n            # Update compartment counter\n            ii = ii + 1\n            # Get soil layer\n\n            # Calculate saturated drainage ability\n            dthdtS = prof.tau[ii] * (prof.th_s[ii] - prof.th_fc[ii])\n            # Calculate drainage factor\n            factor = prof.Ksat[ii] / (dthdtS * 1000 * prof.dz[ii])\n\n            # Calculate drainage ability required\n            dthdt0 = ToStore / (1000 * prof.dz[ii])\n\n            # Check drainage ability\n            if dthdt0 &lt; dthdtS:\n                # Calculate water content, thX, needed to meet drainage dthdt0\n                if dthdt0 &lt;= 0:\n                    theta0 = InitCond_th_fc_Adj[ii]\n                else:\n                    A = 1 + (\n                        (dthdt0 * (np.exp(prof.th_s[ii] - prof.th_fc[ii]) - 1))\n                        / (prof.tau[ii] * (prof.th_s[ii] - prof.th_fc[ii]))\n                    )\n\n                    theta0 = prof.th_fc[ii] + np.log(A)\n\n                # Limit thX to between saturation and field capacity\n                if theta0 &gt; prof.th_s[ii]:\n                    theta0 = prof.th_s[ii]\n                elif theta0 &lt;= InitCond_th_fc_Adj[ii]:\n                    theta0 = InitCond_th_fc_Adj[ii]\n                    dthdt0 = 0\n\n            else:\n                # Limit water content and drainage to saturation\n                theta0 = prof.th_s[ii]\n                dthdt0 = dthdtS\n\n            # Calculate maximum water flow through compartment ii\n            drainmax = factor * dthdt0 * 1000 * prof.dz[ii]\n            # Calculate total drainage from compartment ii\n            drainage = drainmax + FluxOut[ii]\n            # Limit drainage to saturated hydraulic conductivity\n            if drainage &gt; prof.Ksat[ii]:\n                drainmax = prof.Ksat[ii] - FluxOut[ii]\n\n            # Calculate difference between threshold and current water contents\n            diff = theta0 - InitCond_th[ii]\n\n            if diff &gt; 0:\n                # Increase water content of compartment ii\n                thnew[ii] = thnew[ii] + (ToStore / (1000 * prof.dz[ii]))\n                if thnew[ii] &gt; theta0:\n                    # Water remaining that can infiltrate to compartments below\n                    ToStore = (thnew[ii] - theta0) * 1000 * prof.dz[ii]\n                    thnew[ii] = theta0\n                else:\n                    # All infiltrating water has been stored\n                    ToStore = 0\n\n            # Update outflow from current compartment (drainage + infiltration\n            # flows)\n            FluxOut[ii] = FluxOut[ii] + ToStore\n\n            # Calculate back-up of water into compartments above\n            excess = ToStore - drainmax\n            if excess &lt; 0:\n                excess = 0\n\n            # Update water to store\n            ToStore = ToStore - excess\n\n            # Redistribute excess to compartments above\n            if excess &gt; 0:\n                precomp = ii + 1\n                while (excess &gt; 0) and (precomp != 0):\n                    # Keep storing in compartments above until soil surface is\n                    # reached\n                    # Update compartment counter\n                    precomp = precomp - 1\n                    # Update layer number\n\n                    # Update outflow from compartment\n                    FluxOut[precomp] = FluxOut[precomp] - excess\n                    # Update water content\n                    thnew[precomp] = thnew[precomp] + (excess / (prof.dz[precomp] * 1000))\n                    # Limit water content to saturation\n                    if thnew[precomp] &gt; prof.th_s[precomp]:\n                        # Update excess to store\n                        excess = (thnew[precomp] - prof.th_s[precomp]) * 1000 * prof.dz[precomp]\n                        # Set water content to saturation\n                        thnew[precomp] = prof.th_s[precomp]\n                    else:\n                        # All excess stored\n                        excess = 0\n\n                if excess &gt; 0:\n                    # Any leftover water not stored becomes runoff\n                    Runoff = Runoff + excess\n\n        # Infiltration left to store after bottom compartment becomes deep\n        # percolation (mm)\n        DeepPerc = ToStore\n    else:\n        # No infiltration\n        DeepPerc = 0\n        Runoff = 0\n\n    ## Update total runoff ##\n    Runoff = Runoff + RunoffIni\n\n    ## Update surface storage (if bunds are present) ##\n    if Runoff &gt; RunoffIni:\n        if FieldMngt_Bunds:\n            if FieldMngt_zBund &gt; 0.001:\n                # Increase surface storage\n                NewCond_SurfaceStorage = NewCond_SurfaceStorage + (Runoff - RunoffIni)\n                # Limit surface storage to bund height\n                if NewCond_SurfaceStorage &gt; FieldMngt_zBund:\n                    # Additonal water above top of bunds becomes runoff\n                    Runoff = RunoffIni + (NewCond_SurfaceStorage - FieldMngt_zBund)\n                    # Set surface storage to bund height\n                    NewCond_SurfaceStorage = FieldMngt_zBund\n                else:\n                    # No additional overtopping of bunds\n                    Runoff = RunoffIni\n\n    ## Store updated water contents ##\n    NewCond_th = thnew\n\n    ## Update deep percolation, surface runoff, and infiltration values ##\n    DeepPerc = DeepPerc + DeepPerc0\n    Infl = Infl - Runoff\n    RunoffTot = Runoff + Runoff0\n\n    return NewCond_th,NewCond_SurfaceStorage, DeepPerc, RunoffTot, Infl, FluxOut\n</code></pre>"},{"location":"solution/#aquacrop.solution.irrigation","title":"<code>aquacrop.solution.irrigation</code>","text":""},{"location":"solution/#aquacrop.solution.irrigation.irrigation","title":"<code>irrigation(IrrMngt_IrrMethod, IrrMngt_SMT, IrrMngt_AppEff, IrrMngt_MaxIrr, IrrMngt_IrrInterval, IrrMngt_Schedule, IrrMngt_depth, IrrMngt_MaxIrrSeason, NewCond_GrowthStage, NewCond_IrrCum, NewCond_Epot, NewCond_Tpot, NewCond_Zroot, NewCond_th, NewCond_DAP, NewCond_TimeStepCounter, Crop, prof, Soil_zTop, growing_season, Rain, Runoff)</code>","text":"<p>Function to get irrigation depth for current day</p> <p>Reference Manual: irrigation description (pg. 31-32)</p> <p>Arguments:</p> <pre><code>IrrMngt_IrrMethod (int): irrigation method\n\nIrrMngt_SMT (numpy.array): soil-moisture thresholds\n\nIrrMngt_AppEff (float): application efficiency\n\nIrrMngt_MaxIrr (float): max irrigation depth per event\n\nIrrMngt_IrrInterval (int): irrigation event interval (days)\n\nIrrMngt_Schedule (numpy.array): irrigation depth schedule\n\nIrrMngt_depth (float): depth to apply next day\n\nIrrMngt_MaxIrrSeason (float): max irrigation for the season\n\nNewCond_GrowthStage (float): crop growth stage\n\nNewCond_IrrCum (float): irrigation applied so far this season\n\nNewCond_Epot (float): potential evaporation\n\nNewCond_Tpot (float): potential transpiration\n\nNewCond_Zroot (float): rooting depth\n\nNewCond_th (numpy.array): soil water content\n\nNewCond_DAP (int): days after planting\n\nNewCond_TimeStepCounter (int): current simulation timestep\n\nCrop (Crop): Crop paramaters\n\nSoil (SoilProfile): Soil object containing soil paramaters\n\ngrowing_season (bool): is growing season (True or Flase)\n\nRain (float): daily precipitation mm\n\nRunoff (float): surface runoff on current day\n</code></pre> <p>Returns:</p> <pre><code>NewCond_Depletion (float): soil water depletion\n\nNewCond_TAW (float): total available water\n\nNewCond_IrrCum (float): total irrigation aplpied so far\n\nIrr (float): Irrigaiton applied on current day mm\n</code></pre> Source code in <code>aquacrop/solution/irrigation.py</code> <pre><code>def irrigation(\n    IrrMngt_IrrMethod: int,\n    IrrMngt_SMT: float,\n    IrrMngt_AppEff: float,\n    IrrMngt_MaxIrr: float,\n    IrrMngt_IrrInterval: int,\n    IrrMngt_Schedule: \"ndarray\",\n    IrrMngt_depth: float,\n    IrrMngt_MaxIrrSeason: float,\n    NewCond_GrowthStage: float,\n    NewCond_IrrCum: float,\n    NewCond_Epot: float,\n    NewCond_Tpot: float,\n    NewCond_Zroot: float,\n    NewCond_th: \"ndarray\",\n    NewCond_DAP: int,\n    NewCond_TimeStepCounter: int,\n    Crop: \"Crop\",\n    prof: \"SoilProfile\",\n    Soil_zTop: float,\n    growing_season: bool,\n    Rain: float,\n    Runoff: float,\n    ) -&gt; Tuple[float,float,float, float]:\n    \"\"\"\n    Function to get irrigation depth for current day\n\n\n    &lt;a href=\"https://www.fao.org/3/BR246E/br246e.pdf#page=40\" target=\"_blank\"&gt;Reference Manual: irrigation description&lt;/a&gt; (pg. 31-32)\n\n\n    Arguments:\n\n\n        IrrMngt_IrrMethod (int): irrigation method\n\n        IrrMngt_SMT (numpy.array): soil-moisture thresholds\n\n        IrrMngt_AppEff (float): application efficiency\n\n        IrrMngt_MaxIrr (float): max irrigation depth per event\n\n        IrrMngt_IrrInterval (int): irrigation event interval (days)\n\n        IrrMngt_Schedule (numpy.array): irrigation depth schedule\n\n        IrrMngt_depth (float): depth to apply next day\n\n        IrrMngt_MaxIrrSeason (float): max irrigation for the season\n\n        NewCond_GrowthStage (float): crop growth stage\n\n        NewCond_IrrCum (float): irrigation applied so far this season\n\n        NewCond_Epot (float): potential evaporation\n\n        NewCond_Tpot (float): potential transpiration\n\n        NewCond_Zroot (float): rooting depth\n\n        NewCond_th (numpy.array): soil water content\n\n        NewCond_DAP (int): days after planting\n\n        NewCond_TimeStepCounter (int): current simulation timestep\n\n        Crop (Crop): Crop paramaters\n\n        Soil (SoilProfile): Soil object containing soil paramaters\n\n        growing_season (bool): is growing season (True or Flase)\n\n        Rain (float): daily precipitation mm\n\n        Runoff (float): surface runoff on current day\n\n\n    Returns:\n\n        NewCond_Depletion (float): soil water depletion\n\n        NewCond_TAW (float): total available water\n\n        NewCond_IrrCum (float): total irrigation aplpied so far\n\n        Irr (float): Irrigaiton applied on current day mm\n\n\n\"\"\"\n    ## Store intial conditions for updating ##\n    # NewCond = InitCond\n\n    ## Determine irrigation depth (mm/day) to be applied ##\n    if growing_season == True:\n        # Calculate root zone water content and depletion\n        # TAW_ = TAW()\n        # Dr_ = Dr()\n        # thRZ = RootZoneWater()\n        (\n            WrAct,\n            Dr_Zt,\n            Dr_Rz,\n            TAW_Zt,\n            TAW_Rz,\n            thRZ_Act,\n            thRZ_S,\n            thRZ_FC,\n            thRZ_WP,\n            thRZ_Dry,\n            thRZ_Aer,\n        ) = root_zone_water(\n            prof,\n            float(NewCond_Zroot),\n            NewCond_th,\n            Soil_zTop,\n            float(Crop.Zmin),\n            Crop.Aer,\n        )\n        # WrAct,Dr_,TAW_,thRZ = root_zone_water(prof,float(NewCond.z_root),NewCond.th,Soil_zTop,float(Crop.Zmin),Crop.Aer)\n        # Use root zone depletions and taw only for triggering irrigation\n        Dr = Dr_Rz\n        taw = TAW_Rz\n\n        # Determine adjustment for inflows and outflows on current day #\n        if thRZ_Act &gt; thRZ_FC:\n            rootdepth = max(NewCond_Zroot, Crop.Zmin)\n            AbvFc = (thRZ_Act - thRZ_FC) * 1000 * rootdepth\n        else:\n            AbvFc = 0\n\n        WCadj = NewCond_Tpot + NewCond_Epot - Rain + Runoff - AbvFc\n\n        NewCond_Depletion = Dr + WCadj\n        NewCond_TAW = taw\n\n        # Update growth stage if it is first day of a growing season\n        if NewCond_DAP == 1:\n            NewCond_GrowthStage = 1\n\n        if IrrMngt_IrrMethod == 0:\n            Irr = 0\n\n        elif IrrMngt_IrrMethod == 1:\n\n            Dr = NewCond_Depletion / NewCond_TAW\n            index = int(NewCond_GrowthStage) - 1\n\n            if Dr &gt; 1 - IrrMngt_SMT[index] / 100:\n                # Irrigation occurs\n                IrrReq = max(0, NewCond_Depletion)\n                # Adjust irrigation requirements for application efficiency\n                EffAdj = ((100 - IrrMngt_AppEff) + 100) / 100\n                IrrReq = IrrReq * EffAdj\n                # Limit irrigation to maximum depth\n                Irr = min(IrrMngt_MaxIrr, IrrReq)\n                # Irr = 15 # hard-code in 15mm depth for tests\n            else:\n                Irr = 0\n\n        elif IrrMngt_IrrMethod == 2:  # Irrigation - fixed interval\n\n            Dr = NewCond_Depletion\n\n            # Get number of days in growing season so far (subtract 1 so that\n            # always irrigate first on day 1 of each growing season)\n            nDays = NewCond_DAP - 1\n\n            if nDays % IrrMngt_IrrInterval == 0:\n                # Irrigation occurs\n                IrrReq = max(0, Dr)\n                # Adjust irrigation requirements for application efficiency\n                EffAdj = ((100 - IrrMngt_AppEff) + 100) / 100\n                IrrReq = IrrReq * EffAdj\n                # Limit irrigation to maximum depth\n                Irr = min(IrrMngt_MaxIrr, IrrReq)\n            else:\n                # No irrigation\n                Irr = 0\n\n        elif IrrMngt_IrrMethod == 3:  # Irrigation - pre-defined schedule\n            # Get current date\n            idx = NewCond_TimeStepCounter\n            # Find irrigation value corresponding to current date\n            Irr = IrrMngt_Schedule[idx]\n\n            assert Irr &gt;= 0\n\n            Irr = min(IrrMngt_MaxIrr, Irr)\n\n        elif IrrMngt_IrrMethod == 4:  # Irrigation - net irrigation\n            # Net irrigation calculation performed after transpiration, so\n            # irrigation is zero here\n\n            Irr = 0\n\n        elif IrrMngt_IrrMethod == 5:  # depth applied each day (usually specified outside of model)\n\n            Irr = min(IrrMngt_MaxIrr, IrrMngt_depth)\n\n        #         else:\n        #             assert 1 ==2, f'somethings gone wrong in irrigation method:{IrrMngt.irrigation_method}'\n\n        Irr = max(0, Irr)\n\n    elif growing_season == False:\n        # No irrigation outside growing season\n        Irr = 0.\n        NewCond_IrrCum = 0.\n        NewCond_Depletion = 0.\n        NewCond_TAW = 0.\n\n\n    if NewCond_IrrCum + Irr &gt; IrrMngt_MaxIrrSeason:\n        Irr = max(0, IrrMngt_MaxIrrSeason - NewCond_IrrCum)\n\n    # Update cumulative irrigation counter for growing season\n    NewCond_IrrCum = NewCond_IrrCum + Irr\n\n    return NewCond_Depletion,NewCond_TAW,NewCond_IrrCum, Irr\n</code></pre>"},{"location":"solution/#aquacrop.solution.pre_irrigation","title":"<code>aquacrop.solution.pre_irrigation</code>","text":""},{"location":"solution/#aquacrop.solution.pre_irrigation.pre_irrigation","title":"<code>pre_irrigation(prof, Crop, InitCond, growing_season, IrrMngt)</code>","text":"<p>Function to calculate pre-irrigation when in net irrigation mode</p> <p>Reference Manual: Net irrigation description (pg. 31)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): Soil object containing soil paramaters\n\nCrop (Crop): Crop object containing Crop paramaters\n\nInitCond (InitialCondition): InitCond object containing model paramaters\n\ngrowing_season (bool): is growing season (True or Flase)\n\nIrrMngt (IrrMngtStruct): object containing irrigation management paramaters\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition): InitCond object containing updated model paramaters\n\nPreIrr (float): Pre-Irrigaiton applied on current day mm\n</code></pre> Source code in <code>aquacrop/solution/pre_irrigation.py</code> <pre><code>def pre_irrigation(\n    prof: \"SoilProfile\",\n    Crop: \"Crop\",\n    InitCond: \"InitialCondition\",\n    growing_season: bool,\n    IrrMngt: \"IrrMngtStruct\",\n    ) -&gt; Tuple[\"InitialCondition\", float]:\n    \"\"\"\n    Function to calculate pre-irrigation when in net irrigation mode\n\n    &lt;a href=\"https://www.fao.org/3/BR246E/br246e.pdf#page=40\" target=\"_blank\"&gt;Reference Manual: Net irrigation description&lt;/a&gt; (pg. 31)\n\n\n    Arguments:\n\n        prof (SoilProfile): Soil object containing soil paramaters\n\n        Crop (Crop): Crop object containing Crop paramaters\n\n        InitCond (InitialCondition): InitCond object containing model paramaters\n\n        growing_season (bool): is growing season (True or Flase)\n\n        IrrMngt (IrrMngtStruct): object containing irrigation management paramaters\n\n\n\n    Returns:\n\n        NewCond (InitialCondition): InitCond object containing updated model paramaters\n\n        PreIrr (float): Pre-Irrigaiton applied on current day mm\n\n\n\n\n    \"\"\"\n    # Store initial conditions for updating ##\n    NewCond = InitCond\n\n    ## Calculate pre-irrigation needs ##\n    if growing_season == True:\n        if (IrrMngt.irrigation_method != 4) or (NewCond.dap != 1):\n            # No pre-irrigation as not in net irrigation mode or not on first day\n            # of the growing season\n            PreIrr = 0\n        else:\n            # Determine compartments covered by the root zone\n            rootdepth = round(max(NewCond.z_root, Crop.Zmin), 2)\n\n            compRz = np.argwhere(prof.dzsum &gt;= rootdepth).flatten()[0]\n\n            PreIrr = 0\n            for ii in range(int(compRz)):\n\n                # Determine critical water content threshold\n                thCrit = prof.th_wp[ii] + (\n                    (IrrMngt.NetIrrSMT / 100) * (prof.th_fc[ii] - prof.th_wp[ii])\n                )\n\n                # Check if pre-irrigation is required\n                if NewCond.th[ii] &lt; thCrit:\n                    PreIrr = PreIrr + ((thCrit - NewCond.th[ii]) * 1000 * prof.dz[ii])\n                    NewCond.th[ii] = thCrit\n\n    else:\n        PreIrr = 0\n\n    return NewCond, PreIrr\n</code></pre>"},{"location":"solution/#aquacrop.solution.rainfall_partition","title":"<code>aquacrop.solution.rainfall_partition</code>","text":""},{"location":"solution/#aquacrop.solution.rainfall_partition.rainfall_partition","title":"<code>rainfall_partition(precipitation, InitCond_th, NewCond_DaySubmerged, FieldMngt_SRinhb, FieldMngt_Bunds, FieldMngt_zBund, FieldMngt_CNadjPct, Soil_CN, Soil_AdjCN, Soil_zCN, Soil_nComp, prof)</code>","text":"<p>Function to partition rainfall into surface runoff and infiltration using the curve number approach</p> <p>Reference Manual: rainfall partition calculations (pg. 48-51)</p> <p>Arguments:</p> <pre><code>precipitation (float): Percipitation on current day\n\nInitCond_th (numpy.array): InitCond object containing model paramaters\n\nNewCond_DaySubmerged (int): number of days submerged\n\nFieldMngt_SRinhb (float): field management params\n\nFieldMngt_Bunds (bool): field management params\n\nFieldMngt_zBund (float): bund height\n\nFieldMngt_CNadjPct (float): curve number adjustment percent\n\nSoil_CN (float): curve number\n\nSoil_AdjCN (float): adjusted curve number\n\nSoil_zCN (float` :\n\nSoil_nComp (float): number of compartments\n\nprof (SoilProfile): Soil object\n</code></pre> <p>Returns:</p> <pre><code>Runoff (float): Total Suface Runoff\n\nInfl (float): Total Infiltration\n\nNewCond_DaySubmerged (float): number of days submerged\n</code></pre> Source code in <code>aquacrop/solution/rainfall_partition.py</code> <pre><code>def rainfall_partition(\n    precipitation: float,\n    InitCond_th: \"ndarray\",\n    NewCond_DaySubmerged: int,\n    FieldMngt_SRinhb: float,\n    FieldMngt_Bunds: bool,\n    FieldMngt_zBund: float,\n    FieldMngt_CNadjPct: float,\n    Soil_CN: float,\n    Soil_AdjCN: float,\n    Soil_zCN: float,\n    Soil_nComp: int,\n    prof: \"SoilProfile\",\n) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Function to partition rainfall into surface runoff and infiltration using the curve number approach\n\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=57\" target=\"_blank\"&gt;Reference Manual: rainfall partition calculations&lt;/a&gt; (pg. 48-51)\n\n\n    Arguments:\n\n        precipitation (float): Percipitation on current day\n\n        InitCond_th (numpy.array): InitCond object containing model paramaters\n\n        NewCond_DaySubmerged (int): number of days submerged\n\n        FieldMngt_SRinhb (float): field management params\n\n        FieldMngt_Bunds (bool): field management params\n\n        FieldMngt_zBund (float): bund height\n\n        FieldMngt_CNadjPct (float): curve number adjustment percent\n\n        Soil_CN (float): curve number\n\n        Soil_AdjCN (float): adjusted curve number\n\n        Soil_zCN (float` :\n\n        Soil_nComp (float): number of compartments\n\n        prof (SoilProfile): Soil object\n\n    Returns:\n\n        Runoff (float): Total Suface Runoff\n\n        Infl (float): Total Infiltration\n\n        NewCond_DaySubmerged (float): number of days submerged\n\n\n    \"\"\"\n\n    # can probs make this faster by doing a if precipitation=0 loop\n\n    ## Store initial conditions for updating ##\n    # NewCond = InitCond\n\n    ## Calculate runoff ##\n    if (FieldMngt_SRinhb == False) and ((FieldMngt_Bunds == False) or (FieldMngt_zBund &lt; 0.001)):\n        # Surface runoff is not inhibited and no soil bunds are on field\n        # Reset submerged days\n        NewCond_DaySubmerged = 0\n        # Adjust curve number for field management practices\n        cn = Soil_CN * (1 + (FieldMngt_CNadjPct / 100))\n        if Soil_AdjCN == 1:  # Adjust cn for antecedent moisture\n            # Calculate upper and lowe curve number bounds\n            CNbot = round(\n                1.4 * (np.exp(-14 * np.log(10)))\n                + (0.507 * cn)\n                - (0.00374 * cn ** 2)\n                + (0.0000867 * cn ** 3)\n            )\n            CNtop = round(\n                5.6 * (np.exp(-14 * np.log(10)))\n                + (2.33 * cn)\n                - (0.0209 * cn ** 2)\n                + (0.000076 * cn ** 3)\n            )\n            # Check which compartment cover depth of top soil used to adjust\n            # curve number\n            comp_sto_array = prof.dzsum[prof.dzsum &gt;= Soil_zCN]\n            if comp_sto_array.shape[0] == 0:\n                comp_sto = int(Soil_nComp)\n            else:\n                comp_sto = int(Soil_nComp - comp_sto_array.shape[0])\n\n            comp_sto+=1\n\n            # Calculate weighting factors by compartment\n            xx = 0\n            wrel = np.zeros(comp_sto)\n            for ii in range(comp_sto):\n                if prof.dzsum[ii] &gt; Soil_zCN:\n                    prof.dzsum[ii] = Soil_zCN\n\n                wx = 1.016 * (1 - np.exp(-4.16 * (prof.dzsum[ii] / Soil_zCN)))\n                wrel[ii] = wx - xx\n                if wrel[ii] &lt; 0:\n                    wrel[ii] = 0\n                elif wrel[ii] &gt; 1:\n                    wrel[ii] = 1\n\n                xx = wx\n\n            # Calculate relative wetness of top soil\n            wet_top = 0\n            # prof = prof\n\n            for ii in range(comp_sto):\n                th = max(prof.th_wp[ii], InitCond_th[ii])\n                wet_top = wet_top + (\n                    wrel[ii] * ((th - prof.th_wp[ii]) / (prof.th_fc[ii] - prof.th_wp[ii]))\n                )\n\n            # Calculate adjusted curve number\n            if wet_top &gt; 1:\n                wet_top = 1\n            elif wet_top &lt; 0:\n                wet_top = 0\n\n            cn = round(CNbot + (CNtop - CNbot) * wet_top)\n\n        # Partition rainfall into runoff and infiltration (mm)\n        S = (25400 / cn) - 254\n        term = precipitation - ((5 / 100) * S)\n        if term &lt;= 0:\n            Runoff = 0\n            Infl = precipitation\n        else:\n            Runoff = (term ** 2) / (precipitation + (1 - (5 / 100)) * S)\n            Infl = precipitation - Runoff\n\n    else:\n        # bunds on field, therefore no surface runoff\n        Runoff = 0\n        Infl = precipitation\n\n    return Runoff, Infl, NewCond_DaySubmerged\n</code></pre>"},{"location":"solution/#aquacrop.solution.root_development","title":"<code>aquacrop.solution.root_development</code>","text":""},{"location":"solution/#aquacrop.solution.root_development.root_development","title":"<code>root_development(Crop, prof, NewCond_DAP, NewCond_Zroot, NewCond_DelayedCDs, NewCond_GDDcum, NewCond_DelayedGDDs, NewCond_TrRatio, NewCond_th, NewCond_CC, NewCond_CC_NS, NewCond_Germination, NewCond_rCor, NewCond_Tpot, NewCond_zGW, gdd, growing_season, water_table_presence)</code>","text":"<p>Function to calculate root zone expansion</p> <p>Reference Manual: root developement equations (pg. 37-41)</p> <p>Arguments:</p> <pre><code>Crop (Crop): crop params\n\nprof (SoilProfile): soilv profile paramaters\n\nNewCond_DAP (float): days after planting\n\nNewCond_Zroot (float): root depth\n\nNewCond_DelayedCDs (float): delayed calendar days\n\nNewCond_GDDcum (float): cumulative growing degree days\n\nNewCond_TrRatio (float): transpiration ratio\n\nNewCond_CC (float): canopy cover\n\nNewCond_CC_NS (float): canopy cover no-stress\n\nNewCond_Germination (float): germination flag\n\nNewCond_rCor (float):\n\nNewCond_DAP (float): days after planting\n\nNewCond_Tpot (float): potential transpiration\n\nNewCond_zGW (float): groundwater depth\n\ngdd (float): Growing degree days on current day\n\ngrowing_season (bool): is growing season (True or Flase)\n\nwater_table_presence (int): water table present (True=1 or Flase=0)\n</code></pre> <p>Returns:</p> <pre><code>NewCond_Zroot (float): updated rooting depth\n</code></pre> Source code in <code>aquacrop/solution/root_development.py</code> <pre><code>def root_development(\n    Crop: \"Crop\",\n    prof: \"SoilProfile\",\n    NewCond_DAP: float,\n    NewCond_Zroot: float,\n    NewCond_DelayedCDs: float,\n    NewCond_GDDcum: float,\n    NewCond_DelayedGDDs: float,\n    NewCond_TrRatio: float,\n    NewCond_th: \"ndarray\",\n    NewCond_CC: float,\n    NewCond_CC_NS: float,\n    NewCond_Germination: bool,\n    NewCond_rCor: float,\n    NewCond_Tpot: float,\n    NewCond_zGW: float,\n    gdd: float,\n    growing_season: bool,\n    water_table_presence: int,\n    ) -&gt; float:\n    \"\"\"\n    Function to calculate root zone expansion\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=46\" target=\"_blank\"&gt;Reference Manual: root developement equations&lt;/a&gt; (pg. 37-41)\n\n\n    Arguments:\n\n        Crop (Crop): crop params\n\n        prof (SoilProfile): soilv profile paramaters\n\n        NewCond_DAP (float): days after planting\n\n        NewCond_Zroot (float): root depth\n\n        NewCond_DelayedCDs (float): delayed calendar days\n\n        NewCond_GDDcum (float): cumulative growing degree days\n\n        NewCond_TrRatio (float): transpiration ratio\n\n        NewCond_CC (float): canopy cover\n\n        NewCond_CC_NS (float): canopy cover no-stress\n\n        NewCond_Germination (float): germination flag\n\n        NewCond_rCor (float): \n\n        NewCond_DAP (float): days after planting\n\n        NewCond_Tpot (float): potential transpiration\n\n        NewCond_zGW (float): groundwater depth\n\n        gdd (float): Growing degree days on current day\n\n        growing_season (bool): is growing season (True or Flase)\n\n        water_table_presence (int): water table present (True=1 or Flase=0)\n\n\n    Returns:\n\n        NewCond_Zroot (float): updated rooting depth\n\n\n    \"\"\"\n    # Store initial conditions for updating\n    # NewCond = InitCond\n\n    # save initial zroot\n    Zroot_init = float(NewCond_Zroot) * 1.0\n    Soil_nLayer = np.unique(prof.Layer).shape[0]\n\n    # Calculate root expansion (if in growing season)\n    if growing_season == True:\n        # If today is first day of season, root depth is equal to minimum depth\n        if NewCond_DAP == 1:\n            NewCond_Zroot = float(Crop.Zmin) * 1.0\n            Zroot_init = float(Crop.Zmin) * 1.0\n\n        # Adjust time for any delayed development\n        if Crop.CalendarType == 1:\n            tAdj = NewCond_DAP - NewCond_DelayedCDs\n        elif Crop.CalendarType == 2:\n            tAdj = NewCond_GDDcum - NewCond_DelayedGDDs\n\n        # Calculate root expansion #\n        Zini = Crop.Zmin * (Crop.PctZmin / 100)\n        t0 = round((Crop.Emergence / 2))\n        tmax = Crop.MaxRooting\n        if Crop.CalendarType == 1:\n            tOld = tAdj - 1\n        elif Crop.CalendarType == 2:\n            tOld = tAdj - gdd\n\n        # Potential root depth on previous day\n        if tOld &gt;= tmax:\n            ZrOld = Crop.Zmax\n        elif tOld &lt;= t0:\n            ZrOld = Zini\n        else:\n            X = (tOld - t0) / (tmax - t0)\n            ZrOld = Zini + (Crop.Zmax - Zini) * np.power(X, 1 / Crop.fshape_r)\n\n        if ZrOld &lt; Crop.Zmin:\n            ZrOld = Crop.Zmin\n\n        # Potential root depth on current day\n        if tAdj &gt;= tmax:\n            Zr = Crop.Zmax\n        elif tAdj &lt;= t0:\n            Zr = Zini\n        else:\n            X = (tAdj - t0) / (tmax - t0)\n            Zr = Zini + (Crop.Zmax - Zini) * np.power(X, 1 / Crop.fshape_r)\n\n        if Zr &lt; Crop.Zmin:\n            Zr = Crop.Zmin\n\n        # Store Zr as potential value\n        ZrPot = Zr\n\n        # Determine rate of change\n        dZr = Zr - ZrOld\n\n        # Adjust expansion rate for presence of restrictive soil horizons\n        if Zr &gt; Crop.Zmin:\n            layeri = 1\n            l_idx = np.argwhere(prof.Layer == layeri).flatten()\n            Zsoil = prof.dz[l_idx].sum()\n            while (round(Zsoil, 2) &lt;= Crop.Zmin) and (layeri &lt; Soil_nLayer):\n                layeri = layeri + 1\n                l_idx = np.argwhere(prof.Layer == layeri).flatten()\n                Zsoil = Zsoil + prof.dz[l_idx].sum()\n\n            soil_layer_dz = prof.dz[l_idx].sum()\n            layer_comp = l_idx[0]\n            # soil_layer = prof.Layer[layeri]\n            ZrAdj = Crop.Zmin\n            ZrRemain = Zr - Crop.Zmin\n            deltaZ = Zsoil - Crop.Zmin\n            EndProf = False\n            while EndProf == False:\n                ZrTest = ZrAdj + (ZrRemain * (prof.Penetrability[layer_comp] / 100))\n                if (\n                    (layeri == Soil_nLayer)\n                    or (prof.Penetrability[layer_comp] == 0)\n                    or (ZrTest &lt;= Zsoil)\n                ):\n                    ZrOUT = ZrTest\n                    EndProf = True\n                else:\n                    ZrAdj = Zsoil\n                    ZrRemain = ZrRemain - (deltaZ / (prof.Penetrability[layer_comp] / 100))\n                    layeri = layeri + 1\n                    l_idx = np.argwhere(prof.Layer == layeri).flatten()\n                    layer_comp = l_idx[0]\n                    soil_layer_dz = prof.dz[l_idx].sum()\n                    Zsoil = Zsoil + soil_layer_dz\n                    deltaZ = soil_layer_dz\n\n            # Correct Zr and dZr for effects of restrictive horizons\n            Zr = max(ZrOUT, ZrOld)\n            dZr = Zr - ZrOld\n\n        # Adjust rate of expansion for any stomatal water stress\n        if NewCond_TrRatio &lt; 0.9999:\n            if Crop.fshape_ex &gt;= 0:\n                dZr = dZr * NewCond_TrRatio\n            else:\n                fAdj = (np.exp(NewCond_TrRatio * Crop.fshape_ex) - 1) / (np.exp(Crop.fshape_ex) - 1)\n                dZr = dZr * fAdj\n\n        # print(NewCond.dap,NewCond.th)\n\n        # Adjust rate of root expansion for dry soil at expansion front\n        if dZr &gt; 0.001:\n            # Define water stress threshold for inhibition of root expansion\n            pZexp = Crop.p_up[1] + ((1 - Crop.p_up[1]) / 2)\n            # Define potential new root depth\n            ZiTmp = float(Zroot_init + dZr)\n            # Find compartment that root zone will expand in to\n            # compi_index = prof.dzsum[prof.dzsum&gt;=ZiTmp].index[0] # have changed to index\n            idx = np.argwhere(prof.dzsum &gt;= ZiTmp).flatten()[0]\n            prof = prof\n            # Get taw in compartment\n            layeri = prof.Layer[idx]\n            TAWprof = prof.th_fc[idx] - prof.th_wp[idx]\n            # Define stress threshold\n            thThr = prof.th_fc[idx] - (pZexp * TAWprof)\n            # Check for stress conditions\n            if NewCond_th[idx] &lt; thThr:\n                # Root expansion limited by water content at expansion front\n                if NewCond_th[idx] &lt;= prof.th_wp[idx]:\n\n                    # Expansion fully inhibited\n                    dZr = 0\n                else:\n                    # Expansion partially inhibited\n                    Wrel = (prof.th_fc[idx] - NewCond_th[idx]) / TAWprof\n                    Drel = 1 - ((1 - Wrel) / (1 - pZexp))\n                    Ks = 1 - (\n                        (np.exp(Drel * Crop.fshape_w[1]) - 1) / (np.exp(Crop.fshape_w[1]) - 1)\n                    )\n                    dZr = dZr * Ks\n\n        # Adjust for early senescence\n        if (NewCond_CC &lt;= 0) and (NewCond_CC_NS &gt; 0.5):\n            dZr = 0\n\n        # Adjust root expansion for failure to germinate (roots cannot expand\n        # if crop has not germinated)\n        if NewCond_Germination == False:\n            dZr = 0\n\n        # Get new rooting depth\n        NewCond_Zroot = float(Zroot_init + dZr)\n\n        # Adjust root density if deepening is restricted due to dry subsoil\n        # and/or restrictive layers\n        if NewCond_Zroot &lt; ZrPot:\n            NewCond_rCor = (\n                2 * (ZrPot / NewCond_Zroot) * ((Crop.SxTop + Crop.SxBot) / 2) - Crop.SxTop\n            ) / Crop.SxBot\n\n            if NewCond_Tpot &gt; 0:\n                NewCond_rCor = NewCond_rCor * NewCond_TrRatio\n                if NewCond_rCor &lt; 1:\n                    NewCond_rCor = 1\n\n        else:\n            NewCond_rCor = 1\n\n        # Limit rooting depth if groundwater table is present (roots cannot\n        # develop below the water table)\n        if (water_table_presence == 1) and (NewCond_zGW &gt; 0):\n            if NewCond_Zroot &gt; NewCond_zGW:\n                NewCond_Zroot = float(NewCond_zGW)\n                if NewCond_Zroot &lt; Crop.Zmin:\n                    NewCond_Zroot = float(Crop.Zmin)\n\n    else:\n        # No root system outside of the growing season\n        NewCond_Zroot = 0\n\n    return NewCond_Zroot, NewCond_rCor\n</code></pre>"},{"location":"solution/#aquacrop.solution.root_zone_water","title":"<code>aquacrop.solution.root_zone_water</code>","text":""},{"location":"solution/#aquacrop.solution.root_zone_water.root_zone_water","title":"<code>root_zone_water(prof, InitCond_Zroot, InitCond_th, Soil_zTop, Crop_Zmin, Crop_Aer)</code>","text":"<p>Function to calculate actual and total available water in the rootzone at current time step</p> <p>Reference Manual: root-zone water calculations (pg. 5-8)</p> <p>Arguments:</p> <pre><code>prof (SoilProfile): jit class Object containing soil paramaters\n\nInitCond_Zroot (float): Initial rooting depth\n\nInitCond_th (np.array): Initial water content\n\nSoil_zTop (float): Top soil depth\n\nCrop_Zmin (float): crop minimum rooting depth\n\nCrop_Aer (int): number of aeration stress days\n</code></pre> <p>Returns:</p> <pre><code>WrAct (float):  Actual rootzone water content\n\nDr_Zt (float):  topsoil depletion\n\nDr_Rz (float):  rootzone depletion\n\nTAW_Zt (float):  topsoil total available water\n\nTAW_Rz (float):  rootzone total available water\n\nthRZ_Act (float):  Actual rootzone water content\n\nthRZ_S (float):  rootzone water content at saturation\n\nthRZ_FC (float):  rootzone water content at field capacity\n\nthRZ_WP (float):  rootzone water content at wilting point\n\nthRZ_Dry (float):  rootzone water content at air dry\n\nthRZ_Aer (float):  rootzone water content at aeration stress threshold\n</code></pre> Source code in <code>aquacrop/solution/root_zone_water.py</code> <pre><code>def root_zone_water(\n    prof: \"SoilProfile\",\n    InitCond_Zroot: float,\n    InitCond_th: \"ndarray\",\n    Soil_zTop: float,\n    Crop_Zmin: float,\n    Crop_Aer: float,\n) -&gt; Tuple[float, float, float, float, float, float, float, float, float, float, float]:\n    \"\"\"\n    Function to calculate actual and total available water in the rootzone at current time step\n\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=14\" target=\"_blank\"&gt;Reference Manual: root-zone water calculations&lt;/a&gt; (pg. 5-8)\n\n\n    Arguments:\n\n        prof (SoilProfile): jit class Object containing soil paramaters\n\n        InitCond_Zroot (float): Initial rooting depth\n\n        InitCond_th (np.array): Initial water content\n\n        Soil_zTop (float): Top soil depth\n\n        Crop_Zmin (float): crop minimum rooting depth\n\n        Crop_Aer (int): number of aeration stress days\n\n    Returns:\n\n        WrAct (float):  Actual rootzone water content\n\n        Dr_Zt (float):  topsoil depletion\n\n        Dr_Rz (float):  rootzone depletion\n\n        TAW_Zt (float):  topsoil total available water\n\n        TAW_Rz (float):  rootzone total available water\n\n        thRZ_Act (float):  Actual rootzone water content\n\n        thRZ_S (float):  rootzone water content at saturation\n\n        thRZ_FC (float):  rootzone water content at field capacity\n\n        thRZ_WP (float):  rootzone water content at wilting point\n\n        thRZ_Dry (float):  rootzone water content at air dry\n\n        thRZ_Aer (float):  rootzone water content at aeration stress threshold \n\n\n    \"\"\"\n\n    ## Calculate root zone water content and available water ##\n    # Compartments covered by the root zone\n    rootdepth = round(np.maximum(InitCond_Zroot, Crop_Zmin), 2)\n    comp_sto = np.argwhere(prof.dzsum &gt;= rootdepth).flatten()[0]\n\n    # Initialise counters\n    WrAct = 0\n    WrS = 0\n    WrFC = 0\n    WrWP = 0\n    WrDry = 0\n    WrAer = 0\n    for ii in range(comp_sto + 1):\n        # Fraction of compartment covered by root zone\n        if prof.dzsum[ii] &gt; rootdepth:\n            factor = 1 - ((prof.dzsum[ii] - rootdepth) / prof.dz[ii])\n        else:\n            factor = 1\n\n        # Actual water storage in root zone (mm)\n        WrAct = WrAct + round(factor * 1000 * InitCond_th[ii] * prof.dz[ii], 2)\n        # Water storage in root zone at saturation (mm)\n        WrS = WrS + round(factor * 1000 * prof.th_s[ii] * prof.dz[ii], 2)\n        # Water storage in root zone at field capacity (mm)\n        WrFC = WrFC + round(factor * 1000 * prof.th_fc[ii] * prof.dz[ii], 2)\n        # Water storage in root zone at permanent wilting point (mm)\n        WrWP = WrWP + round(factor * 1000 * prof.th_wp[ii] * prof.dz[ii], 2)\n        # Water storage in root zone at air dry (mm)\n        WrDry = WrDry + round(factor * 1000 * prof.th_dry[ii] * prof.dz[ii], 2)\n        # Water storage in root zone at aeration stress threshold (mm)\n        WrAer = WrAer + round(factor * 1000 * (prof.th_s[ii] - (Crop_Aer / 100)) * prof.dz[ii], 2)\n\n    if WrAct &lt; 0:\n        WrAct = 0\n\n    # define total available water, depletion, root zone water content\n    # taw = TAW()\n    # Dr = Dr()\n    # thRZ = RootZoneWater()\n\n    # Calculate total available water (m3/m3)\n    TAW_Rz = max(WrFC - WrWP, 0.0)\n    # Calculate soil water depletion (mm)\n    Dr_Rz = min(WrFC - WrAct, TAW_Rz)\n\n    # Actual root zone water content (m3/m3)\n    thRZ_Act = WrAct / (rootdepth * 1000)\n    # Root zone water content at saturation (m3/m3)\n    thRZ_S = WrS / (rootdepth * 1000)\n    # Root zone water content at field capacity (m3/m3)\n    thRZ_FC = WrFC / (rootdepth * 1000)\n    # Root zone water content at permanent wilting point (m3/m3)\n    thRZ_WP = WrWP / (rootdepth * 1000)\n    # Root zone water content at air dry (m3/m3)\n    thRZ_Dry = WrDry / (rootdepth * 1000)\n    # Root zone water content at aeration stress threshold (m3/m3)\n    thRZ_Aer = WrAer / (rootdepth * 1000)\n\n    # print('inside')\n\n    # thRZ = thRZNT(\n    # Act=thRZ_Act,\n    # S=thRZ_S,\n    # FC=thRZ_FC,\n    # WP=thRZ_WP,\n    # Dry=thRZ_Dry,\n    # Aer=thRZ_Aer,\n    # )\n    # print(thRZ)\n\n\n    ## Calculate top soil water content and available water ##\n    if rootdepth &gt; Soil_zTop:\n        # Determine compartments covered by the top soil\n        ztopdepth = round(Soil_zTop, 2)\n        comp_sto = np.sum(prof.dzsum &lt;= ztopdepth)\n        # Initialise counters\n        WrAct_Zt = 0\n        WrFC_Zt = 0\n        WrWP_Zt = 0\n        # Calculate water storage in top soil\n        assert comp_sto &gt; 0\n\n        for ii in range(comp_sto):\n\n            # Fraction of compartment covered by root zone\n            if prof.dzsum[ii] &gt; ztopdepth:\n                factor = 1 - ((prof.dzsum[ii] - ztopdepth) / prof.dz[ii])\n            else:\n                factor = 1\n\n            # Actual water storage in top soil (mm)\n            WrAct_Zt = WrAct_Zt + (factor * 1000 * InitCond_th[ii] * prof.dz[ii])\n            # Water storage in top soil at field capacity (mm)\n            WrFC_Zt = WrFC_Zt + (factor * 1000 * prof.th_fc[ii] * prof.dz[ii])\n            # Water storage in top soil at permanent wilting point (mm)\n            WrWP_Zt = WrWP_Zt + (factor * 1000 * prof.th_wp[ii] * prof.dz[ii])\n\n        # Ensure available water in top soil is not less than zero\n        if WrAct_Zt &lt; 0:\n            WrAct_Zt = 0\n\n        # Calculate total available water in top soil (m3/m3)\n        TAW_Zt = max(WrFC_Zt - WrWP_Zt, 0)\n        # Calculate depletion in top soil (mm)\n        Dr_Zt = min(WrFC_Zt - WrAct_Zt, TAW_Zt)\n    else:\n        # Set top soil depletions and taw to root zone values\n        Dr_Zt = Dr_Rz\n        TAW_Zt = TAW_Rz\n\n\n    return (\n        WrAct,\n        Dr_Zt,\n        Dr_Rz,\n        TAW_Zt,\n        TAW_Rz,\n        thRZ_Act,\n        thRZ_S,\n        thRZ_FC,\n        thRZ_WP,\n        thRZ_Dry,\n        thRZ_Aer,\n    )\n</code></pre>"},{"location":"solution/#aquacrop.solution.soil_evaporation","title":"<code>aquacrop.solution.soil_evaporation</code>","text":""},{"location":"solution/#aquacrop.solution.soil_evaporation.soil_evaporation","title":"<code>soil_evaporation(ClockStruct_EvapTimeSteps, ClockStruct_SimOffSeason, ClockStruct_TimeStepCounter, prof, Soil_EvapZmin, Soil_EvapZmax, Soil_REW, Soil_Kex, Soil_fwcc, Soil_fWrelExp, Soil_fevap, Crop_CalendarType, Crop_Senescence, IrrMngt_IrrMethod, IrrMngt_WetSurf, FieldMngt_Mulches, FieldMngt_fMulch, FieldMngt_MulchPct, NewCond_DAP, NewCond_Wsurf, NewCond_EvapZ, NewCond_Stage2, NewCond_th, NewCond_DelayedCDs, NewCond_GDDcum, NewCond_DelayedGDDs, NewCond_CCxW, NewCond_CCadj, NewCond_CCxAct, NewCond_CC, NewCond_PrematSenes, NewCond_SurfaceStorage, NewCond_Wstage2, NewCond_Epot, et0, Infl, Rain, Irr, growing_season)</code>","text":"<p>Function to calculate daily soil evaporation</p> <p>Reference Manual: evaporation equations (pg. 73-81)</p> <p>Arguments:</p> <pre><code>ClockStruct_EvapTimeSteps (int): number of evaportation time steps\n\nClockStruct_SimOffSeason (bool): simulate off season? (False=no, True=yes)\n\nClockStruct_TimeStepCounter (int): time step counter\n\nprof (SoilProfile): soil profile object\n\nSoil_EvapZmin (float): minimum evaporation depth (m)\n\nSoil_EvapZmax (float): maximum evaporation depth (m)\n\nSoil_REW (float): Readily Evaporable Water\n\nSoil_Kex (float): Soil evaporation coefficient\n\nSoil_fwcc (float):\n\nSoil_fWrelExp (float):\n\nSoil_fevap (float):\n\nCrop_CalendarType (int): calendar type\n\nCrop_Senescence (float):\n\nIrrMngt_IrrMethod (int): irrigation method\n\nIrrMngt_WetSurf (float): wet surface area\n\nFieldMngt_Mulches (bool): mulch present? (0=no, 1=yes)\n\nFieldMngt_fMulch (float): mulch factor\n\nFieldMngt_MulchPct (float): mulch percentage\n\nNewCond_DAP (int): days after planting\n\nNewCond_Wsurf (float): wet surface area\n\nNewCond_EvapZ (float): evaporation depth (m)\n\nNewCond_Stage2 (float): stage 2 evaporation\n\nNewCond_th (ndarray): soil water content\n\nNewCond_DelayedCDs: delayed calendar days\n\nNewCond_GDDcum (float): cumulative growing degree days\n\nNewCond_DelayedGDDs (float): delayed growing degree days\n\nNewCond_CCxW (float):\n\nNewCond_CCadj (float): canopy cover adjusted\n\nNewCond_CCxAct: max canopy cover actual\n\nNewCond_CC (float): canopy cover\n\nNewCond_PrematSenes (bool): prematurity senescence? (0=no, 1=yes)\n\nNewCond_SurfaceStorage (float): surface storage\n\nNewCond_Wstage2 (float): stage 2 water content\n\nNewCond_Epot (float): potential evaporation\n\net0 (float): daily reference evapotranspiration\n\nInfl (float): Infiltration on current day\n\nRain (float): daily precipitation mm\n\nIrr (float): Irrigation applied on current day\n\ngrowing_season (bool): is growing season (True or Flase)\n</code></pre> <p>Returns:</p> <pre><code>NewCond_Epot (float): Potential surface evaporation current day\n\nNewCond_th (ndarray): updated soil water content\n\nNewCond_Stage2 (bool): stage 2 soil evaporation\n\nNewCond_Wstage2 (float): stage 2 soil evaporation\n\nNewCond_Wsurf (float): updated surface water content\n\nNewCond_SurfaceStorage (float): updated surface storage\n\nNewCond_EvapZ (float): updated evaporation layer depth\n\nEsAct (float): Actual surface evaporation current day\n\nEsPot (float): Potential surface evaporation current day\n</code></pre> Source code in <code>aquacrop/solution/soil_evaporation.py</code> <pre><code>def soil_evaporation(\n    ClockStruct_EvapTimeSteps: int,\n    ClockStruct_SimOffSeason: bool,\n    ClockStruct_TimeStepCounter: int,\n    prof: \"SoilProfile\",\n    Soil_EvapZmin: float,\n    Soil_EvapZmax: float,\n    Soil_REW: float,\n    Soil_Kex: float,\n    Soil_fwcc: float,\n    Soil_fWrelExp: float,\n    Soil_fevap: float,\n    Crop_CalendarType: int,\n    Crop_Senescence: float,\n    IrrMngt_IrrMethod: int,\n    IrrMngt_WetSurf: float,\n    FieldMngt_Mulches: bool,\n    FieldMngt_fMulch: float,\n    FieldMngt_MulchPct: float,\n    NewCond_DAP: int,\n    NewCond_Wsurf: float,\n    NewCond_EvapZ: float,\n    NewCond_Stage2: float,\n    NewCond_th: \"ndarray\",\n    NewCond_DelayedCDs: float,\n    NewCond_GDDcum: float,\n    NewCond_DelayedGDDs: float,\n    NewCond_CCxW: float,\n    NewCond_CCadj: float,\n    NewCond_CCxAct: float,\n    NewCond_CC: float,\n    NewCond_PrematSenes: bool,\n    NewCond_SurfaceStorage: float,\n    NewCond_Wstage2: float,\n    NewCond_Epot: float,\n    et0: float,\n    Infl: float,\n    Rain: float,\n    Irr: float,\n    growing_season: bool,\n) -&gt; Tuple[float, \"ndarray\", bool, float, float, float, float, float, float]:\n\n    \"\"\"\n    Function to calculate daily soil evaporation\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=82\" target=\"_blank\"&gt;Reference Manual: evaporation equations&lt;/a&gt; (pg. 73-81)\n\n\n    Arguments:\n\n        ClockStruct_EvapTimeSteps (int): number of evaportation time steps\n\n        ClockStruct_SimOffSeason (bool): simulate off season? (False=no, True=yes)\n\n        ClockStruct_TimeStepCounter (int): time step counter\n\n        prof (SoilProfile): soil profile object\n\n        Soil_EvapZmin (float): minimum evaporation depth (m)\n\n        Soil_EvapZmax (float): maximum evaporation depth (m)\n\n        Soil_REW (float): Readily Evaporable Water \n\n        Soil_Kex (float): Soil evaporation coefficient\n\n        Soil_fwcc (float): \n\n        Soil_fWrelExp (float): \n\n        Soil_fevap (float): \n\n        Crop_CalendarType (int): calendar type \n\n        Crop_Senescence (float):\n\n        IrrMngt_IrrMethod (int): irrigation method\n\n        IrrMngt_WetSurf (float): wet surface area\n\n        FieldMngt_Mulches (bool): mulch present? (0=no, 1=yes)\n\n        FieldMngt_fMulch (float): mulch factor\n\n        FieldMngt_MulchPct (float): mulch percentage\n\n        NewCond_DAP (int): days after planting\n\n        NewCond_Wsurf (float): wet surface area\n\n        NewCond_EvapZ (float): evaporation depth (m)\n\n        NewCond_Stage2 (float): stage 2 evaporation\n\n        NewCond_th (ndarray): soil water content\n\n        NewCond_DelayedCDs: delayed calendar days\n\n        NewCond_GDDcum (float): cumulative growing degree days\n\n        NewCond_DelayedGDDs (float): delayed growing degree days\n\n        NewCond_CCxW (float): \n\n        NewCond_CCadj (float): canopy cover adjusted\n\n        NewCond_CCxAct: max canopy cover actual\n\n        NewCond_CC (float): canopy cover\n\n        NewCond_PrematSenes (bool): prematurity senescence? (0=no, 1=yes)\n\n        NewCond_SurfaceStorage (float): surface storage\n\n        NewCond_Wstage2 (float): stage 2 water content\n\n        NewCond_Epot (float): potential evaporation\n\n        et0 (float): daily reference evapotranspiration\n\n        Infl (float): Infiltration on current day\n\n        Rain (float): daily precipitation mm\n\n        Irr (float): Irrigation applied on current day\n\n        growing_season (bool): is growing season (True or Flase)\n\n\n    Returns:\n\n        NewCond_Epot (float): Potential surface evaporation current day\n\n        NewCond_th (ndarray): updated soil water content\n\n        NewCond_Stage2 (bool): stage 2 soil evaporation\n\n        NewCond_Wstage2 (float): stage 2 soil evaporation \n\n        NewCond_Wsurf (float): updated surface water content\n\n        NewCond_SurfaceStorage (float): updated surface storage\n\n        NewCond_EvapZ (float): updated evaporation layer depth\n\n        EsAct (float): Actual surface evaporation current day\n\n        EsPot (float): Potential surface evaporation current day\n\n    \"\"\"\n\n    # Wevap = WaterEvaporation()\n\n    ## Store initial conditions in new structure that will be updated ##\n    # NewCond = InitCond\n\n    ## Prepare stage 2 evaporation (rew gone) ##\n    # Only do this if it is first day of simulation, or if it is first day of\n    # growing season and not simulating off-season\n    if (ClockStruct_TimeStepCounter == 0) or (\n        (NewCond_DAP == 1) and (ClockStruct_SimOffSeason == False)\n    ):\n        # Reset storage in surface soil layer to zero\n        NewCond_Wsurf = 0\n        # Set evaporation depth to minimum\n        NewCond_EvapZ = Soil_EvapZmin\n        # Trigger stage 2 evaporation\n        NewCond_Stage2 = True\n        # Get relative water content for start of stage 2 evaporation\n        Wevap_Sat, Wevap_Fc, Wevap_Wp, Wevap_Dry, Wevap_Act = evap_layer_water_content(\n            NewCond_th,\n            NewCond_EvapZ,\n            prof,\n        )\n        NewCond_Wstage2 = round(\n            (Wevap_Act - (Wevap_Fc - Soil_REW)) / (Wevap_Sat - (Wevap_Fc - Soil_REW)), 2\n        )\n        if NewCond_Wstage2 &lt; 0:\n            NewCond_Wstage2 = 0\n\n    ## Prepare soil evaporation stage 1 ##\n    # Adjust water in surface evaporation layer for any infiltration\n    if (Rain &gt; 0) or ((Irr &gt; 0) and (IrrMngt_IrrMethod != 4)):\n        # Only prepare stage one when rainfall occurs, or when irrigation is\n        # trigerred (not in net irrigation mode)\n        if Infl &gt; 0:\n            # Update storage in surface evaporation layer for incoming\n            # infiltration\n            NewCond_Wsurf = Infl\n            # Water stored in surface evaporation layer cannot exceed rew\n            if NewCond_Wsurf &gt; Soil_REW:\n                NewCond_Wsurf = Soil_REW\n\n            # Reset variables\n            NewCond_Wstage2 = 0\n            NewCond_EvapZ = Soil_EvapZmin\n            NewCond_Stage2 = False\n\n    ## Calculate potential soil evaporation rate (mm/day) ##\n    if growing_season == True:\n        # Adjust time for any delayed development\n        if Crop_CalendarType == 1:\n            tAdj = NewCond_DAP - NewCond_DelayedCDs\n        elif Crop_CalendarType == 2:\n            tAdj = NewCond_GDDcum - NewCond_DelayedGDDs\n\n        # Calculate maximum potential soil evaporation\n        EsPotMax = Soil_Kex * et0 * (1 - NewCond_CCxW * (Soil_fwcc / 100))\n        # Calculate potential soil evaporation (given current canopy cover\n        # size)\n        EsPot = Soil_Kex * (1 - NewCond_CCadj) * et0\n\n        # Adjust potential soil evaporation for effects of withered canopy\n        if (tAdj &gt; Crop_Senescence) and (NewCond_CCxAct &gt; 0):\n            if NewCond_CC &gt; (NewCond_CCxAct / 2):\n                if NewCond_CC &gt; NewCond_CCxAct:\n                    mult = 0\n                else:\n                    mult = (NewCond_CCxAct - NewCond_CC) / (NewCond_CCxAct / 2)\n\n            else:\n                mult = 1\n\n            EsPot = EsPot * (1 - NewCond_CCxAct * (Soil_fwcc / 100) * mult)\n            CCxActAdj = (\n                (1.72 * NewCond_CCxAct) - (NewCond_CCxAct ** 2) + 0.3 * (NewCond_CCxAct ** 3)\n            )\n            EsPotMin = Soil_Kex * (1 - CCxActAdj) * et0\n            if EsPotMin &lt; 0:\n                EsPotMin = 0\n\n            if EsPot &lt; EsPotMin:\n                EsPot = EsPotMin\n            elif EsPot &gt; EsPotMax:\n                EsPot = EsPotMax\n\n        if NewCond_PrematSenes == True:\n            if EsPot &gt; EsPotMax:\n                EsPot = EsPotMax\n\n    else:\n        # No canopy cover outside of growing season so potential soil\n        # evaporation only depends on reference evapotranspiration\n        EsPot = Soil_Kex * et0\n\n    ## Adjust potential soil evaporation for mulches and/or partial wetting ##\n    # mulches\n    if NewCond_SurfaceStorage &lt; 0.000001:\n        if not FieldMngt_Mulches:\n            # No mulches present\n            EsPotMul = EsPot\n        elif FieldMngt_Mulches:\n            # mulches present\n            EsPotMul = EsPot * (1 - FieldMngt_fMulch * (FieldMngt_MulchPct / 100))\n\n    else:\n        # Surface is flooded - no adjustment of potential soil evaporation for\n        # mulches\n        EsPotMul = EsPot\n\n    # Partial surface wetting by irrigation\n    if (Irr &gt; 0) and (IrrMngt_IrrMethod != 4):\n        # Only apply adjustment if irrigation occurs and not in net irrigation\n        # mode\n        if (Rain &gt; 1) or (NewCond_SurfaceStorage &gt; 0):\n            # No adjustment for partial wetting - assume surface is fully wet\n            EsPotIrr = EsPot\n        else:\n            # Adjust for proprtion of surface area wetted by irrigation\n            EsPotIrr = EsPot * (IrrMngt_WetSurf / 100)\n\n    else:\n        # No adjustment for partial surface wetting\n        EsPotIrr = EsPot\n\n    # Assign minimum value (mulches and partial wetting don't combine)\n    EsPot = min(EsPotIrr, EsPotMul)\n\n    ## Surface evaporation ##\n    # Initialise actual evaporation counter\n    EsAct = 0\n    # Evaporate surface storage\n    if NewCond_SurfaceStorage &gt; 0:\n        if NewCond_SurfaceStorage &gt; EsPot:\n            # All potential soil evaporation can be supplied by surface storage\n            EsAct = EsPot\n            # Update surface storage\n            NewCond_SurfaceStorage = NewCond_SurfaceStorage - EsAct\n        else:\n            # Surface storage is not sufficient to meet all potential soil\n            # evaporation\n            EsAct = NewCond_SurfaceStorage\n            # Update surface storage, evaporation layer depth, stage\n            NewCond_SurfaceStorage = 0\n            NewCond_Wsurf = Soil_REW\n            NewCond_Wstage2 = 0\n            NewCond_EvapZ = Soil_EvapZmin\n            NewCond_Stage2 = False\n\n    ## stage 1 evaporation ##\n    # Determine total water to be extracted\n    ToExtract = EsPot - EsAct\n    # Determine total water to be extracted in stage one (limited by surface\n    # layer water storage)\n    ExtractPotStg1 = min(ToExtract, NewCond_Wsurf)\n    # Extract water\n    if ExtractPotStg1 &gt; 0:\n        # Find soil compartments covered by evaporation layer\n        comp_sto = np.sum(prof.dzsum &lt; Soil_EvapZmin) + 1\n        comp = -1\n        # prof = Soil_Profile\n        while (ExtractPotStg1 &gt; 0) and (comp &lt; comp_sto):\n            # Increment compartment counter\n            comp = comp + 1\n            # Specify layer number\n            # Determine proportion of compartment in evaporation layer\n            if prof.dzsum[comp] &gt; Soil_EvapZmin:\n                factor = 1 - ((prof.dzsum[comp] - Soil_EvapZmin) / prof.dz[comp])\n            else:\n                factor = 1\n\n            # Water storage (mm) at air dry\n            Wdry = 1000 * prof.th_dry[comp] * prof.dz[comp]\n            # Available water (mm)\n            W = 1000 * NewCond_th[comp] * prof.dz[comp]\n            # Water available in compartment for extraction (mm)\n            AvW = (W - Wdry) * factor\n            if AvW &lt; 0:\n                AvW = 0\n\n            if AvW &gt;= ExtractPotStg1:\n                # Update actual evaporation\n                EsAct = EsAct + ExtractPotStg1\n                # Update depth of water in current compartment\n                W = W - ExtractPotStg1\n                # Update total water to be extracted\n                ToExtract = ToExtract - ExtractPotStg1\n                # Update water to be extracted from surface layer (stage 1)\n                ExtractPotStg1 = 0\n            else:\n                # Update actual evaporation\n                EsAct = EsAct + AvW\n                # Update water to be extracted from surface layer (stage 1)\n                ExtractPotStg1 = ExtractPotStg1 - AvW\n                # Update total water to be extracted\n                ToExtract = ToExtract - AvW\n                # Update depth of water in current compartment\n                W = W - AvW\n\n            # Update water content\n            NewCond_th[comp] = W / (1000 * prof.dz[comp])\n\n        # Update surface evaporation layer water balance\n        NewCond_Wsurf = NewCond_Wsurf - EsAct\n        if (NewCond_Wsurf &lt; 0) or (ExtractPotStg1 &gt; 0.0001):\n            NewCond_Wsurf = 0\n\n        # If surface storage completely depleted, prepare stage 2\n        if NewCond_Wsurf &lt; 0.0001:\n            # Get water contents (mm)\n            Wevap_Sat, Wevap_Fc, Wevap_Wp, Wevap_Dry, Wevap_Act = evap_layer_water_content(\n                NewCond_th,\n                NewCond_EvapZ,\n                prof,\n            )\n            # Proportional water storage for start of stage two evaporation\n            NewCond_Wstage2 = round(\n                (Wevap_Act - (Wevap_Fc - Soil_REW)) / (Wevap_Sat - (Wevap_Fc - Soil_REW)), 2\n            )\n            if NewCond_Wstage2 &lt; 0:\n                NewCond_Wstage2 = 0\n\n    ## stage 2 evaporation ##\n    # Extract water\n    if ToExtract &gt; 0:\n        # Start stage 2\n        NewCond_Stage2 = True\n        # Get sub-daily evaporative demand\n        Edt = ToExtract / ClockStruct_EvapTimeSteps\n        # Loop sub-daily steps\n        for jj in range(int(ClockStruct_EvapTimeSteps)):\n            # Get current water storage (mm)\n            Wevap_Sat, Wevap_Fc, Wevap_Wp, Wevap_Dry, Wevap_Act = evap_layer_water_content(\n                NewCond_th,\n                NewCond_EvapZ,\n                prof,\n            )\n            # Get water storage (mm) at start of stage 2 evaporation\n            Wupper = NewCond_Wstage2 * (Wevap_Sat - (Wevap_Fc - Soil_REW)) + (Wevap_Fc - Soil_REW)\n            # Get water storage (mm) when there is no evaporation\n            Wlower = Wevap_Dry\n            # Get relative depletion of evaporation storage in stage 2\n            Wrel = (Wevap_Act - Wlower) / (Wupper - Wlower)\n            # Check if need to expand evaporation layer\n            if Soil_EvapZmax &gt; Soil_EvapZmin:\n                Wcheck = Soil_fWrelExp * (\n                    (Soil_EvapZmax - NewCond_EvapZ) / (Soil_EvapZmax - Soil_EvapZmin)\n                )\n                while (Wrel &lt; Wcheck) and (NewCond_EvapZ &lt; Soil_EvapZmax):\n                    # Expand evaporation layer by 1 mm\n                    NewCond_EvapZ = NewCond_EvapZ + 0.001\n                    # Update water storage (mm) in evaporation layer\n                    Wevap_Sat, Wevap_Fc, Wevap_Wp, Wevap_Dry, Wevap_Act = evap_layer_water_content(\n                        NewCond_th,\n                        NewCond_EvapZ,\n                        prof,\n                    )\n                    Wupper = NewCond_Wstage2 * (Wevap_Sat - (Wevap_Fc - Soil_REW)) + (\n                        Wevap_Fc - Soil_REW\n                    )\n                    Wlower = Wevap_Dry\n                    # Update relative depletion of evaporation storage\n                    Wrel = (Wevap_Act - Wlower) / (Wupper - Wlower)\n                    Wcheck = Soil_fWrelExp * (\n                        (Soil_EvapZmax - NewCond_EvapZ) / (Soil_EvapZmax - Soil_EvapZmin)\n                    )\n\n            # Get stage 2 evaporation reduction coefficient\n            Kr = (np.exp(Soil_fevap * Wrel) - 1) / (np.exp(Soil_fevap) - 1)\n            if Kr &gt; 1:\n                Kr = 1\n\n            # Get water to extract (mm)\n            ToExtractStg2 = Kr * Edt\n\n            # Extract water from compartments\n            comp_sto = np.sum(prof.dzsum &lt; NewCond_EvapZ) + 1\n            comp = -1\n            # prof = Soil_Profile\n            while (ToExtractStg2 &gt; 0) and (comp &lt; comp_sto):\n                # Increment compartment counter\n                comp = comp + 1\n                # Specify layer number\n                # Determine proportion of compartment in evaporation layer\n                if prof.dzsum[comp] &gt; NewCond_EvapZ:\n                    factor = 1 - ((prof.dzsum[comp] - NewCond_EvapZ) / prof.dz[comp])\n                else:\n                    factor = 1\n\n                # Water storage (mm) at air dry\n                Wdry = 1000 * prof.th_dry[comp] * prof.dz[comp]\n                # Available water (mm)\n                W = 1000 * NewCond_th[comp] * prof.dz[comp]\n                # Water available in compartment for extraction (mm)\n                AvW = (W - Wdry) * factor\n                if AvW &gt;= ToExtractStg2:\n                    # Update actual evaporation\n                    EsAct = EsAct + ToExtractStg2\n                    # Update depth of water in current compartment\n                    W = W - ToExtractStg2\n                    # Update total water to be extracted\n                    ToExtract = ToExtract - ToExtractStg2\n                    # Update water to be extracted from surface layer (stage 1)\n                    ToExtractStg2 = 0\n                else:\n                    # Update actual evaporation\n                    EsAct = EsAct + AvW\n                    # Update depth of water in current compartment\n                    W = W - AvW\n                    # Update water to be extracted from surface layer (stage 1)\n                    ToExtractStg2 = ToExtractStg2 - AvW\n                    # Update total water to be extracted\n                    ToExtract = ToExtract - AvW\n\n                # Update water content\n                NewCond_th[comp] = W / (1000 * prof.dz[comp])\n\n    ## Store potential evaporation for irrigation calculations on next day ##\n    NewCond_Epot = EsPot\n\n    return (\n        NewCond_Epot,\n        NewCond_th,\n        NewCond_Stage2,\n        NewCond_Wstage2,\n        NewCond_Wsurf,\n        NewCond_SurfaceStorage,\n        NewCond_EvapZ,\n        EsAct,\n        EsPot,\n    )\n</code></pre>"},{"location":"solution/#aquacrop.solution.temperature_stress","title":"<code>aquacrop.solution.temperature_stress</code>","text":""},{"location":"solution/#aquacrop.solution.temperature_stress.temperature_stress","title":"<code>temperature_stress(Crop, temp_max, temp_min)</code>","text":"<p>Function to get irrigation depth for current day</p> <p>Reference Manual: temperature stress (pg. 14)</p> <p>Arguments:</p> <pre><code>Crop (Crop): Crop object containing Crop paramaters\n\ntemp_max (float): max tempatature on current day (celcius)\n\ntemp_min (float): min tempature on current day (celcius)\n</code></pre> <p>Returns:</p> <pre><code>Kst_PolH (float): heat stress coefficient for current day\n\nKst_PolC (float): cold stress coefficient for current day\n</code></pre> Source code in <code>aquacrop/solution/temperature_stress.py</code> <pre><code>def temperature_stress(\n    Crop: \"Crop\",\n    temp_max: float,\n    temp_min: float,\n    ) -&gt; Tuple[float,float]:\n    # Function to calculate temperature stress coefficients\n    \"\"\"\n    Function to get irrigation depth for current day\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=23\" target=\"_blank\"&gt;Reference Manual: temperature stress&lt;/a&gt; (pg. 14)\n\n\n\n    Arguments:\n\n        Crop (Crop): Crop object containing Crop paramaters\n\n        temp_max (float): max tempatature on current day (celcius)\n\n        temp_min (float): min tempature on current day (celcius)\n\n\n    Returns:\n\n        Kst_PolH (float): heat stress coefficient for current day\n\n        Kst_PolC (float): cold stress coefficient for current day\n\n\n\n\n\n\n\n    \"\"\"\n\n    ## Calculate temperature stress coefficients affecting crop pollination ##\n    # Get parameters for logistic curve\n    KsPol_up = 1\n    KsPol_lo = 0.001\n\n    # Kst = Kst()\n\n    # Calculate effects of heat stress on pollination\n    if Crop.PolHeatStress == 0:\n        # No heat stress effects on pollination\n        Kst_PolH = 1\n    elif Crop.PolHeatStress == 1:\n        # Pollination affected by heat stress\n        if temp_max &lt;= Crop.Tmax_lo:\n            Kst_PolH = 1\n        elif temp_max &gt;= Crop.Tmax_up:\n            Kst_PolH = 0\n        else:\n            Trel = (temp_max - Crop.Tmax_lo) / (Crop.Tmax_up - Crop.Tmax_lo)\n            Kst_PolH = (KsPol_up * KsPol_lo) / (\n                KsPol_lo + (KsPol_up - KsPol_lo) * np.exp(-Crop.fshape_b * (1 - Trel))\n            )\n\n    # Calculate effects of cold stress on pollination\n    if Crop.PolColdStress == 0:\n        # No cold stress effects on pollination\n        Kst_PolC = 1\n    elif Crop.PolColdStress == 1:\n        # Pollination affected by cold stress\n        if temp_min &gt;= Crop.Tmin_up:\n            Kst_PolC = 1\n        elif temp_min &lt;= Crop.Tmin_lo:\n            Kst_PolC = 0\n        else:\n            Trel = (Crop.Tmin_up - temp_min) / (Crop.Tmin_up - Crop.Tmin_lo)\n            Kst_PolC = (KsPol_up * KsPol_lo) / (\n                KsPol_lo + (KsPol_up - KsPol_lo) * np.exp(-Crop.fshape_b * (1 - Trel))\n            )\n\n    return (Kst_PolH,Kst_PolC)\n</code></pre>"},{"location":"solution/#aquacrop.solution.transpiration","title":"<code>aquacrop.solution.transpiration</code>","text":""},{"location":"solution/#aquacrop.solution.transpiration.transpiration","title":"<code>transpiration(Soil_Profile, Soil_nComp, Soil_zTop, Crop, IrrMngt_IrrMethod, IrrMngt_NetIrrSMT, InitCond, et0, CO2, growing_season, gdd)</code>","text":"<p>Function to calculate crop transpiration on current day</p> <p>Reference Manual: transpiration equations (pg. 82-91)</p> <p>Arguments:</p> <pre><code>Soil_Profile (SoilProfile): Soil profile params\n\nSoil_nComp (int): number of soil components\n\nSoil_zTop (float): depth of topsoil\n\nCrop (Crop): Crop params\n\nIrrMngt_IrrMethod (int): irrigation method\n\nIrrMngt_NetIrrSMT (float): net irrigation soil-moisture target\n\nInitCond (InitialCondition): InitCond object\n\net0 (float): reference evapotranspiration\n\nCO2 (CO2): CO2\n\ngdd (float): Growing Degree Days\n\ngrowing_season (bool): is it currently within the growing season (True, Flase)\n</code></pre> <p>Returns:</p> <pre><code>TrAct (float): Actual Transpiration on current day\n\nTrPot_NS (float): Potential Transpiration on current day with no water stress\n\nTrPot0 (float): Potential Transpiration on current day\n\nNewCond (InitialCondition): updated InitCond object\n\nIrrNet (float): Net Irrigation (if required)\n</code></pre> Source code in <code>aquacrop/solution/transpiration.py</code> <pre><code>def transpiration(\n    Soil_Profile: \"SoilProfile\",\n    Soil_nComp: int,\n    Soil_zTop: float,\n    Crop: \"CropStructNT\",\n    IrrMngt_IrrMethod: int,\n    IrrMngt_NetIrrSMT: float,\n    InitCond: \"InitialCondition\",\n    et0: float,\n    CO2: \"CO2\",\n    growing_season: bool,\n    gdd: float,\n) -&gt; Tuple[float,float,float,\"InitialCondition\",float]:\n\n    \"\"\"\n    Function to calculate crop transpiration on current day\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=91\" target=\"_blank\"&gt;Reference Manual: transpiration equations&lt;/a&gt; (pg. 82-91)\n\n\n\n    Arguments:\n\n\n        Soil_Profile (SoilProfile): Soil profile params\n\n        Soil_nComp (int): number of soil components\n\n        Soil_zTop (float): depth of topsoil\n\n        Crop (Crop): Crop params\n\n        IrrMngt_IrrMethod (int): irrigation method \n\n        IrrMngt_NetIrrSMT (float): net irrigation soil-moisture target\n\n        InitCond (InitialCondition): InitCond object\n\n        et0 (float): reference evapotranspiration\n\n        CO2 (CO2): CO2\n\n        gdd (float): Growing Degree Days\n\n        growing_season (bool): is it currently within the growing season (True, Flase)\n\n    Returns:\n\n\n        TrAct (float): Actual Transpiration on current day\n\n        TrPot_NS (float): Potential Transpiration on current day with no water stress\n\n        TrPot0 (float): Potential Transpiration on current day\n\n        NewCond (InitialCondition): updated InitCond object\n\n        IrrNet (float): Net Irrigation (if required)\n\n\n\n\n\n\n\n    \"\"\"\n\n    ## Store initial conditions ##\n    NewCond = InitCond\n\n    InitCond_th = InitCond.th\n\n    prof = Soil_Profile\n\n    ## Calculate transpiration (if in growing season) ##\n    if growing_season == True:\n        ## Calculate potential transpiration ##\n        # 1. No prior water stress\n        # Update ageing days counter\n        DAPadj = NewCond.dap - NewCond.delayed_cds\n        if DAPadj &gt; Crop.MaxCanopyCD:\n            NewCond.age_days_ns = DAPadj - Crop.MaxCanopyCD\n\n        # Update crop coefficient for ageing of canopy\n        if NewCond.age_days_ns &gt; 5:\n            Kcb_NS = Crop.Kcb - ((NewCond.age_days_ns - 5) * (Crop.fage / 100)) * NewCond.ccx_w_ns\n        else:\n            Kcb_NS = Crop.Kcb\n\n        # Update crop coefficient for CO2 concentration\n        CO2CurrentConc = CO2.current_concentration\n        CO2RefConc = CO2.ref_concentration\n        if CO2CurrentConc &gt; CO2RefConc:\n            Kcb_NS = Kcb_NS * (1 - 0.05 * ((CO2CurrentConc - CO2RefConc) / (550 - CO2RefConc)))\n\n        # Determine potential transpiration rate (no water stress)\n        TrPot_NS = Kcb_NS * (NewCond.canopy_cover_adj_ns) * et0\n\n        # Correct potential transpiration for dying green canopy effects\n        if NewCond.canopy_cover_ns &lt; NewCond.ccx_w_ns:\n            if (NewCond.ccx_w_ns &gt; 0.001) and (NewCond.canopy_cover_ns &gt; 0.001):\n                TrPot_NS = TrPot_NS * ((NewCond.canopy_cover_ns / NewCond.ccx_w_ns) ** Crop.a_Tr)\n\n        # 2. Potential prior water stress and/or delayed development\n        # Update ageing days counter\n        DAPadj = NewCond.dap - NewCond.delayed_cds\n        if DAPadj &gt; Crop.MaxCanopyCD:\n            NewCond.age_days = DAPadj - Crop.MaxCanopyCD\n\n        # Update crop coefficient for ageing of canopy\n        if NewCond.age_days &gt; 5:\n            Kcb = Crop.Kcb - ((NewCond.age_days - 5) * (Crop.fage / 100)) * NewCond.ccx_w\n        else:\n            Kcb = Crop.Kcb\n\n        # Update crop coefficient for CO2 concentration\n        if CO2CurrentConc &gt; CO2RefConc:\n            Kcb = Kcb * (1 - 0.05 * ((CO2CurrentConc - CO2RefConc) / (550 - CO2RefConc)))\n\n        # Determine potential transpiration rate\n        TrPot0 = Kcb * (NewCond.canopy_cover_adj) * et0\n        # Correct potential transpiration for dying green canopy effects\n        if NewCond.canopy_cover &lt; NewCond.ccx_w:\n            if (NewCond.ccx_w &gt; 0.001) and (NewCond.canopy_cover &gt; 0.001):\n                TrPot0 = TrPot0 * ((NewCond.canopy_cover / NewCond.ccx_w) ** Crop.a_Tr)\n\n        # 3. Adjust potential transpiration for cold stress effects\n        # Check if cold stress occurs on current day\n        if Crop.TrColdStress == 0:\n            # Cold temperature stress does not affect transpiration\n            KsCold = 1\n        elif Crop.TrColdStress == 1:\n            # Transpiration can be affected by cold temperature stress\n            if gdd &gt;= Crop.GDD_up:\n                # No cold temperature stress\n                KsCold = 1\n            elif gdd &lt;= Crop.GDD_lo:\n                # Transpiration fully inhibited by cold temperature stress\n                KsCold = 0\n            else:\n                # Transpiration partially inhibited by cold temperature stress\n                # Get parameters for logistic curve\n                KsTr_up = 1\n                KsTr_lo = 0.02\n                fshapeb = (-1) * (\n                    np.log(((KsTr_lo * KsTr_up) - 0.98 * KsTr_lo) / (0.98 * (KsTr_up - KsTr_lo)))\n                )\n                # Calculate cold stress level\n                GDDrel = (gdd - Crop.GDD_lo) / (Crop.GDD_up - Crop.GDD_lo)\n                KsCold = (KsTr_up * KsTr_lo) / (\n                    KsTr_lo + (KsTr_up - KsTr_lo) * np.exp(-fshapeb * GDDrel)\n                )\n                KsCold = KsCold - KsTr_lo * (1 - GDDrel)\n\n        # Correct potential transpiration rate (mm/day)\n        TrPot0 = TrPot0 * KsCold\n        TrPot_NS = TrPot_NS * KsCold\n\n        # print(TrPot0,NewCond.dap)\n\n        ## Calculate surface layer transpiration ##\n        if (NewCond.surface_storage &gt; 0) and (NewCond.day_submerged &lt; Crop.LagAer):\n\n            # Update submergence days counter\n            NewCond.day_submerged = NewCond.day_submerged + 1\n            # Update anerobic conditions counter for each compartment\n            for ii in range(int(Soil_nComp)):\n                # Increment aeration days counter for compartment ii\n                NewCond.aer_days_comp[ii] = NewCond.aer_days_comp[ii] + 1\n                if NewCond.aer_days_comp[ii] &gt; Crop.LagAer:\n                    NewCond.aer_days_comp[ii] = Crop.LagAer\n\n            # Reduce actual transpiration that is possible to account for\n            # aeration stress due to extended submergence\n            fSub = 1 - (NewCond.day_submerged / Crop.LagAer)\n            if NewCond.surface_storage &gt; (fSub * TrPot0):\n                # Transpiration occurs from surface storage\n                NewCond.surface_storage = NewCond.surface_storage - (fSub * TrPot0)\n                TrAct0 = fSub * TrPot0\n            else:\n                # No transpiration from surface storage\n                TrAct0 = 0\n\n            if TrAct0 &lt; (fSub * TrPot0):\n                # More water can be extracted from soil profile for transpiration\n                TrPot = (fSub * TrPot0) - TrAct0\n                # print('now')\n\n            else:\n                # No more transpiration possible on current day\n                TrPot = 0\n                # print('here')\n\n        else:\n\n            # No surface transpiration occurs\n            TrPot = TrPot0\n            TrAct0 = 0\n\n        # print(TrPot,NewCond.dap)\n\n        ## Update potential root zone transpiration for water stress ##\n        # Determine root zone and top soil depletion, and root zone water\n        # content\n\n        taw = TAW()\n        water_root_depletion = Dr()\n        thRZ = RootZoneWater()\n        (\n            _,\n            water_root_depletion.Zt,\n            water_root_depletion.Rz,\n            taw.Zt,\n            taw.Rz,\n            thRZ.Act,\n            thRZ.S,\n            thRZ.FC,\n            thRZ.WP,\n            thRZ.Dry,\n            thRZ.Aer,\n        ) = root_zone_water(\n            prof,\n            float(NewCond.z_root),\n            NewCond.th,\n            Soil_zTop,\n            float(Crop.Zmin),\n            Crop.Aer,\n        )\n\n        class_args = {key:value for key, value in thRZ.__dict__.items() if not key.startswith('__') and not callable(key)}\n        #thRZ = thRZNT(**class_args)\n\n        # _,water_root_depletion,taw,thRZ = root_zone_water(Soil_Profile,float(NewCond.z_root),NewCond.th,Soil_zTop,float(Crop.Zmin),Crop.Aer)\n        # Check whether to use root zone or top soil depletions for calculating\n        # water stress\n        if (water_root_depletion.Rz / taw.Rz) &lt;= (water_root_depletion.Zt / taw.Zt):\n            # Root zone is wetter than top soil, so use root zone value\n            water_root_depletion = water_root_depletion.Rz\n            taw = taw.Rz\n        else:\n            # Top soil is wetter than root zone, so use top soil values\n            water_root_depletion = water_root_depletion.Zt\n            taw = taw.Zt\n\n        # Calculate water stress coefficients\n        beta = True\n        water_stress_coef = Ksw()\n        water_stress_coef.exp, water_stress_coef.sto, water_stress_coef.sen, water_stress_coef.pol, water_stress_coef.sto_lin = water_stress(\n            Crop.p_up,\n            Crop.p_lo,\n            Crop.ETadj,\n            Crop.beta,\n            Crop.fshape_w,\n            NewCond.t_early_sen,\n            water_root_depletion,\n            taw,\n            et0,\n            beta,\n        )\n        # water_stress_coef = water_stress(Crop, NewCond, water_root_depletion, taw, et0, beta)\n\n        # Calculate aeration stress coefficients\n        Ksa_Aer, NewCond.aer_days = aeration_stress(NewCond.aer_days, Crop.LagAer, thRZ)\n        # Maximum stress effect\n        Ks = min(water_stress_coef.sto_lin, Ksa_Aer)\n        # Update potential transpiration in root zone\n        if IrrMngt_IrrMethod != 4:\n            # No adjustment to TrPot for water stress when in net irrigation mode\n            TrPot = TrPot * Ks\n\n        ## Determine compartments covered by root zone ##\n        # Compartments covered by the root zone\n        rootdepth = round(max(float(NewCond.z_root), float(Crop.Zmin)), 2)\n        comp_sto = min(np.sum(Soil_Profile.dzsum &lt; rootdepth) + 1, int(Soil_nComp))\n        RootFact = np.zeros(int(Soil_nComp))\n        # Determine fraction of each compartment covered by root zone\n        for ii in range(comp_sto):\n            if Soil_Profile.dzsum[ii] &gt; rootdepth:\n                RootFact[ii] = 1 - ((Soil_Profile.dzsum[ii] - rootdepth) / Soil_Profile.dz[ii])\n            else:\n                RootFact[ii] = 1\n\n        ## Determine maximum sink term for each compartment ##\n        SxComp = np.zeros(int(Soil_nComp))\n        if IrrMngt_IrrMethod == 4:\n            # Net irrigation mode\n            for ii in range(comp_sto):\n                SxComp[ii] = (Crop.SxTop + Crop.SxBot) / 2\n\n        else:\n            # Maximum sink term declines linearly with depth\n            SxCompBot = Crop.SxTop\n            for ii in range(comp_sto):\n                SxCompTop = SxCompBot\n                if Soil_Profile.dzsum[ii] &lt;= rootdepth:\n                    SxCompBot = Crop.SxBot * NewCond.r_cor + (\n                        (Crop.SxTop - Crop.SxBot * NewCond.r_cor)\n                        * ((rootdepth - Soil_Profile.dzsum[ii]) / rootdepth)\n                    )\n                else:\n                    SxCompBot = Crop.SxBot * NewCond.r_cor\n\n                SxComp[ii] = (SxCompTop + SxCompBot) / 2\n\n        # print(TrPot,NewCond.dap)\n        ## Extract water ##\n        ToExtract = TrPot\n        comp = -1\n        TrAct = 0\n        while (ToExtract &gt; 0) and (comp &lt; comp_sto - 1):\n            # Increment compartment\n            comp = comp + 1\n            # Specify layer number\n\n            # Determine taw (m3/m3) for compartment\n            thTAW = prof.th_fc[comp] - prof.th_wp[comp]\n            if Crop.ETadj == 1:\n                # Adjust stomatal stress threshold for et0 on current day\n                p_up_sto = Crop.p_up[1] + (0.04 * (5 - et0)) * (np.log10(10 - 9 * Crop.p_up[1]))\n\n            # Determine critical water content at which stomatal closure will\n            # occur in compartment\n            thCrit = prof.th_fc[comp] - (thTAW * p_up_sto)\n\n            # Check for soil water stress\n            if NewCond.th[comp] &gt;= thCrit:\n                # No water stress effects on transpiration\n                KsComp = 1\n            elif NewCond.th[comp] &gt; prof.th_wp[comp]:\n                # Transpiration from compartment is affected by water stress\n                Wrel = (prof.th_fc[comp] - NewCond.th[comp]) / (prof.th_fc[comp] - prof.th_wp[comp])\n                pRel = (Wrel - Crop.p_up[1]) / (Crop.p_lo[1] - Crop.p_up[1])\n                if pRel &lt;= 0:\n                    KsComp = 1\n                elif pRel &gt;= 1:\n                    KsComp = 0\n                else:\n                    KsComp = 1 - (\n                        (np.exp(pRel * Crop.fshape_w[1]) - 1) / (np.exp(Crop.fshape_w[1]) - 1)\n                    )\n\n                if KsComp &gt; 1:\n                    KsComp = 1\n                elif KsComp &lt; 0:\n                    KsComp = 0\n\n            else:\n                # No transpiration is possible from compartment as water\n                # content does not exceed wilting point\n                KsComp = 0\n\n            # Adjust compartment stress factor for aeration stress\n            if NewCond.day_submerged &gt;= Crop.LagAer:\n                # Full aeration stress - no transpiration possible from\n                # compartment\n                AerComp = 0\n            elif NewCond.th[comp] &gt; (prof.th_s[comp] - (Crop.Aer / 100)):\n                # Increment aeration stress days counter\n                NewCond.aer_days_comp[comp] = NewCond.aer_days_comp[comp] + 1\n                if NewCond.aer_days_comp[comp] &gt;= Crop.LagAer:\n                    NewCond.aer_days_comp[comp] = Crop.LagAer\n                    fAer = 0\n                else:\n                    fAer = 1\n\n                # Calculate aeration stress factor\n                AerComp = (prof.th_s[comp] - NewCond.th[comp]) / (\n                    prof.th_s[comp] - (prof.th_s[comp] - (Crop.Aer / 100))\n                )\n                if AerComp &lt; 0:\n                    AerComp = 0\n\n                AerComp = (fAer + (NewCond.aer_days_comp[comp] - 1) * AerComp) / (\n                    fAer + NewCond.aer_days_comp[comp] - 1\n                )\n            else:\n                # No aeration stress as number of submerged days does not\n                # exceed threshold for initiation of aeration stress\n                AerComp = 1\n                NewCond.aer_days_comp[comp] = 0\n\n            # Extract water\n            ThToExtract = (ToExtract / 1000) / Soil_Profile.dz[comp]\n            if IrrMngt_IrrMethod == 4:\n                # Don't reduce compartment sink for stomatal water stress if in\n                # net irrigation mode. Stress only occurs due to deficient\n                # aeration conditions\n                Sink = AerComp * SxComp[comp] * RootFact[comp]\n            else:\n                # Reduce compartment sink for greatest of stomatal and aeration\n                # stress\n                if KsComp == AerComp:\n                    Sink = KsComp * SxComp[comp] * RootFact[comp]\n                else:\n                    Sink = min(KsComp, AerComp) * SxComp[comp] * RootFact[comp]\n\n            # Limit extraction to demand\n            if ThToExtract &lt; Sink:\n                Sink = ThToExtract\n\n            # Limit extraction to avoid compartment water content dropping\n            # below air dry\n            if (InitCond_th[comp] - Sink) &lt; prof.th_dry[comp]:\n                Sink = InitCond_th[comp] - prof.th_dry[comp]\n                if Sink &lt; 0:\n                    Sink = 0\n\n            # Update water content in compartment\n            NewCond.th[comp] = InitCond_th[comp] - Sink\n            # Update amount of water to extract\n            ToExtract = ToExtract - (Sink * 1000 * prof.dz[comp])\n            # Update actual transpiration\n            TrAct = TrAct + (Sink * 1000 * prof.dz[comp])\n\n        ## Add net irrigation water requirement (if this mode is specified) ##\n        if (IrrMngt_IrrMethod == 4) and (TrPot &gt; 0):\n            # Initialise net irrigation counter\n            IrrNet = 0\n            # Get root zone water content\n\n            taw = TAW()\n            water_root_depletion = Dr()\n            thRZ = RootZoneWater()\n            (\n                _,\n                water_root_depletion.Zt,\n                water_root_depletion.Rz,\n                taw.Zt,\n                taw.Rz,\n                thRZ.Act,\n                thRZ.S,\n                thRZ.FC,\n                thRZ.WP,\n                thRZ.Dry,\n                thRZ.Aer,\n            ) = root_zone_water(\n                prof,\n                float(NewCond.z_root),\n                NewCond.th,\n                Soil_zTop,\n                float(Crop.Zmin),\n                Crop.Aer,\n            )\n\n            # _,_Dr,_TAW,thRZ = root_zone_water(Soil_Profile,float(NewCond.z_root),NewCond.th,Soil_zTop,float(Crop.Zmin),Crop.Aer)\n            NewCond.depletion = water_root_depletion.Rz\n            NewCond.taw = taw.Rz\n            # Determine critical water content for net irrigation\n            thCrit = thRZ.WP + ((IrrMngt_NetIrrSMT / 100) * (thRZ.FC - thRZ.WP))\n            # Check if root zone water content is below net irrigation trigger\n            if thRZ.Act &lt; thCrit:\n                # Initialise layer counter\n                prelayer = 0\n                for ii in range(comp_sto):\n                    # Get soil layer\n                    layeri = Soil_Profile.Layer[ii]\n                    if layeri &gt; prelayer:\n                        # If in new layer, update critical water content for\n                        # net irrigation\n                        thCrit = prof.th_wp[ii] + (\n                            (IrrMngt_NetIrrSMT / 100) * (prof.th_fc[ii] - prof.th_wp[ii])\n                        )\n                        # Update layer counter\n                        prelayer = layeri\n\n                    # Determine necessary change in water content in\n                    # compartments to reach critical water content\n                    dWC = RootFact[ii] * (thCrit - NewCond.th[ii]) * 1000 * prof.dz[ii]\n                    # Update water content\n                    NewCond.th[ii] = NewCond.th[ii] + (dWC / (1000 * prof.dz[ii]))\n                    # Update net irrigation counter\n                    IrrNet = IrrNet + dWC\n\n            # Update net irrigation counter for the growing season\n            NewCond.irr_net_cum = NewCond.irr_net_cum + IrrNet\n        elif (IrrMngt_IrrMethod == 4) and (TrPot &lt;= 0):\n            # No net irrigation as potential transpiration is zero\n            IrrNet = 0\n        else:\n            # No net irrigation as not in net irrigation mode\n            IrrNet = 0\n            NewCond.irr_net_cum = 0\n\n        ## Add any surface transpiration to root zone total ##\n        TrAct = TrAct + TrAct0\n\n        ## Feedback with canopy cover development ##\n        # If actual transpiration is zero then no canopy cover growth can occur\n        if ((NewCond.canopy_cover - NewCond.cc_prev) &gt; 0.005) and (TrAct == 0):\n            NewCond.canopy_cover = NewCond.cc_prev\n\n        ## Update transpiration ratio ##\n        if TrPot0 &gt; 0:\n            if TrAct &lt; TrPot0:\n                NewCond.tr_ratio = TrAct / TrPot0\n            else:\n                NewCond.tr_ratio = 1\n\n        else:\n            NewCond.tr_ratio = 1\n\n        if NewCond.tr_ratio &lt; 0:\n            NewCond.tr_ratio = 0\n        elif NewCond.tr_ratio &gt; 1:\n            NewCond.tr_ratio = 1\n\n    else:\n        # No transpiration if not in growing season\n        TrAct = 0\n        TrPot0 = 0\n        TrPot_NS = 0\n        # No irrigation if not in growing season\n        IrrNet = 0\n        NewCond.irr_net_cum = 0\n\n    ## Store potential transpiration for irrigation calculations on next day ##\n    NewCond.t_pot = TrPot0\n\n    return TrAct, TrPot_NS, TrPot0, NewCond, IrrNet\n</code></pre>"},{"location":"solution/#aquacrop.solution.update_CCx_CDC","title":"<code>aquacrop.solution.update_CCx_CDC</code>","text":""},{"location":"solution/#aquacrop.solution.update_CCx_CDC.update_CCx_CDC","title":"<code>update_CCx_CDC(cc_prev, CDC, CCx, dt)</code>","text":"<p>Function to update CCx and CDC parameter valyes for rewatering in late season of an early declining canopy</p> <p>Reference Manual: canopy_cover stress response (pg. 27-33)</p> <p>Arguments:</p> <pre><code>cc_prev (float): Canopy Cover at previous timestep.\n\nCDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\nCCx (float): Maximum canopy cover (fraction of soil cover)\n\ndt (float): Time delta of canopy growth (1 calander day or ... gdd)\n</code></pre> <p>Returns:</p> <pre><code>CCxAdj (float): updated CCxAdj\n\nCDCadj (float): updated CDCadj\n</code></pre> Source code in <code>aquacrop/solution/update_CCx_CDC.py</code> <pre><code>def update_CCx_CDC(\n    cc_prev: float,\n    CDC: float,\n    CCx: float,\n    dt: float,\n    ) -&gt; Tuple[float,float]:\n    \"\"\"\n    Function to update CCx and CDC parameter valyes for rewatering in late season of an early declining canopy\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=36\" target=\"_blank\"&gt;Reference Manual: canopy_cover stress response&lt;/a&gt; (pg. 27-33)\n\n\n    Arguments:\n\n\n        cc_prev (float): Canopy Cover at previous timestep.\n\n        CDC (float): Canopy decline coefficient (fraction per gdd/calendar day)\n\n        CCx (float): Maximum canopy cover (fraction of soil cover)\n\n        dt (float): Time delta of canopy growth (1 calander day or ... gdd)\n\n\n    Returns:\n\n        CCxAdj (float): updated CCxAdj\n\n        CDCadj (float): updated CDCadj\n\n\n\n\n\n    \"\"\"\n\n    ## Get adjusted CCx ##\n    CCXadj = cc_prev / (1 - 0.05 * (np.exp(dt * ((CDC * 3.33) / (CCx + 2.29))) - 1))\n\n    ## Get adjusted CDC ##\n    CDCadj = CDC * ((CCXadj + 2.29) / (CCx + 2.29))\n\n    return CCXadj, CDCadj\n</code></pre>"},{"location":"solution/#aquacrop.solution.water_stress","title":"<code>aquacrop.solution.water_stress</code>","text":""},{"location":"solution/#aquacrop.solution.water_stress.water_stress","title":"<code>water_stress(Crop_p_up, Crop_p_lo, Crop_ETadj, Crop_beta, Crop_fshape_w, InitCond_tEarlySen, Dr, taw, et0, beta)</code>","text":"<p>Function to calculate water stress coefficients</p> <p>Reference Manual: water stress equations (pg. 9-13)</p> <p>Arguments:</p> <pre><code>Crop_p_up (ndarray): water stress thresholds for start of water stress\n\nCrop_p_lo (ndarray): water stress thresholds for maximum water stress\n\nCrop_ETadj (float):\n\nCrop_beta (float):\n\nCrop_fshape_w (ndarray): shape factors for water stress\n\nInitCond_tEarlySen (float): days in early senesence\n\nDr (Dr): rootzone depletion\n\ntaw (TAW): root zone total available water\n\net0 (float): Reference Evapotranspiration\n\nbeta (float): Adjust senescence threshold if early sensescence is triggered\n</code></pre> <p>Returns:</p> <pre><code>Ksw (Ksw): Ksw object containint water stress coefficients\n</code></pre> Source code in <code>aquacrop/solution/water_stress.py</code> <pre><code>def water_stress(\n    Crop_p_up: \"ndarray\",\n    Crop_p_lo: \"ndarray\",\n    Crop_ETadj: float,\n    Crop_beta: float,\n    Crop_fshape_w: \"ndarray\",\n    InitCond_tEarlySen: float,\n    Dr: float,\n    taw: float,\n    et0: float,\n    beta: float,\n) -&gt; Tuple[float, float, float, float, float]:\n    \"\"\"\n    Function to calculate water stress coefficients\n\n    &lt;a href=\"https://www.fao.org/3/BR248E/br248e.pdf#page=18\" target=\"_blank\"&gt;Reference Manual: water stress equations&lt;/a&gt; (pg. 9-13)\n\n\n    Arguments:\n\n\n        Crop_p_up (ndarray): water stress thresholds for start of water stress\n\n        Crop_p_lo (ndarray): water stress thresholds for maximum water stress\n\n        Crop_ETadj (float): \n\n        Crop_beta (float): \n\n        Crop_fshape_w (ndarray): shape factors for water stress\n\n        InitCond_tEarlySen (float): days in early senesence\n\n        Dr (Dr): rootzone depletion\n\n        taw (TAW): root zone total available water\n\n        et0 (float): Reference Evapotranspiration\n\n        beta (float): Adjust senescence threshold if early sensescence is triggered\n\n\n    Returns:\n\n        Ksw (Ksw): Ksw object containint water stress coefficients\n\n\n    \"\"\"\n\n    ## Calculate relative root zone water depletion for each stress type ##\n    # Number of stress variables\n    nstress = len(Crop_p_up)\n\n    # Store stress thresholds\n    p_up = np.ones(nstress) * Crop_p_up\n    p_lo = np.ones(nstress) * Crop_p_lo\n    if Crop_ETadj == 1:\n        # Adjust stress thresholds for et0 on currentbeta day (don't do this for\n        # pollination water stress coefficient)\n\n        for ii in range(3):\n            p_up[ii] = p_up[ii] + (0.04 * (5 - et0)) * (np.log10(10 - 9 * p_up[ii]))\n            p_lo[ii] = p_lo[ii] + (0.04 * (5 - et0)) * (np.log10(10 - 9 * p_lo[ii]))\n\n    # Adjust senescence threshold if early sensescence is triggered\n    if (beta == True) and (InitCond_tEarlySen &gt; 0):\n        p_up[2] = p_up[2] * (1 - Crop_beta / 100)\n\n    # Limit values\n    p_up = np.maximum(p_up, np.zeros(4))\n    p_lo = np.maximum(p_lo, np.zeros(4))\n    p_up = np.minimum(p_up, np.ones(4))\n    p_lo = np.minimum(p_lo, np.ones(4))\n\n    # Calculate relative depletion\n    Drel = np.zeros(nstress)\n    for ii in range(nstress):\n        if Dr &lt;= (p_up[ii] * taw):\n            # No water stress\n            Drel[ii] = 0\n        elif (Dr &gt; (p_up[ii] * taw)) and (Dr &lt; (p_lo[ii] * taw)):\n            # Partial water stress\n            Drel[ii] = 1 - ((p_lo[ii] - (Dr / taw)) / (p_lo[ii] - p_up[ii]))\n        elif Dr &gt;= (p_lo[ii] * taw):\n            # Full water stress\n            Drel[ii] = 1\n\n    ## Calculate root zone water stress coefficients ##\n    Ks = np.ones(3)\n    for ii in range(3):\n        Ks[ii] = 1 - ((np.exp(Drel[ii] * Crop_fshape_w[ii]) - 1) / (np.exp(Crop_fshape_w[ii]) - 1))\n\n    # Ksw = Ksw()\n\n    # Water stress coefficient for leaf expansion\n    Ksw_Exp = Ks[0]\n    # Water stress coefficient for stomatal closure\n    Ksw_Sto = Ks[1]\n    # Water stress coefficient for senescence\n    Ksw_Sen = Ks[2]\n    # Water stress coefficient for pollination failure\n    Ksw_Pol = 1 - Drel[3]\n    # Mean water stress coefficient for stomatal closure\n    Ksw_StoLin = 1 - Drel[1]\n\n    return Ksw_Exp, Ksw_Sto, Ksw_Sen, Ksw_Pol, Ksw_StoLin\n</code></pre>"},{"location":"timestep/","title":"timestep","text":""},{"location":"timestep/#aquacrop.timestep","title":"<code>aquacrop.timestep</code>","text":""},{"location":"timestep/#aquacrop.timestep.check_if_model_is_finished","title":"<code>aquacrop.timestep.check_if_model_is_finished</code>","text":""},{"location":"timestep/#aquacrop.timestep.check_if_model_is_finished.check_model_is_finished","title":"<code>check_model_is_finished(step_end_time, simulation_end_date, model_is_finished, season_counter, n_seasons, harvest_flag)</code>","text":"<p>Function to check and declare model termination</p> <p>Arguments:</p> <pre><code>step_end_time (str):  date of next step\n\nsimulation_end_date (str):  date of end of simulation\n\nmodel_is_finished (bool):  is model finished\n\nseason_counter (int):  tracking the number of seasons simulated\n\nn_seasons (int):  total number of seasons being simulated\n\nharvest_flag (bool):  Has crop been harvested\n</code></pre> <p>Returns:</p> <pre><code>model_is_finished (bool): is simulation finished\n</code></pre> Source code in <code>aquacrop/timestep/check_if_model_is_finished.py</code> <pre><code>def check_model_is_finished(\n    step_end_time: str,\n    simulation_end_date: str,\n    model_is_finished: bool,\n    season_counter: int,\n    n_seasons: int,\n    harvest_flag: bool,\n) -&gt; bool:\n    \"\"\"\n    Function to check and declare model termination\n\n\n    Arguments:\n\n        step_end_time (str):  date of next step\n\n        simulation_end_date (str):  date of end of simulation\n\n        model_is_finished (bool):  is model finished\n\n        season_counter (int):  tracking the number of seasons simulated\n\n        n_seasons (int):  total number of seasons being simulated\n\n        harvest_flag (bool):  Has crop been harvested\n\n    Returns:\n\n        model_is_finished (bool): is simulation finished\n\n\n    \"\"\"\n\n    # Check if current time-step is the last\n    current_time = step_end_time\n    if current_time &lt; simulation_end_date:\n        model_is_finished = False\n    elif current_time &gt;= simulation_end_date:\n        model_is_finished = True\n\n    # Check if at the end of last growing season ##\n    # Allow model to exit early if crop has reached maturity or died, and in\n    # the last simulated growing season\n    if (harvest_flag is True) and (season_counter == n_seasons - 1):\n        model_is_finished = True\n\n    return model_is_finished\n</code></pre>"},{"location":"timestep/#aquacrop.timestep.outputs_when_model_is_finished","title":"<code>aquacrop.timestep.outputs_when_model_is_finished</code>","text":""},{"location":"timestep/#aquacrop.timestep.outputs_when_model_is_finished.outputs_when_model_is_finished","title":"<code>outputs_when_model_is_finished(model_is_finished, flux_output, water_output, growth_outputs, steps_are_finished)</code>","text":"<p>Function that turns numpy array outputs into pandas dataframes</p> <p>Arguments:</p> <pre><code>model_is_finished (bool):  is model finished\n\nflux_output (numpy.array): water flux_output\n\nwater_output (numpy.array):  water storage in each compartment\n\ngrowth_outputs (numpy.array):  crop growth variables\n\nn_seasons (int):  total number of seasons being simulated\n\nsteps_are_finished (bool):  have the simulated num_steps finished\n</code></pre> <p>Returns:</p> <pre><code>flux_output (pandas.DataFrame): water flux_output\n\nwater_output (pandas.DataFrame):  water storage in each compartment\n\ngrowth_outputs (pandas.DataFrame):  crop growth variables\n</code></pre> Source code in <code>aquacrop/timestep/outputs_when_model_is_finished.py</code> <pre><code>def outputs_when_model_is_finished(\n    model_is_finished: bool,\n    flux_output: \"ndarray\",\n    water_output: \"ndarray\",\n    growth_outputs: \"ndarray\",\n    steps_are_finished: bool,\n):\n    \"\"\"\n    Function that turns numpy array outputs into pandas dataframes\n\n    Arguments:\n\n        model_is_finished (bool):  is model finished\n\n        flux_output (numpy.array): water flux_output\n\n        water_output (numpy.array):  water storage in each compartment\n\n        growth_outputs (numpy.array):  crop growth variables\n\n        n_seasons (int):  total number of seasons being simulated\n\n        steps_are_finished (bool):  have the simulated num_steps finished\n\n    Returns:\n\n        flux_output (pandas.DataFrame): water flux_output\n\n        water_output (pandas.DataFrame):  water storage in each compartment\n\n        growth_outputs (pandas.DataFrame):  crop growth variables\n\n\n    \"\"\"\n    if model_is_finished is True or steps_are_finished is True:\n        # ClockStruct.step_start_time = ClockStruct.step_end_time\n        # ClockStruct.step_end_time = ClockStruct.step_end_time + np.timedelta64(1, \"D\")\n        flux_output_df = pd.DataFrame(\n            flux_output,\n            columns=[\n                \"time_step_counter\",\n                \"season_counter\",\n                \"dap\",\n                \"Wr\",\n                \"z_gw\",\n                \"surface_storage\",\n                \"IrrDay\",\n                \"Infl\",\n                \"Runoff\",\n                \"DeepPerc\",\n                \"CR\",\n                \"GwIn\",\n                \"Es\",\n                \"EsPot\",\n                \"Tr\",\n                \"TrPot\",\n            ],\n        )\n\n        water_output_df = pd.DataFrame(\n            water_output,\n            columns=[\"time_step_counter\", \"growing_season\", \"dap\"]\n            + [\"th\" + str(i) for i in range(1, water_output.shape[1] - 2)],\n        )\n\n        growth_outputs_df = pd.DataFrame(\n            growth_outputs,\n            columns=[\n                \"time_step_counter\",\n                \"season_counter\",\n                \"dap\",\n                \"gdd\",\n                \"gdd_cum\",\n                \"z_root\",\n                \"canopy_cover\",\n                \"canopy_cover_ns\",\n                \"biomass\",\n                \"biomass_ns\",\n                \"harvest_index\",\n                \"harvest_index_adj\",\n                \"DryYield\",\n                \"FreshYield\",\n                \"YieldPot\",\n            ],\n        )\n\n        return flux_output_df, water_output_df, growth_outputs_df\n\n    return False\n</code></pre>"},{"location":"timestep/#aquacrop.timestep.reset_initial_conditions","title":"<code>aquacrop.timestep.reset_initial_conditions</code>","text":""},{"location":"timestep/#aquacrop.timestep.reset_initial_conditions.reset_initial_conditions","title":"<code>reset_initial_conditions(ClockStruct, InitCond, ParamStruct, weather, crop)</code>","text":"<p>Function to reset initial model conditions for start of growing season (when running model over multiple seasons)</p> <p>Arguments:</p> <pre><code>ClockStruct (ClockStruct):  model time paramaters\n\nInitCond (InitialCondition):  containing current model paramaters\n\nParamStruct (ParamStruct):  containing current model paramaters\n\nweather (numpy.ndarray):  weather data for simulation period\n</code></pre> <p>Returns:</p> <pre><code>InitCond (InitialCondition):  containing reset simulation variables and counters\n\nParamStruct (ParamStruct):  contains all model params\n</code></pre> Source code in <code>aquacrop/timestep/reset_initial_conditions.py</code> <pre><code>def reset_initial_conditions(\n    ClockStruct: \"ClockStruct\",\n    InitCond: \"InitialCondition\",\n    ParamStruct: \"ParamStruct\",\n    weather: \"ndarray\",\n    crop: \"Crop\") -&gt; Tuple[\"InitialCondition\", \"ParamStruct\"]:\n\n    \"\"\"\n    Function to reset initial model conditions for start of growing\n    season (when running model over multiple seasons)\n\n    Arguments:\n\n        ClockStruct (ClockStruct):  model time paramaters\n\n        InitCond (InitialCondition):  containing current model paramaters\n\n        ParamStruct (ParamStruct):  containing current model paramaters\n\n        weather (numpy.ndarray):  weather data for simulation period\n\n\n    Returns:\n\n        InitCond (InitialCondition):  containing reset simulation variables and counters\n\n        ParamStruct (ParamStruct):  contains all model params\n\n\n\n    \"\"\"\n\n    # Extract crop type\n    # TODO: This is necessary?\n    CropType = ParamStruct.CropChoices[ClockStruct.season_counter]\n\n    # Extract structures for updating\n    Soil = ParamStruct.Soil\n    crop = ParamStruct.Seasonal_Crop_List[ClockStruct.season_counter]\n    FieldMngt = ParamStruct.FieldMngt\n\n    # Reset counters\n    InitCond.age_days = 0\n    InitCond.age_days_ns = 0\n    InitCond.aer_days = 0\n    InitCond.irr_cum = 0\n    InitCond.delayed_gdds = 0\n    InitCond.delayed_cds = 0\n    InitCond.pct_lag_phase = 0\n    InitCond.t_early_sen = 0\n    InitCond.gdd_cum = 0\n    InitCond.day_submerged = 0\n    InitCond.irr_net_cum = 0\n    InitCond.dap = 0\n\n    InitCond.aer_days_comp = np.zeros(int(Soil.nComp))\n\n    # Reset states\n    # States\n    InitCond.pre_adj = False\n    InitCond.crop_mature = False\n    InitCond.crop_dead = False\n    InitCond.germination = False\n    InitCond.premat_senes = False\n    InitCond.harvest_flag = False\n\n    # Harvest index\n    # harvest_index\n    InitCond.stage = 1\n    InitCond.f_pre = 1\n    InitCond.f_post = 1\n    InitCond.fpost_dwn = 1\n    InitCond.fpost_upp = 1\n\n    InitCond.h1_cor_asum = 0\n    InitCond.h1_cor_bsum = 0\n    InitCond.f_pol = 0\n    InitCond.s_cor1 = 0\n    InitCond.s_cor2 = 0\n\n    # Growth stage\n    InitCond.growth_stage = 0\n\n    # Transpiration\n    InitCond.tr_ratio = 1\n\n    # crop growth\n    InitCond.r_cor = 1\n\n    InitCond.canopy_cover = 0\n    InitCond.canopy_cover_adj = 0\n    InitCond.canopy_cover_ns = 0\n    InitCond.canopy_cover_adj_ns = 0\n    InitCond.biomass = 0\n    InitCond.biomass_ns = 0\n    InitCond.harvest_index = 0\n    InitCond.harvest_index_adj = 0\n    InitCond.ccx_act = 0\n    InitCond.ccx_act_ns = 0\n    InitCond.ccx_w = 0\n    InitCond.ccx_w_ns = 0\n    InitCond.ccx_early_sen = 0\n    InitCond.cc_prev = 0\n    InitCond.protected_seed = 0\n    InitCond.sumET0EarlySen = 0\n    InitCond.HIfinal = crop.HI0\n    InitCond.DryYield = 0\n    InitCond.FreshYield = 0\n\n    # Update CO2 concentration ##\n    # Get CO2 concentration\n\n    # if user specified constant concentration\n    if  ParamStruct.CO2.constant_conc is True:\n        if ParamStruct.CO2.current_concentration &gt; 0.:\n            CO2conc = ParamStruct.CO2.current_concentration\n        else:\n            CO2conc = ParamStruct.CO2.co2_data_processed.iloc[0]\n    else:\n        Yri = pd.DatetimeIndex([ClockStruct.step_start_time]).year[0]\n        CO2conc = ParamStruct.CO2.co2_data_processed.loc[Yri]\n\n    ParamStruct.CO2.current_concentration = CO2conc\n\n    # Get CO2 weighting factor for first year\n    CO2conc = ParamStruct.CO2.current_concentration\n    CO2ref = ParamStruct.CO2.ref_concentration\n\n    if CO2conc &lt;= CO2ref:\n        fw = 0\n    else:\n        if CO2conc &gt;= 550:\n            fw = 1\n        else:\n            fw = 1 - ((550 - CO2conc) / (550 - CO2ref))\n\n    # Determine initial adjustment\n    if CO2conc &lt;= 550:\n        # Set weighting factor for CO2\n        if CO2conc &lt;= CO2ref:\n            fw = 0\n        elif CO2conc &gt;= 550:\n            fw = 1\n        else:\n            fw = 1 - ((550 - CO2conc) / (550 - CO2ref))\n        # Set fCO2old within the 'if CO2conc &lt;= 550' block:\n        fCO2old = (CO2conc / CO2ref) / (\n            1\n            + (CO2conc - CO2ref)\n            * (\n                (1 - fw) * crop.bsted\n                + fw * ((crop.bsted * crop.fsink) + (crop.bface * (1 - crop.fsink)))\n            )\n        )\n    # New adjusted correction coefficient for CO2 (version 7 of AquaCrop)\n    if (CO2conc &gt; CO2ref):\n        # Calculate shape factor\n        fshape = -4.61824 - 3.43831*crop.fsink - 5.32587*crop.fsink*crop.fsink\n        # Determine adjustment for CO2\n        if (CO2conc &gt;= 2000):\n            fCO2new = 1.58  # Maximum CO2 adjustment \n        else:\n            CO2rel = (CO2conc-CO2ref)/(2000-CO2ref)\n            fCO2new = 1 + 0.58 * ((np.exp(CO2rel*fshape) - 1)/(np.exp(fshape) - 1))\n\n\n    # Select adjusted coefficient for CO2\n    if (CO2conc &lt;= CO2ref):\n        fCO2 = fCO2old\n    else:\n        fCO2 = fCO2new\n        if ((CO2conc &lt;= 550) and (fCO2old &lt; fCO2new)): \n            fCO2 = fCO2old\n\n\n    # Consider crop type\n    if crop.WP &gt;= 40:\n        # No correction for C4 crops\n        ftype = 0\n    elif crop.WP &lt;= 20:\n        # Full correction for C3 crops\n        ftype = 1\n    else:\n        ftype = (40 - crop.WP) / (40 - 20)\n\n    # Total adjustment\n    crop.fCO2 = 1 + ftype * (fCO2 - 1)\n\n    # Reset soil water conditions (if not running off-season)\n    if ClockStruct.sim_off_season is False:\n        # Reset water content to starting conditions\n        InitCond.th = InitCond.thini\n        # Reset surface storage\n        if (FieldMngt.bunds) and (FieldMngt.z_bund &gt; 0.001):\n            # Get initial storage between surface bunds\n            InitCond.surface_storage = min(FieldMngt.bund_water, FieldMngt.z_bund)\n        else:\n            # No surface bunds\n            InitCond.surface_storage = 0\n\n    # Update crop parameters (if in gdd mode)\n    if crop.CalendarType == 2:\n        # Extract weather data for upcoming growing season\n        weather_df = weather[\n            weather[:, 4] &gt;= ClockStruct.planting_dates[ClockStruct.season_counter]\n        ]\n\n        temp_min = weather_df[:, 0]\n        temp_max = weather_df[:, 1]\n\n        # Calculate gdd's\n        if crop.GDDmethod == 1:\n            Tmean = (temp_max + temp_min) / 2\n            Tmean[Tmean &gt; crop.Tupp] = crop.Tupp\n            Tmean[Tmean &lt; crop.Tbase] = crop.Tbase\n            gdd = Tmean - crop.Tbase\n        elif crop.GDDmethod == 2:\n            temp_max[temp_max &gt; crop.Tupp] = crop.Tupp\n            temp_max[temp_max &lt; crop.Tbase] = crop.Tbase\n            temp_min[temp_min &gt; crop.Tupp] = crop.Tupp\n            temp_min[temp_min &lt; crop.Tbase] = crop.Tbase\n            Tmean = (temp_max + temp_min) / 2\n            gdd = Tmean - crop.Tbase\n        elif crop.GDDmethod == 3:\n            temp_max[temp_max &gt; crop.Tupp] = crop.Tupp\n            temp_max[temp_max &lt; crop.Tbase] = crop.Tbase\n            temp_min[temp_min &gt; crop.Tupp] = crop.Tupp\n            Tmean = (temp_max + temp_min) / 2\n            Tmean[Tmean &lt; crop.Tbase] = crop.Tbase\n            gdd = Tmean - crop.Tbase\n\n        gdd_cum = np.cumsum(gdd)\n\n        assert (\n            gdd_cum[-1] &gt; crop.Maturity\n        ), f\"not enough growing degree days in simulation ({gdd_cum[-1]}) to reach maturity ({crop.Maturity})\"\n\n        crop.MaturityCD = np.argmax((gdd_cum &gt; crop.Maturity)) + 1\n\n        assert crop.MaturityCD &lt; 365, \"crop will take longer than 1 year to mature\"\n\n        # 1. gdd's from sowing to maximum canopy cover\n        crop.MaxCanopyCD = (gdd_cum &gt; crop.MaxCanopy).argmax() + 1\n        # 2. gdd's from sowing to end of vegetative growth\n        crop.CanopyDevEndCD = (gdd_cum &gt; crop.CanopyDevEnd).argmax() + 1\n        # 3. Calendar days from sowing to start of yield_ formation\n        crop.HIstartCD = (gdd_cum &gt; crop.HIstart).argmax() + 1\n        # 4. Calendar days from sowing to end of yield_ formation\n        crop.HIendCD = (gdd_cum &gt; crop.HIend).argmax() + 1\n        # 5. Duration of yield_ formation in calendar days\n        crop.YldFormCD = crop.HIendCD - crop.HIstartCD\n        if crop.CropType == 3:\n            # 1. Calendar days from sowing to end of flowering\n            FloweringEnd = (gdd_cum &gt; crop.FloweringEnd).argmax() + 1\n            # 2. Duration of flowering in calendar days\n            crop.FloweringCD = FloweringEnd - crop.HIstartCD\n        else:\n            crop.FloweringCD = ModelConstants.NO_VALUE\n\n        # Update harvest index growth coefficient\n        crop.HIGC = calculate_HIGC(\n            crop.YldFormCD,\n            crop.HI0,\n            crop.HIini,\n        )\n\n        # Update day to switch to linear harvest_index build-up\n        if crop.CropType == 3:\n            # Determine linear switch point and HIGC rate for fruit/grain crops\n            crop.tLinSwitch, crop.dHILinear = calculate_HI_linear(\n                crop.YldFormCD, crop.HIini, crop.HI0, crop.HIGC\n            )\n\n        else:\n            # No linear switch for leafy vegetable or root/tiber crops\n            crop.tLinSwitch = 0\n            crop.dHILinear = 0.0\n\n    # Update global variables\n    ParamStruct.Seasonal_Crop_List[ClockStruct.season_counter] = crop\n\n    return InitCond, ParamStruct\n</code></pre>"},{"location":"timestep/#aquacrop.timestep.run_single_timestep","title":"<code>aquacrop.timestep.run_single_timestep</code>","text":""},{"location":"timestep/#aquacrop.timestep.run_single_timestep.solution_single_time_step","title":"<code>solution_single_time_step(init_cond, param_struct, clock_struct, weather_step, outputs)</code>","text":"<p>Function to perform AquaCrop solution for a single time step</p> <p>Arguments:</p> <pre><code>init_cond (InitialCondition):  containing current variables+counters\n\nparam_struct (ParamStruct):  contains model paramaters\n\nclock_struct (ClockStruct):  model time paramaters\n\nweather_step (numpy.ndarray):  contains precipitation,ET,temp_max,temp_min for current day\n\noutputs (Output):  object to store outputs\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition):  containing updated simulation variables+counters\n\nparam_struct (ParamStruct):  contains model paramaters\n\noutputs (Output):  object to store outputs\n</code></pre> Source code in <code>aquacrop/timestep/run_single_timestep.py</code> <pre><code>def solution_single_time_step(\n    init_cond: \"InitialCondition\",\n    param_struct: \"ParamStruct\",\n    clock_struct: \"ClockStruct\",\n    weather_step: \"ndarray\",\n    outputs:\"Output\",\n) -&gt;  Tuple[\"InitialCondition\", \"ParamStruct\",\"Output\"]:\n    \"\"\"\n    Function to perform AquaCrop solution for a single time step\n\n    Arguments:\n\n        init_cond (InitialCondition):  containing current variables+counters\n\n        param_struct (ParamStruct):  contains model paramaters\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        weather_step (numpy.ndarray):  contains precipitation,ET,temp_max,temp_min for current day\n\n        outputs (Output):  object to store outputs\n\n    Returns:\n\n        NewCond (InitialCondition):  containing updated simulation variables+counters\n\n        param_struct (ParamStruct):  contains model paramaters\n\n        outputs (Output):  object to store outputs\n\n    \"\"\"\n\n    # Unpack structures\n    Soil = param_struct.Soil\n    CO2 = param_struct.CO2\n    precipitation = weather_step[2]\n    temp_max = weather_step[1]\n    temp_min = weather_step[0]\n    et0 = weather_step[3]\n\n    # Store initial conditions in structure for updating %%\n    NewCond = init_cond\n    if param_struct.water_table == 1:\n        GroundWater = param_struct.z_gw[clock_struct.time_step_counter]\n    else:\n        GroundWater = 0\n\n    # Check if growing season is active on current time step %%\n    if clock_struct.season_counter &gt;= 0:\n        # Check if in growing season\n        CurrentDate = clock_struct.step_start_time\n        planting_date = clock_struct.planting_dates[clock_struct.season_counter]\n        harvest_date = clock_struct.harvest_dates[clock_struct.season_counter]\n\n        if (\n            (planting_date &lt;= CurrentDate)\n            and (harvest_date &gt;= CurrentDate)\n            and (NewCond.crop_mature is False)\n            and (NewCond.crop_dead is False)\n        ):\n            growing_season = True\n        else:\n            growing_season = False\n        # Assign crop, irrigation management, and field management structures\n        Crop_ = param_struct.Seasonal_Crop_List[clock_struct.season_counter]\n        Crop_Name = param_struct.CropChoices[clock_struct.season_counter]\n        IrrMngt = param_struct.IrrMngt\n\n        if growing_season is True:\n            FieldMngt = param_struct.FieldMngt\n        else:\n            FieldMngt = param_struct.FallowFieldMngt\n\n    else:\n        # Not yet reached start of first growing season\n        growing_season = False\n        # Assign crop, irrigation management, and field management structures\n        # Assign first crop as filler crop\n        Crop_ = param_struct.Fallow_Crop\n        Crop_Name = \"fallow\"\n\n        Crop_.Aer = 5\n        Crop_.Zmin = 0.3\n        IrrMngt = param_struct.FallowIrrMngt\n        FieldMngt = param_struct.FallowFieldMngt\n\n    # Increment time counters %%\n    if growing_season is True:\n        # Calendar days after planting\n        NewCond.dap = NewCond.dap + 1\n        # Growing degree days after planting\n        gdd = growing_degree_day(\n            Crop_.GDDmethod, Crop_.Tupp, Crop_.Tbase, temp_max, temp_min\n        )\n\n        # Update cumulative gdd counter\n        NewCond.gdd = gdd\n        NewCond.gdd_cum = NewCond.gdd_cum + gdd\n\n        NewCond.growing_season = True\n    else:\n        NewCond.growing_season = False\n\n        # Calendar days after planting\n        NewCond.dap = 0\n        # Growing degree days after planting\n        gdd = 0.3\n        NewCond.gdd_cum = 0\n\n    # save current timestep counter\n    NewCond.time_step_counter = clock_struct.time_step_counter\n    NewCond.precipitation = weather_step[2]\n    NewCond.temp_max = weather_step[1]\n    NewCond.temp_min = weather_step[0]\n    NewCond.et0 = weather_step[3]\n\n    crop = Crop_\n\n    # Run simulations %%\n    # 1. Check for groundwater table\n    NewCond.th_fc_Adj, NewCond.wt_in_soil, NewCond.z_gw = check_groundwater_table(\n        Soil.Profile,\n        NewCond.z_gw,\n        NewCond.th,\n        NewCond.th_fc_Adj,\n        param_struct.water_table,\n        GroundWater\n    )\n\n    # 2. Root development\n    NewCond.z_root, NewCond.r_cor = root_development(\n        crop,\n        Soil.Profile,\n        NewCond.dap,\n        NewCond.z_root,\n        NewCond.delayed_cds,\n        NewCond.gdd_cum,\n        NewCond.delayed_gdds,\n        NewCond.tr_ratio,\n        NewCond.th,\n        NewCond.canopy_cover,\n        NewCond.canopy_cover_ns,\n        NewCond.germination,\n        NewCond.r_cor,\n        NewCond.t_pot,\n        NewCond.z_gw,\n        gdd,\n        growing_season,\n        param_struct.water_table,\n    )\n\n    # 3. Pre-irrigation\n    NewCond, PreIrr = pre_irrigation(\n        Soil.Profile, crop, NewCond, growing_season, IrrMngt\n    )\n\n    # 4. Drainage\n\n    NewCond.th, DeepPerc, FluxOut = drainage(\n        Soil.Profile,\n        NewCond.th,\n        NewCond.th_fc_Adj,\n    )\n\n    # 5. Surface runoff\n    Runoff, Infl, NewCond.day_submerged = rainfall_partition(\n        precipitation,\n        NewCond.th,\n        NewCond.day_submerged,\n        FieldMngt.sr_inhb,\n        FieldMngt.bunds,\n        FieldMngt.z_bund,\n        FieldMngt.curve_number_adj_pct,\n        Soil.cn,\n        Soil.adj_cn,\n        Soil.z_cn,\n        Soil.nComp,\n        Soil.Profile,\n    )\n\n    # 6. Irrigation\n    NewCond.depletion, NewCond.taw, NewCond.irr_cum, Irr = irrigation(\n        IrrMngt.irrigation_method,\n        IrrMngt.SMT,\n        IrrMngt.AppEff,\n        IrrMngt.MaxIrr,\n        IrrMngt.IrrInterval,\n        IrrMngt.Schedule,\n        IrrMngt.depth,\n        IrrMngt.MaxIrrSeason,\n        NewCond.growth_stage,\n        NewCond.irr_cum,\n        NewCond.e_pot,\n        NewCond.t_pot,\n        NewCond.z_root,\n        NewCond.th,\n        NewCond.dap,\n        NewCond.time_step_counter,\n        crop,\n        Soil.Profile,\n        Soil.z_top,\n        growing_season,\n        precipitation,\n        Runoff,\n    )\n\n    # 7. Infiltration\n    (\n        NewCond.th,\n        NewCond.surface_storage,\n        DeepPerc,\n        Runoff,\n        Infl,\n        FluxOut,\n    ) = infiltration(\n        Soil.Profile,\n        NewCond.surface_storage,\n        NewCond.th_fc_Adj,\n        NewCond.th,\n        Infl,\n        Irr,\n        IrrMngt.AppEff,\n        FieldMngt.bunds,\n        FieldMngt.z_bund,\n        FluxOut,\n        DeepPerc,\n        Runoff,\n        growing_season,\n    )\n    # 8. Capillary Rise\n    NewCond, CR = capillary_rise(\n        Soil.Profile,\n        Soil.nLayer,\n        Soil.fshape_cr,\n        NewCond,\n        FluxOut,\n        param_struct.water_table,\n    )\n\n    # 9. Check germination\n    NewCond = germination(\n        NewCond,\n        Soil.z_germ,\n        Soil.Profile,\n        crop.GermThr,\n        crop.PlantMethod,\n        gdd,\n        growing_season,\n    )\n\n    # 10. Update growth stage\n    NewCond = growth_stage(crop, NewCond, growing_season)\n\n    # 11. Canopy cover development\n    NewCond = canopy_cover(\n        crop, Soil.Profile, Soil.z_top, NewCond, gdd, et0, growing_season\n    )\n\n    # 12. Soil evaporation\n    (\n        NewCond.e_pot,\n        NewCond.th,\n        NewCond.stage2,\n        NewCond.w_stage_2,\n        NewCond.w_surf,\n        NewCond.surface_storage,\n        NewCond.evap_z,\n        Es,\n        EsPot,\n    ) = soil_evaporation(\n        clock_struct.evap_time_steps,\n        clock_struct.sim_off_season,\n        clock_struct.time_step_counter,\n        Soil.Profile,\n        Soil.evap_z_min,\n        Soil.evap_z_max,\n        Soil.rew,\n        Soil.kex,\n        Soil.fwcc,\n        Soil.f_wrel_exp,\n        Soil.f_evap,\n        crop.CalendarType,\n        crop.Senescence,\n        IrrMngt.irrigation_method,\n        IrrMngt.WetSurf,\n        FieldMngt.mulches,\n        FieldMngt.f_mulch,\n        FieldMngt.mulch_pct,\n        NewCond.dap,\n        NewCond.w_surf,\n        NewCond.evap_z,\n        NewCond.stage2,\n        NewCond.th,\n        NewCond.delayed_cds,\n        NewCond.gdd_cum,\n        NewCond.delayed_gdds,\n        NewCond.ccx_w,\n        NewCond.canopy_cover_adj,\n        NewCond.ccx_act,\n        NewCond.canopy_cover,\n        NewCond.premat_senes,\n        NewCond.surface_storage,\n        NewCond.w_stage_2,\n        NewCond.e_pot,\n        et0,\n        Infl,\n        precipitation,\n        Irr,\n        growing_season,\n    )\n\n    # 13. Crop transpiration\n    Tr, TrPot_NS, TrPot, NewCond, IrrNet = transpiration(\n        Soil.Profile,\n        Soil.nComp,\n        Soil.z_top,\n        crop,\n        IrrMngt.irrigation_method,\n        IrrMngt.NetIrrSMT,\n        NewCond,\n        et0,\n        CO2,\n        growing_season,\n        gdd,\n    )\n\n    # 14. Groundwater inflow\n    NewCond, GwIn = groundwater_inflow(Soil.Profile, NewCond)\n\n    # 15. Reference harvest index\n    (NewCond.hi_ref, NewCond.yield_form, NewCond.pct_lag_phase) = HIref_current_day( # ,NewCond.HIfinal\n        NewCond.hi_ref,\n        NewCond.HIfinal,\n        NewCond.dap,\n        NewCond.delayed_cds,\n        NewCond.yield_form,\n        NewCond.pct_lag_phase,\n        NewCond.canopy_cover,\n        NewCond.cc_prev,\n        NewCond.ccx_w,\n        crop,\n        growing_season,\n    )\n\n    # 16. Biomass accumulation\n    (NewCond.biomass, NewCond.biomass_ns) = biomass_accumulation(\n        crop,\n        NewCond.dap,\n        NewCond.delayed_cds,\n        NewCond.hi_ref,\n        NewCond.pct_lag_phase,\n        NewCond.biomass,\n        NewCond.biomass_ns,\n        Tr,\n        TrPot_NS,\n        et0,\n        growing_season,\n    )\n\n    # 17. Harvest index\n    NewCond = harvest_index(\n        Soil.Profile, Soil.z_top, crop, NewCond, et0, temp_max, temp_min, growing_season\n    )\n\n    # 18. Yield potential\n    NewCond.YieldPot = (NewCond.biomass_ns / 100) * NewCond.harvest_index\n\n    # 19. Crop yield_ (dry and fresh)\n    if growing_season is True:\n        # Calculate crop yield_ (tonne/ha)\n        NewCond.DryYield = (NewCond.biomass / 100) * NewCond.harvest_index_adj\n        NewCond.FreshYield = NewCond.DryYield / (crop.YldWC / 100)\n        # print( clock_struct.time_step_counter,(NewCond.biomass/100),NewCond.harvest_index_adj)\n        # Check if crop has reached maturity\n        if ((crop.CalendarType == 1) and (NewCond.dap &gt;= crop.Maturity)) or (\n            (crop.CalendarType == 2) and (NewCond.gdd_cum &gt;= crop.Maturity)\n        ):\n            # Crop has reached maturity\n            NewCond.crop_mature = True\n\n    elif growing_season is False:\n        # Crop yield_ is zero outside of growing season\n        NewCond.DryYield = 0\n        NewCond.FreshYield = 0\n\n    # 20. Root zone water\n    _TAW = TAW()\n    _water_root_depletion = Dr()\n    # thRZ = RootZoneWater()\n\n    Wr, _water_root_depletion.Zt, _water_root_depletion.Rz, _TAW.Zt, _TAW.Rz, _, _, _, _, _, _ = root_zone_water(\n        Soil.Profile,\n        float(NewCond.z_root),\n        NewCond.th,\n        Soil.z_top,\n        float(crop.Zmin),\n        crop.Aer,\n    )\n\n    # 21. Update net irrigation to add any pre irrigation\n    IrrNet = IrrNet + PreIrr\n    NewCond.irr_net_cum = NewCond.irr_net_cum + PreIrr\n\n    # Update model outputs %%\n    row_day = clock_struct.time_step_counter\n    row_gs = clock_struct.season_counter\n\n    # Irrigation\n    if growing_season is True:\n        if IrrMngt.irrigation_method == 4:\n            # Net irrigation\n            IrrDay = IrrNet\n            IrrTot = NewCond.irr_net_cum\n        else:\n            # Irrigation\n            IrrDay = Irr\n            IrrTot = NewCond.irr_cum\n\n    else:\n        IrrDay = 0\n        IrrTot = 0\n\n        NewCond.depletion = _water_root_depletion.Rz\n        NewCond.taw = _TAW.Rz\n\n    # Water contents\n    outputs.water_storage[row_day, :3] = np.array(\n        [clock_struct.time_step_counter, growing_season, NewCond.dap]\n    )\n    outputs.water_storage[row_day, 3:] = NewCond.th\n\n    # Water fluxes\n    # print(f'Saving NewCond.z_gw to outputs: {NewCond.z_gw}')\n    outputs.water_flux[row_day, :] = [\n        clock_struct.time_step_counter,\n        clock_struct.season_counter,\n        NewCond.dap,\n        Wr,\n        NewCond.z_gw,\n        NewCond.surface_storage,\n        IrrDay,\n        Infl,\n        Runoff,\n        DeepPerc,\n        CR,\n        GwIn,\n        Es,\n        EsPot,\n        Tr,\n        TrPot,\n    ]\n\n    # Crop growth\n    outputs.crop_growth[row_day, :] = [\n        clock_struct.time_step_counter,\n        clock_struct.season_counter,\n        NewCond.dap,\n        gdd,\n        NewCond.gdd_cum,\n        NewCond.z_root,\n        NewCond.canopy_cover,\n        NewCond.canopy_cover_ns,\n        NewCond.biomass,\n        NewCond.biomass_ns,\n        NewCond.harvest_index,\n        NewCond.harvest_index_adj,\n        NewCond.DryYield,\n        NewCond.FreshYield,\n        NewCond.YieldPot,\n    ]\n\n    # Final output (if at end of growing season)\n    if clock_struct.season_counter &gt; -1:\n        if (\n            (NewCond.crop_mature is True)\n            or (NewCond.crop_dead is True)\n            or (\n                clock_struct.harvest_dates[clock_struct.season_counter]\n                == clock_struct.step_end_time\n            )\n        ) and (NewCond.harvest_flag is False):\n\n            # Store final outputs\n            outputs.final_stats.loc[row_gs] = [\n                clock_struct.season_counter,\n                Crop_Name,\n                clock_struct.step_end_time,\n                clock_struct.time_step_counter,\n                NewCond.DryYield,\n                NewCond.FreshYield,\n                NewCond.YieldPot,\n                IrrTot,\n            ]\n\n            # Set harvest flag\n            NewCond.harvest_flag = True\n\n    return NewCond, param_struct, outputs\n</code></pre>"},{"location":"timestep/#aquacrop.timestep.update_time","title":"<code>aquacrop.timestep.update_time</code>","text":"<p>Update time function</p>"},{"location":"timestep/#aquacrop.timestep.update_time.update_time","title":"<code>update_time(clock_struct, init_cond, param_struct, weather, crop)</code>","text":"<p>Function to update current time in model.</p> <p>Arguments:</p> <pre><code>clock_struct (ClockStruct):  model time paramaters\n\ninit_cond (InitialCondition):  containing sim variables+counters\n\nparam_struct (ParamStruct):  containing model paramaters\n\nweather (numpy.array):  weather data for simulation period\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct):  model time paramaters\n\ninit_cond (InitialCondition):  containing reset model paramaters\n\nparam_struct (ParamStruct):  containing model paramaters\n</code></pre> Source code in <code>aquacrop/timestep/update_time.py</code> <pre><code>def update_time(\n    clock_struct: \"ClockStruct\",\n    init_cond: \"InitialCondition\",\n    param_struct: \"ParamStruct\",\n    weather: \"ndarray\",\n    crop: \"Crop\",\n    ) -&gt; Tuple[\"ClockStruct\",\"InitialCondition\", \"ParamStruct\"]:\n    \"\"\"\n    Function to update current time in model.\n\n    Arguments:\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        init_cond (InitialCondition):  containing sim variables+counters\n\n        param_struct (ParamStruct):  containing model paramaters\n\n        weather (numpy.array):  weather data for simulation period\n\n    Returns:\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        init_cond (InitialCondition):  containing reset model paramaters\n\n        param_struct (ParamStruct):  containing model paramaters\n    \"\"\"\n    # Update time\n    if clock_struct.model_is_finished is False:\n        if (init_cond.harvest_flag is True) and (\n            (clock_struct.sim_off_season is False)\n        ):\n            # TODO: sim_off_season will always be False.\n\n            # End of growing season has been reached and not simulating\n            # off-season soil water balance. Advance time to the start of the\n            # next growing season.\n            # Check if in last growing season\n            if clock_struct.season_counter &lt; clock_struct.n_seasons - 1:\n                # Update growing season counter\n                clock_struct.season_counter = clock_struct.season_counter + 1\n                # Update time-step counter\n\n                clock_struct.time_step_counter = clock_struct.time_span.get_loc(\n                    clock_struct.planting_dates[clock_struct.season_counter]\n                )\n                # Update start time of time-step\n                clock_struct.step_start_time = clock_struct.time_span[\n                    clock_struct.time_step_counter\n                ]\n                # Update end time of time-step\n                clock_struct.step_end_time = clock_struct.time_span[\n                    clock_struct.time_step_counter + 1\n                ]\n                # Reset initial conditions for start of growing season\n                init_cond, param_struct = reset_initial_conditions(\n                    clock_struct, init_cond, param_struct, weather, crop\n                )\n\n        else:\n            # Simulation considers off-season, so progress by one time-step\n            # (one day)\n            # Time-step counter\n            clock_struct.time_step_counter = clock_struct.time_step_counter + 1\n            # Start of time step (beginning of current day)\n            # clock_struct.time_span = pd.Series(clock_struct.time_span)\n            clock_struct.step_start_time = clock_struct.time_span[\n                clock_struct.time_step_counter\n            ]\n            # End of time step (beginning of next day)\n            clock_struct.step_end_time = clock_struct.time_span[\n                clock_struct.time_step_counter + 1\n            ]\n            # Check if it is not the last growing season\n            if clock_struct.season_counter &lt; clock_struct.n_seasons - 1:\n                # Check if upcoming day is the start of a new growing season\n                if (\n                    clock_struct.step_start_time\n                    == clock_struct.planting_dates[clock_struct.season_counter + 1]\n                ):\n                    # Update growing season counter\n                    clock_struct.season_counter = clock_struct.season_counter + 1\n                    # Reset initial conditions for start of growing season\n                    init_cond, param_struct = reset_initial_conditions(\n                        clock_struct, init_cond, param_struct, weather, crop\n                    )\n\n    return clock_struct, init_cond, param_struct\n</code></pre>"},{"location":"utils/","title":"utils","text":""},{"location":"utils/#aquacrop.utils.data","title":"<code>aquacrop.utils.data</code>","text":""},{"location":"utils/#aquacrop.utils.data.get_data","title":"<code>get_data(filename, **kwargs)</code>","text":"<p>get selected data file</p> Source code in <code>aquacrop/utils/data.py</code> <pre><code>def get_data(filename, **kwargs):\n    \"\"\"\n    get selected data file\n    \"\"\"\n    filepath = os.path.join(data.__path__[0], filename)\n\n    return np.genfromtxt(filepath, **kwargs)\n</code></pre>"},{"location":"utils/#aquacrop.utils.data.get_filepath","title":"<code>get_filepath(filename)</code>","text":"<p>get selected data file</p> Source code in <code>aquacrop/utils/data.py</code> <pre><code>def get_filepath(filename):\n    \"\"\"\n    get selected data file\n    \"\"\"\n    filepath = os.path.join(data.__path__[0], filename)\n\n    return filepath\n</code></pre>"},{"location":"utils/#aquacrop.utils.data.list_data","title":"<code>list_data()</code>","text":"<p>lists all built-in data files</p> Source code in <code>aquacrop/utils/data.py</code> <pre><code>def list_data():\n    \"\"\"\n    lists all built-in data files\n    \"\"\"\n    path = data.__path__[0]\n\n    return os.listdir(path)\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars","title":"<code>aquacrop.utils.lars</code>","text":""},{"location":"utils/#aquacrop.utils.lars.AquaCropModel","title":"<code>AquaCropModel</code>","text":"<p>This is the main class of the AquaCrop-OSPy model. It is in charge of executing all the operations.</p> <p>Parameters:</p> <pre><code>sim_start_time (str): YYYY/MM/DD, Simulation start date\n\nsim_end_time (str): date YYYY/MM/DD, Simulation end date\n\nweather_df: daily weather data , created using prepare_weather\n\nsoil: Soil object contains paramaters and variables of the soil\n        used in the simulation\n\ncrop: Crop object contains Paramaters and variables of the crop used\n        in the simulation\n\ninitial_water_content: Defines water content at start of simulation\n\nirrigation_management: Defines irrigation strategy\n\nfield_management: Defines field management options\n\nfallow_field_management: Defines field management options during fallow period\n\ngroundwater: Stores information on water table parameters\n\nco2_concentration: Defines CO2 concentrations\n\noff_season: (True) simulate off-season or (False) skip ahead to start of \n            next growing season\n</code></pre> Source code in <code>aquacrop/core.py</code> <pre><code>class AquaCropModel:\n    \"\"\"\n    This is the main class of the AquaCrop-OSPy model.\n    It is in charge of executing all the operations.\n\n    Parameters:\n\n        sim_start_time (str): YYYY/MM/DD, Simulation start date\n\n        sim_end_time (str): date YYYY/MM/DD, Simulation end date\n\n        weather_df: daily weather data , created using prepare_weather\n\n        soil: Soil object contains paramaters and variables of the soil\n                used in the simulation\n\n        crop: Crop object contains Paramaters and variables of the crop used\n                in the simulation\n\n        initial_water_content: Defines water content at start of simulation\n\n        irrigation_management: Defines irrigation strategy\n\n        field_management: Defines field management options\n\n        fallow_field_management: Defines field management options during fallow period\n\n        groundwater: Stores information on water table parameters\n\n        co2_concentration: Defines CO2 concentrations\n\n        off_season: (True) simulate off-season or (False) skip ahead to start of \n                    next growing season\n\n\n    \"\"\"\n\n    # Model parameters\n    __steps_are_finished: bool = False  # True if all steps of the simulation are done.\n    __has_model_executed: bool = False  # Determines if the model has been run\n    __has_model_finished: bool = False  # Determines if the model is finished\n    __start_model_execution: float = 0.0  # Time when the execution start\n    __end_model_execution: float = 0.0  # Time when the execution end\n    # Attributes initialised later\n    _clock_struct: \"ClockStruct\"\n    _param_struct: \"ParamStruct\"\n    _init_cond: \"InitialCondition\"\n    _outputs: \"Output\"\n    _weather: \"DataFrame\"\n\n    def __init__(\n        self,\n        sim_start_time: str,\n        sim_end_time: str,\n        weather_df: \"DataFrame\",\n        soil: \"Soil\",\n        crop: \"Crop\",\n        initial_water_content: \"InitialWaterContent\",\n        irrigation_management: Optional[\"IrrigationManagement\"] = None,\n        field_management: Optional[\"FieldMngt\"] = None,\n        fallow_field_management: Optional[\"FieldMngt\"] = None,\n        groundwater: Optional[\"GroundWater\"] = None,\n        co2_concentration: Optional[\"CO2\"] = None,\n        off_season: bool=False,\n    ) -&gt; None:\n\n        self.sim_start_time = sim_start_time\n        self.sim_end_time = sim_end_time\n        self.weather_df = weather_df\n        self.soil = soil\n        self.crop = crop\n        self.initial_water_content = initial_water_content   \n        self.co2_concentration = co2_concentration\n        self.off_season = off_season\n\n        self.irrigation_management = irrigation_management\n        self.field_management = field_management\n        self.fallow_field_management = fallow_field_management\n        self.groundwater = groundwater\n\n        if irrigation_management is None:\n            self.irrigation_management = IrrigationManagement(irrigation_method=0)\n        if field_management is None:\n            self.field_management = FieldMngt()\n        if fallow_field_management is None:\n            self.fallow_field_management = FieldMngt()\n        if groundwater is None:\n            self.groundwater = GroundWater()\n        if co2_concentration is None:\n            self.co2_concentration = CO2()\n\n    @property\n    def sim_start_time(self) -&gt; str:\n        \"\"\"\n        Return sim start date\n        \"\"\"\n        return self._sim_start_time\n\n    @sim_start_time.setter\n    def sim_start_time(self, value: str) -&gt; None:\n        \"\"\"\n        Check if sim start date is in a correct format.\n        \"\"\"\n\n        if _sim_date_format_is_correct(value) is not False:\n            self._sim_start_time = value\n        else:\n            raise ValueError(\"sim_start_time format must be 'YYYY/MM/DD'\")\n\n    @property\n    def sim_end_time(self) -&gt; str:\n        \"\"\"\n        Return sim end date\n        \"\"\"\n        return self._sim_end_time\n\n    @sim_end_time.setter\n    def sim_end_time(self, value: str) -&gt; None:\n        \"\"\"\n        Check if sim end date is in a correct format.\n        \"\"\"\n        if _sim_date_format_is_correct(value) is not False:\n            self._sim_end_time = value\n        else:\n            raise ValueError(\"sim_end_time format must be 'YYYY/MM/DD'\")\n\n    @property\n    def weather_df(self) -&gt; \"DataFrame\":\n        \"\"\"\n        Return weather dataframe\n        \"\"\"\n        return self._weather_df\n\n    @weather_df.setter\n    def weather_df(self, value: \"DataFrame\"):\n        \"\"\"\n        Check if weather dataframe is in a correct format.\n        \"\"\"\n        weather_df_columns = \"Date MinTemp MaxTemp Precipitation ReferenceET\".split(\" \")\n        if not all([column in value for column in weather_df_columns]):\n            raise ValueError(\n                \"Error in weather_df format. Check if all the following columns exist \"\n                + \"(Date MinTemp MaxTemp Precipitation ReferenceET).\"\n            )\n\n        self._weather_df = value\n\n    def _initialize(self) -&gt; None:\n        \"\"\"\n        Initialise all model variables\n        \"\"\"\n\n        # Initialize ClockStruct object\n        self._clock_struct = read_clock_parameters(\n            self.sim_start_time, self.sim_end_time, self.off_season\n        )\n\n        # get _weather data\n        self.weather_df = read_weather_inputs(self._clock_struct, self.weather_df)\n\n        # read model params\n        self._clock_struct, self._param_struct = read_model_parameters(\n            self._clock_struct, self.soil, self.crop, self.weather_df\n        )\n\n        # read irrigation management\n        self._param_struct = read_irrigation_management(\n            self._param_struct, self.irrigation_management, self._clock_struct\n        )\n\n        # read field management\n        self._param_struct = read_field_management(\n            self._param_struct, self.field_management, self.fallow_field_management\n        )\n\n        # read groundwater table\n        self._param_struct = read_groundwater_table(\n            self._param_struct, self.groundwater, self._clock_struct\n        )\n\n        # Compute additional variables\n        self._param_struct.CO2 = self.co2_concentration\n        self._param_struct = compute_variables(\n            self._param_struct, self.weather_df, self._clock_struct\n        )\n\n        # read, calculate inital conditions\n        self._param_struct, self._init_cond = read_model_initial_conditions(\n            self._param_struct, self._clock_struct, self.initial_water_content, self.crop\n        )\n\n        self._param_struct = create_soil_profile(self._param_struct)\n\n        # Outputs results (water_flux, crop_growth, final_stats)\n        self._outputs = Output(self._clock_struct.time_span, self._init_cond.th)\n\n        # save model _weather to _init_cond\n        self._weather = self.weather_df.values\n\n    def run_model(\n        self,\n        num_steps: int = 1,\n        till_termination: bool = False,\n        initialize_model: bool = True,\n        process_outputs: bool = False,\n    ) -&gt; bool:\n        \"\"\"\n        This function is responsible for executing the model.\n\n        Arguments:\n\n            num_steps: Number of steps (Days) to be executed.\n\n            till_termination: Run the simulation to completion\n\n            initialize_model: Whether to initialize the model \\\n            (i.e., go back to beginning of season)\n\n            process_outputs: process outputs into dataframe before \\\n                simulation is finished\n\n        Returns:\n            True if finished\n        \"\"\"\n\n        if initialize_model:\n            self._initialize()\n\n        if till_termination:\n            self.__start_model_execution = time.time()\n            while self._clock_struct.model_is_finished is False:\n                (\n                    self._clock_struct,\n                    self._init_cond,\n                    self._param_struct,\n                    self._outputs,\n                ) = self._perform_timestep()\n            self.__end_model_execution = time.time()\n            self.__has_model_executed = True\n            self.__has_model_finished = True\n            return True\n        else:\n            if num_steps &lt; 1:\n                raise ValueError(\"num_steps must be equal to or greater than 1.\")\n            self.__start_model_execution = time.time()\n            for i in range(num_steps):\n\n                if (i == range(num_steps)[-1]) and (process_outputs is True):\n                    self.__steps_are_finished = True\n\n                (\n                    self._clock_struct,\n                    self._init_cond,\n                    self._param_struct,\n                    self._outputs,\n                ) = self._perform_timestep()\n\n                if self._clock_struct.model_is_finished:\n                    self.__end_model_execution = time.time()\n                    self.__has_model_executed = True\n                    self.__has_model_finished = True\n                    return True\n\n            self.__end_model_execution = time.time()\n            self.__has_model_executed = True\n            self.__has_model_finished = False\n            return True\n\n    def _perform_timestep(\n        self,\n    ) -&gt; Tuple[\"ClockStruct\", \"InitialCondition\", \"ParamStruct\", \"Output\"]:\n\n        \"\"\"\n        Function to run a single time-step (day) calculation of AquaCrop-OS\n        \"\"\"\n\n        # extract _weather data for current timestep\n        weather_step = _weather_data_current_timestep(\n            self._weather, self._clock_struct.time_step_counter\n        )\n\n        # Get model solution_single_time_step\n        new_cond, param_struct, outputs = solution_single_time_step(\n            self._init_cond,\n            self._param_struct,\n            self._clock_struct,\n            weather_step,\n            self._outputs,\n        )\n\n        # Check model termination\n        clock_struct = self._clock_struct\n        clock_struct.model_is_finished = check_model_is_finished(\n            self._clock_struct.step_end_time,\n            self._clock_struct.simulation_end_date,\n            self._clock_struct.model_is_finished,\n            self._clock_struct.season_counter,\n            self._clock_struct.n_seasons,\n            new_cond.harvest_flag,\n        )\n\n        # Update time step\n        clock_struct, _init_cond, param_struct = update_time(\n            clock_struct, new_cond, param_struct, self._weather, self.crop\n        )\n\n        # Create  _outputsdataframes when model is finished\n        final_water_flux_growth_outputs = outputs_when_model_is_finished(\n            clock_struct.model_is_finished,\n            outputs.water_flux,\n            outputs.water_storage,\n            outputs.crop_growth,\n            self.__steps_are_finished,\n        )\n\n        if final_water_flux_growth_outputs is not False:\n            (\n                outputs.water_flux,\n                outputs.water_storage,\n                outputs.crop_growth,\n            ) = final_water_flux_growth_outputs\n\n        return clock_struct, _init_cond, param_struct, outputs\n\n    def get_simulation_results(self):\n        \"\"\"\n        Return all the simulation results\n        \"\"\"\n        if self.__has_model_executed:\n            if self.__has_model_finished:\n                return self._outputs.final_stats\n            else:\n                return False  # If the model is not finished, the results are not generated.\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_water_storage(self):\n        \"\"\"\n        Return water storage in soil results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.water_storage\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_water_flux(self):\n        \"\"\"\n        Return water flux results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.water_flux\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_crop_growth(self):\n        \"\"\"\n        Return crop growth results\n        \"\"\"\n        if self.__has_model_executed:\n            return self._outputs.crop_growth\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n\n    def get_additional_information(self) -&gt; Dict[str, Union[bool, float]]:\n        \"\"\"\n        Additional model information.\n\n        Returns:\n            dict: {has_model_finished,execution_time}\n\n        \"\"\"\n        if self.__has_model_executed:\n            return {\n                \"has_model_finished\": self.__has_model_finished,\n                \"execution_time\": self.__end_model_execution\n                - self.__start_model_execution,\n            }\n        else:\n            raise ValueError(\n                \"You cannot get results without running the model. \"\n                + \"Please execute the run_model() method.\"\n            )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.sim_end_time","title":"<code>sim_end_time</code>  <code>property</code> <code>writable</code>","text":"<p>Return sim end date</p>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.sim_start_time","title":"<code>sim_start_time</code>  <code>property</code> <code>writable</code>","text":"<p>Return sim start date</p>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.weather_df","title":"<code>weather_df</code>  <code>property</code> <code>writable</code>","text":"<p>Return weather dataframe</p>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.get_additional_information","title":"<code>get_additional_information()</code>","text":"<p>Additional model information.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[str, Union[bool, float]]</code> <p>{has_model_finished,execution_time}</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_additional_information(self) -&gt; Dict[str, Union[bool, float]]:\n    \"\"\"\n    Additional model information.\n\n    Returns:\n        dict: {has_model_finished,execution_time}\n\n    \"\"\"\n    if self.__has_model_executed:\n        return {\n            \"has_model_finished\": self.__has_model_finished,\n            \"execution_time\": self.__end_model_execution\n            - self.__start_model_execution,\n        }\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.get_crop_growth","title":"<code>get_crop_growth()</code>","text":"<p>Return crop growth results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_crop_growth(self):\n    \"\"\"\n    Return crop growth results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.crop_growth\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.get_simulation_results","title":"<code>get_simulation_results()</code>","text":"<p>Return all the simulation results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_simulation_results(self):\n    \"\"\"\n    Return all the simulation results\n    \"\"\"\n    if self.__has_model_executed:\n        if self.__has_model_finished:\n            return self._outputs.final_stats\n        else:\n            return False  # If the model is not finished, the results are not generated.\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.get_water_flux","title":"<code>get_water_flux()</code>","text":"<p>Return water flux results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_water_flux(self):\n    \"\"\"\n    Return water flux results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.water_flux\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.get_water_storage","title":"<code>get_water_storage()</code>","text":"<p>Return water storage in soil results</p> Source code in <code>aquacrop/core.py</code> <pre><code>def get_water_storage(self):\n    \"\"\"\n    Return water storage in soil results\n    \"\"\"\n    if self.__has_model_executed:\n        return self._outputs.water_storage\n    else:\n        raise ValueError(\n            \"You cannot get results without running the model. \"\n            + \"Please execute the run_model() method.\"\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.AquaCropModel.run_model","title":"<code>run_model(num_steps=1, till_termination=False, initialize_model=True, process_outputs=False)</code>","text":"<p>This function is responsible for executing the model.</p> <p>Arguments:</p> <pre><code>num_steps: Number of steps (Days) to be executed.\n\ntill_termination: Run the simulation to completion\n\ninitialize_model: Whether to initialize the model             (i.e., go back to beginning of season)\n\nprocess_outputs: process outputs into dataframe before                 simulation is finished\n</code></pre> <p>Returns:</p> Type Description <code>bool</code> <p>True if finished</p> Source code in <code>aquacrop/core.py</code> <pre><code>def run_model(\n    self,\n    num_steps: int = 1,\n    till_termination: bool = False,\n    initialize_model: bool = True,\n    process_outputs: bool = False,\n) -&gt; bool:\n    \"\"\"\n    This function is responsible for executing the model.\n\n    Arguments:\n\n        num_steps: Number of steps (Days) to be executed.\n\n        till_termination: Run the simulation to completion\n\n        initialize_model: Whether to initialize the model \\\n        (i.e., go back to beginning of season)\n\n        process_outputs: process outputs into dataframe before \\\n            simulation is finished\n\n    Returns:\n        True if finished\n    \"\"\"\n\n    if initialize_model:\n        self._initialize()\n\n    if till_termination:\n        self.__start_model_execution = time.time()\n        while self._clock_struct.model_is_finished is False:\n            (\n                self._clock_struct,\n                self._init_cond,\n                self._param_struct,\n                self._outputs,\n            ) = self._perform_timestep()\n        self.__end_model_execution = time.time()\n        self.__has_model_executed = True\n        self.__has_model_finished = True\n        return True\n    else:\n        if num_steps &lt; 1:\n            raise ValueError(\"num_steps must be equal to or greater than 1.\")\n        self.__start_model_execution = time.time()\n        for i in range(num_steps):\n\n            if (i == range(num_steps)[-1]) and (process_outputs is True):\n                self.__steps_are_finished = True\n\n            (\n                self._clock_struct,\n                self._init_cond,\n                self._param_struct,\n                self._outputs,\n            ) = self._perform_timestep()\n\n            if self._clock_struct.model_is_finished:\n                self.__end_model_execution = time.time()\n                self.__has_model_executed = True\n                self.__has_model_finished = True\n                return True\n\n        self.__end_model_execution = time.time()\n        self.__has_model_executed = True\n        self.__has_model_finished = False\n        return True\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.CO2","title":"<code>CO2</code>","text":"<p>               Bases: <code>object</code></p> <p>Attributes:</p> <pre><code>ref_concentration (float): reference CO2 concentration\n\ncurrent_concentration (float): current CO2 concentration (initialize if constant_conc=True)\n\nconstant_conc (bool): use constant conc every season\n\nco2_data (DataFrame): CO2 timeseries (2 columns: 'year' and 'ppm')\n</code></pre> Source code in <code>aquacrop/entities/co2.py</code> <pre><code>class CO2(object):\n\n    \"\"\"\n\n    Attributes:\n\n        ref_concentration (float): reference CO2 concentration\n\n        current_concentration (float): current CO2 concentration (initialize if constant_conc=True)\n\n        constant_conc (bool): use constant conc every season\n\n        co2_data (DataFrame): CO2 timeseries (2 columns: 'year' and 'ppm')\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ref_concentration=369.41,\n        current_concentration=0.,\n        constant_conc=False,\n        co2_data=None,\n    ):\n        self.ref_concentration = ref_concentration\n        self.current_concentration = current_concentration\n        self.constant_conc = constant_conc\n        if co2_data is not None:\n            self.co2_data = co2_data\n        else:\n            self.co2_data = pd.read_csv(\n                    f\"{acfp}/data/MaunaLoaCO2.txt\",\n                    header=1,\n                    sep='\\s+',\n                    names=[\"year\", \"ppm\"],\n    )\n        self.co2_data_processed = None\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.FieldMngt","title":"<code>FieldMngt</code>","text":"<p>Field Management Class containing mulches and bunds parameters</p> <p>Attributes:</p> <pre><code>mulches (bool):  Soil surface covered by mulches (yield_ or N)\n\nbunds (bool):  Surface bunds present (yield_ or N)\n\ncurve_number_adj (bool): Field conditions affect curve number (yield_ or N)\n\nsr_inhb (bool): Management practices fully inhibit surface runoff (yield_ or N)\n\nmulch_pct (float):  Area of soil surface covered by mulches (%)\n\nf_mulch (float): Soil evaporation adjustment factor due to effect of mulches\n\nz_bund (float): Bund height, user specifies in (m) but immediately converted to (mm) on initialisation for coherent calculations\n\nbund_water (float): Initial water height in surface bunds (mm)\n\ncurve_number_adj_pct (float): Percentage change in curve number (positive or negative)\n</code></pre> Source code in <code>aquacrop/entities/fieldManagement.py</code> <pre><code>class FieldMngt:\n    \"\"\"\n    Field Management Class containing mulches and bunds parameters\n\n    Attributes:\n\n        mulches (bool):  Soil surface covered by mulches (yield_ or N)\n\n        bunds (bool):  Surface bunds present (yield_ or N)\n\n        curve_number_adj (bool): Field conditions affect curve number (yield_ or N)\n\n        sr_inhb (bool): Management practices fully inhibit surface runoff (yield_ or N)\n\n        mulch_pct (float):  Area of soil surface covered by mulches (%)\n\n        f_mulch (float): Soil evaporation adjustment factor due to effect of mulches\n\n        z_bund (float): Bund height, user specifies in (m) but immediately converted to (mm) on initialisation for coherent calculations\n\n        bund_water (float): Initial water height in surface bunds (mm)\n\n        curve_number_adj_pct (float): Percentage change in curve number (positive or negative)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        mulches=False,\n        bunds=False,\n        curve_number_adj=False,\n        sr_inhb=False,\n        mulch_pct=50,\n        f_mulch=0.5,\n        z_bund=0,\n        bund_water=0,\n        curve_number_adj_pct=0,\n    ):\n\n        self.mulches = mulches  #  Soil surface covered by mulches (yield_ or N)\n        self.bunds = bunds  #  Surface bunds present (yield_ or N)\n        self.curve_number_adj = curve_number_adj  # Field conditions affect curve number (yield_ or N)\n        self.sr_inhb = sr_inhb  # Management practices fully inhibit surface runoff (yield_ or N)\n\n        self.mulch_pct = mulch_pct  #  Area of soil surface covered by mulches (%)\n        self.f_mulch = f_mulch  # Soil evaporation adjustment factor due to effect of mulches\n        self.z_bund = z_bund * 1000 # Bund height, user-specified as (m), here immediately converted to (mm)\n        self.bund_water = bund_water  # Initial water height in surface bunds (mm)\n        self.curve_number_adj_pct = curve_number_adj_pct  # Percentage change in curve number (positive or negative)\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.GroundWater","title":"<code>GroundWater</code>","text":"<p>Ground Water Class stores information on water table params</p> <p>Attributes:</p> <pre><code>water_table (str):  Water table considered (Y or N)\n\nmethod (str):  Water table input data ('Constant' or 'Variable')\n\ndates (list): water table observation dates\n\nvalues (list): water table observation depths\n</code></pre> Source code in <code>aquacrop/entities/groundWater.py</code> <pre><code>class GroundWater:\n    \"\"\"\n    Ground Water Class stores information on water table params\n\n    Attributes:\n\n        water_table (str):  Water table considered (Y or N)\n\n        method (str):  Water table input data ('Constant' or 'Variable')\n\n        dates (list): water table observation dates\n\n        values (list): water table observation depths\n\n    \"\"\"\n\n    def __init__(self, water_table=\"N\", method=\"Constant\", dates=[], values=[]):\n\n        self.water_table = water_table\n        self.method = method\n        self.dates = dates\n        self.values = values\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.IrrigationManagement","title":"<code>IrrigationManagement</code>","text":"<p>IrrigationManagement Class defines irrigation strategy</p> <p>Attributes:</p> <pre><code>irrigation_method (int):  Irrigation method {0: rainfed, 1: soil moisture targets, 2: set time interval,\n                                        3: predifined schedule, 4: net irrigation, 5: constant depth }\n\nWetSurf (int): Soil surface wetted by irrigation (%)\n\nAppEff (int): Irrigation application efficiency (%)\n\nMaxIrr (float): Maximum depth (mm) that can be applied each day\n\nSMT (list):  Soil moisture targets (%taw) to maintain in each growth stage (only used if irrigation method is equal to 1)\n\nIrrInterval (int): Irrigation interval in days (only used if irrigation method is equal to 2)\n\nSchedule (pandas.DataFrame): DataFrame containing dates and depths\n\nNetIrrSMT (float): Net irrigation threshold moisture level (% of taw that will be maintained, for irrigation_method=4)\n\nDepth (float): constant depth to apply on each day (mm)\n</code></pre> Source code in <code>aquacrop/entities/irrigationManagement.py</code> <pre><code>class IrrigationManagement:\n\n    \"\"\"\n    IrrigationManagement Class defines irrigation strategy\n\n    Attributes:\n\n\n        irrigation_method (int):  Irrigation method {0: rainfed, 1: soil moisture targets, 2: set time interval,\n                                                3: predifined schedule, 4: net irrigation, 5: constant depth }\n\n        WetSurf (int): Soil surface wetted by irrigation (%)\n\n        AppEff (int): Irrigation application efficiency (%)\n\n        MaxIrr (float): Maximum depth (mm) that can be applied each day\n\n        SMT (list):  Soil moisture targets (%taw) to maintain in each growth stage (only used if irrigation method is equal to 1)\n\n        IrrInterval (int): Irrigation interval in days (only used if irrigation method is equal to 2)\n\n        Schedule (pandas.DataFrame): DataFrame containing dates and depths\n\n        NetIrrSMT (float): Net irrigation threshold moisture level (% of taw that will be maintained, for irrigation_method=4)\n\n        Depth (float): constant depth to apply on each day (mm)\n\n    \"\"\"\n\n    def __init__(self, irrigation_method, **kwargs):\n        self.irrigation_method = irrigation_method\n\n        self.WetSurf = 100.0\n        self.AppEff = 100.0\n        self.MaxIrr = 25.0\n        self.MaxIrrSeason = 10_000.0\n        self.SMT = np.zeros(4)\n        self.IrrInterval = 0\n        self.Schedule = []\n        self.NetIrrSMT = 80.0\n        self.depth = 0.0\n\n        if irrigation_method == 1:\n            self.SMT = [100] * 4\n\n        if irrigation_method == 2:\n            self.IrrInterval = 3\n\n        if irrigation_method == 3:\n            # wants a pandas dataframe with Date and Depth, pd.Datetime and float\n            \"\"\"\n            dates = pd.DatetimeIndex(['20/10/1979','20/11/1979','20/12/1979'])\n            depths = [25,25,25]\n            irr=pd.DataFrame([dates,depths]).T\n            irr.columns=['Date','Depth']\n            \"\"\"\n            self.Schedule = pd.DataFrame(columns=[\"Date\", \"Depth\"])\n\n        if irrigation_method == 4:\n            self.NetIrrSMT = 80\n\n        if irrigation_method == 5:\n            self.depth = 0\n\n        allowed_keys = {\n            \"name\",\n            \"WetSurf\",\n            \"AppEff\",\n            \"MaxIrr\",\n            \"MaxIrrSeason\",\n            \"SMT\",\n            \"IrrInterval\",\n            \"NetIrrSMT\",\n            \"Schedule\",\n            \"depth\",\n        }\n\n        self.__dict__.update((k, v) for k, v in kwargs.items() if k in allowed_keys)\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.Output","title":"<code>Output</code>","text":"<p>Class to hold output data</p> <p>During Simulation these are numpy arrays and are converted to pandas dataframes at the end of the simulation</p> <p>Atributes:</p> <pre><code>water_flux (pandas.DataFrame, numpy.array): Daily water flux changes\n\nwater_storage (pandas.DataFrame, numpy array): daily water content of each soil compartment\n\ncrop_growth (pandas.DataFrame, numpy array): daily crop growth variables\n\nfinal_stats (pandas.DataFrame, numpy array): final stats at end of each season\n</code></pre> Source code in <code>aquacrop/entities/output.py</code> <pre><code>class Output:\n    \"\"\"\n    Class to hold output data\n\n    During Simulation these are numpy arrays and are converted to pandas dataframes\n    at the end of the simulation\n\n    Atributes:\n\n        water_flux (pandas.DataFrame, numpy.array): Daily water flux changes\n\n        water_storage (pandas.DataFrame, numpy array): daily water content of each soil compartment\n\n        crop_growth (pandas.DataFrame, numpy array): daily crop growth variables\n\n        final_stats (pandas.DataFrame, numpy array): final stats at end of each season\n\n    \"\"\"\n\n    def __init__(self, time_span, initial_th):\n\n        self.water_storage = np.zeros((len(time_span), 3 + len(initial_th)))\n        self.water_flux = np.zeros((len(time_span), 16))\n        self.crop_growth = np.zeros((len(time_span), 15))\n        self.final_stats = pd.DataFrame(\n            columns=[\n                \"Season\",\n                \"crop Type\",\n                \"Harvest Date (YYYY/MM/DD)\",\n                \"Harvest Date (Step)\",\n                \"Dry yield (tonne/ha)\",\n                \"Fresh yield (tonne/ha)\",\n                \"Yield potential (tonne/ha)\",\n                \"Seasonal irrigation (mm)\",\n            ]\n        )\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.check_iwc_soil_match","title":"<code>check_iwc_soil_match(iwc_layers, soil_layers)</code>","text":"<p>This function checks if the number of soil layers is equivalent between the user-specified soil profile and initial water content.</p> Return <p>boolean: True if number of layers match</p> Source code in <code>aquacrop/core.py</code> <pre><code>def check_iwc_soil_match(iwc_layers: int, soil_layers: int) -&gt; bool:\n    \"\"\"\n    This function checks if the number of soil layers is equivalent between the user-specified soil profile and initial water content.\n\n    Arguments:\n        iwc_layers\n        soil_layers\n\n    Return:\n        boolean: True if number of layers match\n\n    \"\"\"\n    if(iwc_layers == soil_layers):\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.check_model_is_finished","title":"<code>check_model_is_finished(step_end_time, simulation_end_date, model_is_finished, season_counter, n_seasons, harvest_flag)</code>","text":"<p>Function to check and declare model termination</p> <p>Arguments:</p> <pre><code>step_end_time (str):  date of next step\n\nsimulation_end_date (str):  date of end of simulation\n\nmodel_is_finished (bool):  is model finished\n\nseason_counter (int):  tracking the number of seasons simulated\n\nn_seasons (int):  total number of seasons being simulated\n\nharvest_flag (bool):  Has crop been harvested\n</code></pre> <p>Returns:</p> <pre><code>model_is_finished (bool): is simulation finished\n</code></pre> Source code in <code>aquacrop/timestep/check_if_model_is_finished.py</code> <pre><code>def check_model_is_finished(\n    step_end_time: str,\n    simulation_end_date: str,\n    model_is_finished: bool,\n    season_counter: int,\n    n_seasons: int,\n    harvest_flag: bool,\n) -&gt; bool:\n    \"\"\"\n    Function to check and declare model termination\n\n\n    Arguments:\n\n        step_end_time (str):  date of next step\n\n        simulation_end_date (str):  date of end of simulation\n\n        model_is_finished (bool):  is model finished\n\n        season_counter (int):  tracking the number of seasons simulated\n\n        n_seasons (int):  total number of seasons being simulated\n\n        harvest_flag (bool):  Has crop been harvested\n\n    Returns:\n\n        model_is_finished (bool): is simulation finished\n\n\n    \"\"\"\n\n    # Check if current time-step is the last\n    current_time = step_end_time\n    if current_time &lt; simulation_end_date:\n        model_is_finished = False\n    elif current_time &gt;= simulation_end_date:\n        model_is_finished = True\n\n    # Check if at the end of last growing season ##\n    # Allow model to exit early if crop has reached maturity or died, and in\n    # the last simulated growing season\n    if (harvest_flag is True) and (season_counter == n_seasons - 1):\n        model_is_finished = True\n\n    return model_is_finished\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.compute_variables","title":"<code>compute_variables(param_struct, weather_df, clock_struct, acfp=dirname(dirname(abspath(__file__))))</code>","text":"<p>Function to compute additional variables needed to run the model eg. CO2</p> <p>Arguments:</p> <pre><code>param_struct (ParamStruct):  Contains model paramaters\n\nweather_df (DataFrame):  weather data\n\nclock_struct (ClockStruct):  time params\n\nacfp (Path):  path to aquacrop directory containing co2 data\n</code></pre> <p>Returns:</p> <pre><code>param_struct (ParamStruct):  updated model params\n</code></pre> Source code in <code>aquacrop/initialize/compute_variables.py</code> <pre><code>def compute_variables(\n    param_struct: \"ParamStruct\",\n    weather_df: \"DataFrame\",\n    clock_struct: \"ClockStruct\",\n    acfp: str = dirname(dirname(abspath(__file__))),\n) -&gt; \"ParamStruct\":\n    \"\"\"\n    Function to compute additional variables needed to run the model eg. CO2\n\n    Arguments:\n\n        param_struct (ParamStruct):  Contains model paramaters\n\n        weather_df (DataFrame):  weather data\n\n        clock_struct (ClockStruct):  time params\n\n        acfp (Path):  path to aquacrop directory containing co2 data\n\n    Returns:\n\n        param_struct (ParamStruct):  updated model params\n\n\n    \"\"\"\n\n    if param_struct.water_table == 1:\n\n        param_struct.Soil.add_capillary_rise_params()\n\n    # Calculate readily evaporable water in surface layer\n    if param_struct.Soil.adj_rew == 0:\n        param_struct.Soil.rew = round(\n            (\n                1000\n                * (\n                    param_struct.Soil.profile.th_fc.iloc[0]\n                    - param_struct.Soil.profile.th_dry.iloc[0]\n                )\n                * param_struct.Soil.evap_z_surf\n            ),\n            2,\n        )\n\n    if param_struct.Soil.calc_cn == 1:\n        # adjust curve number\n        ksat = param_struct.Soil.profile.Ksat.iloc[0]\n        if ksat &gt; 864:\n            param_struct.Soil.cn = 46\n        elif ksat &gt; 347:\n            param_struct.Soil.cn = 61\n        elif ksat &gt; 36:\n            param_struct.Soil.cn = 72\n        elif ksat &gt; 0:\n            param_struct.Soil.cn = 77\n\n        assert ksat &gt; 0\n\n    for i in range(param_struct.NCrops):\n\n        crop = param_struct.CropList[i]\n        # crop.calculate_additional_params()\n\n        # Crop calander\n        crop = compute_crop_calendar(\n            crop,\n            clock_struct.planting_dates,\n            clock_struct.simulation_start_date,\n            clock_struct.simulation_end_date,\n            clock_struct.time_span,\n            weather_df,\n        )\n\n        # Harvest index param_struct.Seasonal_Crop_List[clock_struct.season_counter].Paramsgrowth coefficient\n        crop.HIGC = calculate_HIGC(\n            crop.YldFormCD,\n            crop.HI0,\n            crop.HIini,\n        )\n\n        # Days to linear harvest_index switch point\n        if crop.CropType == 3:\n            # Determine linear switch point and HIGC rate for fruit/grain crops\n            crop.tLinSwitch, crop.dHILinear = calculate_HI_linear(\n                crop.YldFormCD, crop.HIini, crop.HI0, crop.HIGC\n            )\n        else:\n            # No linear switch for leafy vegetable or root/tiber crops\n            crop.tLinSwitch = 0\n            crop.dHILinear = 0.0\n\n        param_struct.CropList[i] = crop\n\n    # Calculate WP adjustment factor for elevation in CO2 concentration\n    # Load CO2 data\n    co2Data = param_struct.CO2.co2_data\n\n    # Years\n    start_year, end_year = pd.DatetimeIndex(\n        [clock_struct.simulation_start_date, clock_struct.simulation_end_date]\n    ).year\n    sim_years = np.arange(start_year, end_year + 1)\n\n    # Interpolate data\n    CO2conc_interp = np.interp(sim_years, co2Data.year, co2Data.ppm)\n\n    # Store data\n    param_struct.CO2.co2_data_processed = pd.Series(CO2conc_interp, index=sim_years)  # maybe get rid of this\n\n    # Get CO2 concentration for first year\n    CO2conc = param_struct.CO2.co2_data_processed.iloc[0]\n\n    # param_struct.CO2 = param_struct.co2_concentration_adj\n\n    # if user specified constant concentration\n    if  param_struct.CO2.constant_conc is True:\n        if param_struct.CO2.current_concentration &gt; 0.:\n            CO2conc = param_struct.CO2.current_concentration\n        else:\n            CO2conc = param_struct.CO2.co2_data_processed.iloc[0]\n\n    param_struct.CO2.current_concentration = CO2conc\n\n    CO2ref = param_struct.CO2.ref_concentration\n\n    # Get CO2 weighting factor for first year\n    if CO2conc &lt;= CO2ref:\n        fw = 0\n    else:\n        if CO2conc &gt;= 550:\n            fw = 1\n        else:\n            fw = 1 - ((550 - CO2conc) / (550 - CO2ref))\n\n    # Determine adjustment for each crop in first year of simulation\n    for i in range(param_struct.NCrops):\n        crop = param_struct.CropList[i]\n        # Determine initial adjustment\n        fCO2old = (CO2conc / CO2ref) / (\n            1\n            + (CO2conc - CO2ref)\n            * (\n                (1 - fw) * crop.bsted\n                + fw * ((crop.bsted * crop.fsink) + (crop.bface * (1 - crop.fsink)))\n            )\n        )\n        # New adjusted correction coefficient for CO2 (version 7 of AquaCrop)\n    if (CO2conc &gt; CO2ref):\n        # Calculate shape factor\n        fshape = -4.61824 - 3.43831*crop.fsink - 5.32587*crop.fsink*crop.fsink\n        # Determine adjustment for CO2\n        if (CO2conc &gt;= 2000):\n            fCO2new = 1.58  # Maximum CO2 adjustment \n        else:\n            CO2rel = (CO2conc-CO2ref)/(2000-CO2ref)\n            fCO2new = 1 + 0.58 * ((np.exp(CO2rel*fshape) - 1)/(np.exp(fshape) - 1))\n\n\n    # Select adjusted coefficient for CO2\n    if (CO2conc &lt;= CO2ref):\n        fCO2 = fCO2old\n    elif ((CO2conc &lt;= 550) and (fCO2old &lt; fCO2new)):\n        fCO2 = fCO2old\n    else:\n        fCO2 = fCO2new\n\n        # Consider crop type\n    if crop.WP &gt;= 40:\n        # No correction for C4 crops\n        ftype = 0\n    elif crop.WP &lt;= 20:\n        # Full correction for C3 crops\n        ftype = 1\n    else:\n        ftype = (40 - crop.WP) / (40 - 20)\n\n        # Total adjustment\n    crop.fCO2 = 1 + ftype * (fCO2 - 1)\n\n    param_struct.CropList[i] = crop\n\n\n    # change this later\n    if param_struct.NCrops == 1:\n        crop_list = [\n            deepcopy(param_struct.CropList[0])\n            for i in range(len(param_struct.CropChoices))\n        ]\n        # param_struct.Seasonal_Crop_List = [deepcopy(param_struct.CropList[0]) for i in range(len(param_struct.CropChoices))]\n\n    else:\n        crop_list = param_struct.CropList\n\n    # add crop for out of growing season\n    # param_struct.Fallow_Crop = deepcopy(param_struct.Seasonal_Crop_List[0])\n    Fallow_Crop = deepcopy(crop_list[0])\n\n    param_struct.Seasonal_Crop_List = []\n\n    for crop in crop_list:\n        #crop_struct = Crop(crop.Name, crop.planting_date) # changed from CropStruct to Crop during removal of numba AOT/JIT compilation\n        #for a, v in crop.__dict__.items():\n        #    if hasattr(crop_struct, a):\n        #        crop_struct.__setattr__(a, v)\n\n        param_struct.Seasonal_Crop_List.append(crop)\n\n    fallow_struct = Crop(crop.Name, crop.planting_date) # changed from CropStruct to Crop during removal of numba AOT/JIT compilation\n    for a, v in Fallow_Crop.__dict__.items():\n        if hasattr(fallow_struct, a):\n            fallow_struct.__setattr__(a, v)\n\n    param_struct.Fallow_Crop = fallow_struct\n\n    return param_struct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.create_soil_profile","title":"<code>create_soil_profile(param_struct)</code>","text":"<p>funciton to create soil profile namedTuple to store soil info. Its much faster to access the info when its in a namedTuple compared to a dataframe</p> <p>Arguments:</p> <pre><code>param_struct (ParamStruct):  Contains model crop and soil paramaters\n</code></pre> <p>Returns:</p> <pre><code>param_struct (ParamStruct):  updated with soil profile\n</code></pre> Source code in <code>aquacrop/initialize/create_soil_profile.py</code> <pre><code>def create_soil_profile(param_struct: \"ParamStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    funciton to create soil profile namedTuple to store soil info.\n    Its much faster to access the info when its in a namedTuple\n    compared to a dataframe\n\n    Arguments:\n\n        param_struct (ParamStruct):  Contains model crop and soil paramaters\n\n    Returns:\n\n        param_struct (ParamStruct):  updated with soil profile\n\n\n    \"\"\"\n\n    profile = SoilProfile(int(param_struct.Soil.profile.shape[0]))\n\n    pdf = param_struct.Soil.profile.astype(\"float64\")\n\n    profile.dz = pdf.dz.values\n    profile.dzsum = pdf.dzsum.values\n    profile.zBot = pdf.zBot.values\n    profile.z_top = pdf.z_top.values\n    profile.zMid = pdf.zMid.values\n\n    profile.Comp = np.int64(pdf.Comp.values)\n    profile.Layer = np.int64(pdf.Layer.values)\n    # profile.Layer_dz = pdf.Layer_dz.values\n    profile.th_wp = pdf.th_wp.values\n    profile.th_fc = pdf.th_fc.values\n    profile.th_s = pdf.th_s.values\n\n    profile.Ksat = pdf.Ksat.values\n    profile.Penetrability = pdf.penetrability.values\n    profile.th_dry = pdf.th_dry.values\n    profile.tau = pdf.tau.values\n    profile.th_fc_Adj = pdf.th_fc_Adj.values\n\n    if param_struct.water_table == 1:\n        profile.aCR = pdf.aCR.values\n        profile.bCR = pdf.bCR.values\n    else:\n        profile.aCR = pdf.dz.values * 0.0\n        profile.bCR = pdf.dz.values * 0.0\n\n    # param_struct.Soil.profile = profile\n\n    param_struct.Soil.Profile = profile\n\n    return param_struct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.outputs_when_model_is_finished","title":"<code>outputs_when_model_is_finished(model_is_finished, flux_output, water_output, growth_outputs, steps_are_finished)</code>","text":"<p>Function that turns numpy array outputs into pandas dataframes</p> <p>Arguments:</p> <pre><code>model_is_finished (bool):  is model finished\n\nflux_output (numpy.array): water flux_output\n\nwater_output (numpy.array):  water storage in each compartment\n\ngrowth_outputs (numpy.array):  crop growth variables\n\nn_seasons (int):  total number of seasons being simulated\n\nsteps_are_finished (bool):  have the simulated num_steps finished\n</code></pre> <p>Returns:</p> <pre><code>flux_output (pandas.DataFrame): water flux_output\n\nwater_output (pandas.DataFrame):  water storage in each compartment\n\ngrowth_outputs (pandas.DataFrame):  crop growth variables\n</code></pre> Source code in <code>aquacrop/timestep/outputs_when_model_is_finished.py</code> <pre><code>def outputs_when_model_is_finished(\n    model_is_finished: bool,\n    flux_output: \"ndarray\",\n    water_output: \"ndarray\",\n    growth_outputs: \"ndarray\",\n    steps_are_finished: bool,\n):\n    \"\"\"\n    Function that turns numpy array outputs into pandas dataframes\n\n    Arguments:\n\n        model_is_finished (bool):  is model finished\n\n        flux_output (numpy.array): water flux_output\n\n        water_output (numpy.array):  water storage in each compartment\n\n        growth_outputs (numpy.array):  crop growth variables\n\n        n_seasons (int):  total number of seasons being simulated\n\n        steps_are_finished (bool):  have the simulated num_steps finished\n\n    Returns:\n\n        flux_output (pandas.DataFrame): water flux_output\n\n        water_output (pandas.DataFrame):  water storage in each compartment\n\n        growth_outputs (pandas.DataFrame):  crop growth variables\n\n\n    \"\"\"\n    if model_is_finished is True or steps_are_finished is True:\n        # ClockStruct.step_start_time = ClockStruct.step_end_time\n        # ClockStruct.step_end_time = ClockStruct.step_end_time + np.timedelta64(1, \"D\")\n        flux_output_df = pd.DataFrame(\n            flux_output,\n            columns=[\n                \"time_step_counter\",\n                \"season_counter\",\n                \"dap\",\n                \"Wr\",\n                \"z_gw\",\n                \"surface_storage\",\n                \"IrrDay\",\n                \"Infl\",\n                \"Runoff\",\n                \"DeepPerc\",\n                \"CR\",\n                \"GwIn\",\n                \"Es\",\n                \"EsPot\",\n                \"Tr\",\n                \"TrPot\",\n            ],\n        )\n\n        water_output_df = pd.DataFrame(\n            water_output,\n            columns=[\"time_step_counter\", \"growing_season\", \"dap\"]\n            + [\"th\" + str(i) for i in range(1, water_output.shape[1] - 2)],\n        )\n\n        growth_outputs_df = pd.DataFrame(\n            growth_outputs,\n            columns=[\n                \"time_step_counter\",\n                \"season_counter\",\n                \"dap\",\n                \"gdd\",\n                \"gdd_cum\",\n                \"z_root\",\n                \"canopy_cover\",\n                \"canopy_cover_ns\",\n                \"biomass\",\n                \"biomass_ns\",\n                \"harvest_index\",\n                \"harvest_index_adj\",\n                \"DryYield\",\n                \"FreshYield\",\n                \"YieldPot\",\n            ],\n        )\n\n        return flux_output_df, water_output_df, growth_outputs_df\n\n    return False\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.prepare_lars_weather","title":"<code>prepare_lars_weather(file, year, generated=True, order=['year', 'jday', 'minTemp', 'maxTemp', 'precip', 'rad'], wind_speed=3.4)</code>","text":"<p>Uses FAO-PM to calculate reference evapotranspiration for LARS generated and baseline input data.</p> Source code in <code>aquacrop/utils/lars.py</code> <pre><code>def prepare_lars_weather(\n    file,\n    year,\n    generated=True,\n    order=[\"year\", \"jday\", \"minTemp\", \"maxTemp\", \"precip\", \"rad\"],\n    wind_speed=3.4,\n):\n    \"\"\"\n    Uses FAO-PM to calculate reference evapotranspiration for LARS generated and baseline input data.\n\n    \"\"\"\n\n    def vap_pres(t):\n        return 0.6108 * np.exp((17.27 * t) / (t + 237.3))\n\n    df = pd.read_csv(file, sep='\\s+', header=None)\n\n    if generated:\n        df.columns = order\n        df[\"tdelta\"] = pd.to_timedelta(df.jday, unit=\"D\")\n        df[\"date\"] = pd.to_datetime(f\"{year-1}/12/31\") + df[\"tdelta\"]\n\n        psyc = 0.054  # sychometric constant\n        tmean = (df.maxTemp + df.minTemp) / 2\n        e_s = (vap_pres(df.maxTemp) + vap_pres(df.minTemp)) / 2\n        e_a = vap_pres(df.minTemp)\n        slope = 4098 * vap_pres(tmean) / (tmean + 237.3) ** 2\n        R_ns = (1 - 0.23) * df.rad\n        sb_const = 4.903e-9\n        R_nl = (\n            sb_const\n            * 0.5\n            * ((df.maxTemp + 273.15) ** 4 + (df.minTemp + 273.15) ** 4)\n            * (0.34 - 0.14 * (e_a) ** 0.5)\n            * (1.35 * 0.77 - 0.35)\n        )\n        Rn = R_ns - R_nl\n        u2 = wind_speed\n\n        eto = 0.408 * slope * Rn + (psyc * 900 * u2 * (e_s - e_a) / (tmean + 273)) / (\n            slope + psyc * (1 + 0.34 * u2)\n        )\n        df[\"eto\"] = eto\n\n        # df[\"eto\"] = df.rad*(0.0023)*(((df.maxTemp+df.minTemp)/2)+17.8)*(df.maxTemp-df.minTemp)**0.5\n        df.eto = df.eto.clip(0.1)\n        df = df[[\"simyear\", \"minTemp\", \"maxTemp\", \"precip\", \"eto\", \"date\"]]\n        df.columns = [\"simyear\", \"MinTemp\", \"MaxTemp\", \"Precipitation\", \"ReferenceET\", \"Date\"]\n\n    else:\n        df.columns = order\n        df[\"date\"] = pd.to_datetime(df.year, format=\"%Y\") + pd.to_timedelta(df.jday - 1, unit=\"d\")\n\n        psyc = 0.054  # sychometric constant\n        tmean = (df.maxTemp + df.minTemp) / 2\n        e_s = (vap_pres(df.maxTemp) + vap_pres(df.minTemp)) / 2\n        e_a = vap_pres(df.minTemp)\n        slope = 4098 * vap_pres(tmean) / (tmean + 237.3) ** 2\n        R_ns = (1 - 0.23) * df.rad\n        sb_const = 4.903e-9\n        R_nl = (\n            sb_const\n            * 0.5\n            * ((df.maxTemp + 273.15) ** 4 + (df.minTemp + 273.15) ** 4)\n            * (0.34 - 0.14 * (e_a) ** 0.5)\n            * (1.35 * 0.77 - 0.35)\n        )\n        Rn = R_ns - R_nl\n        u2 = wind_speed\n\n        eto = 0.408 * slope * Rn + (psyc * 900 * u2 * (e_s - e_a) / (tmean + 273)) / (\n            slope + psyc * (1 + 0.34 * u2)\n        )\n        df[\"eto\"] = eto\n\n        # df[\"eto\"] = df.rad*(0.0023)*(((df.maxTemp+df.minTemp)/2)+17.8)*(df.maxTemp-df.minTemp)**0.5\n        df.eto = df.eto.clip(0.1)\n        df = df[[\"minTemp\", \"maxTemp\", \"precip\", \"eto\", \"date\"]]\n        df.columns = [\"MinTemp\", \"MaxTemp\", \"Precipitation\", \"ReferenceET\", \"Date\"]\n\n    return df\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_clock_parameters","title":"<code>read_clock_parameters(sim_start_time, sim_end_time, off_season=False)</code>","text":"<p>Function to read in start and end simulation time and return a ClockStruct object</p> <p>Arguments:</p> <pre><code>sim_start_time (str): simulation start date\n\nsim_end_time (str): simulation start date\n\noff_season (bool): True, simulate off season\n                  False, skip ahead to next season post-harvest\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct): simulation time paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_clocks_parameters.py</code> <pre><code>def read_clock_parameters(\n    sim_start_time: str,\n    sim_end_time: str,\n    off_season: bool=False) -&gt; ClockStruct:\n    \"\"\"\n    Function to read in start and end simulation time and return a ClockStruct object\n\n    Arguments:\n\n        sim_start_time (str): simulation start date\n\n        sim_end_time (str): simulation start date\n\n        off_season (bool): True, simulate off season\n                          False, skip ahead to next season post-harvest\n\n    Returns:\n\n        clock_struct (ClockStruct): simulation time paramaters\n\n\n    \"\"\"\n    check_max_simulation_days(sim_start_time, sim_end_time)\n\n    # Extract data and put into pandas datetime format\n    pandas_sim_start_time = pd.to_datetime(sim_start_time)\n    pandas_sim_end_time = pd.to_datetime(sim_end_time)\n\n    # create ClockStruct object\n    clock_struct = ClockStruct()\n\n    # Add variables\n    clock_struct.simulation_start_date = pandas_sim_start_time\n    clock_struct.simulation_end_date = pandas_sim_end_time\n\n    clock_struct.n_steps = (pandas_sim_end_time - pandas_sim_start_time).days + 1\n    clock_struct.time_span = pd.date_range(\n        freq=\"D\", start=pandas_sim_start_time, end=pandas_sim_end_time\n    )\n\n    clock_struct.step_start_time = clock_struct.time_span[0]\n    clock_struct.step_end_time = clock_struct.time_span[1]\n\n    clock_struct.sim_off_season = off_season\n\n    return clock_struct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_field_management","title":"<code>read_field_management(ParamStruct, FieldMngt, FallowFieldMngt)</code>","text":"<p>store field management variables as FieldMngtStruct object</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\nFieldMngt (FieldMngt):  field mngt params\n\nFallowFieldMngt (FieldMngt): fallow field mngt params\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated ParamStruct with field management info\n</code></pre> Source code in <code>aquacrop/initialize/read_field_managment.py</code> <pre><code>def read_field_management(\n    ParamStruct: \"ParamStruct\",\n    FieldMngt: \"FieldMngt\",\n    FallowFieldMngt: \"FieldMngt\") -&gt; \"ParamStruct\":\n\n    \"\"\"\n    store field management variables as FieldMngtStruct object\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\n        FieldMngt (FieldMngt):  field mngt params\n\n        FallowFieldMngt (FieldMngt): fallow field mngt params\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated ParamStruct with field management info\n\n\n    \"\"\"\n\n    field_mngt_struct = FieldMngtStruct()\n    for a, v in FieldMngt.__dict__.items():\n        if hasattr(field_mngt_struct, a):\n            field_mngt_struct.__setattr__(a, v)\n\n    fallow_field_mngt_struct = FieldMngtStruct()\n    for a, v in FallowFieldMngt.__dict__.items():\n        if hasattr(fallow_field_mngt_struct, a):\n            fallow_field_mngt_struct.__setattr__(a, v)\n\n    ParamStruct.FieldMngt = field_mngt_struct\n    ParamStruct.FallowFieldMngt = fallow_field_mngt_struct\n\n    return ParamStruct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_groundwater_table","title":"<code>read_groundwater_table(ParamStruct, GwStruct, ClockStruct)</code>","text":"<p>Function to initialise groundwater parameters</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct): Contains model paramaters\n\nGwStruct (GroundWater): groundwater params\n\nClockStruct (ClockStruct): time params\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct): updated with GW info\n</code></pre> Source code in <code>aquacrop/initialize/read_groundwater_table.py</code> <pre><code>def read_groundwater_table(\n    ParamStruct: \"ParamStruct\",\n    GwStruct: \"GroundWater\",\n    ClockStruct: \"ClockStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    Function to initialise groundwater parameters\n\n    Arguments:\n\n        ParamStruct (ParamStruct): Contains model paramaters\n\n        GwStruct (GroundWater): groundwater params\n\n        ClockStruct (ClockStruct): time params\n\n    Returns:\n\n        ParamStruct (ParamStruct): updated with GW info\n\n    \"\"\"\n\n    # assign water table value and method\n    WT = GwStruct.water_table\n    WTMethod = GwStruct.method\n\n    # check if water table present\n    if WT == \"N\":\n        ParamStruct.water_table = 0\n        ParamStruct.z_gw = 999 * np.ones(len(ClockStruct.time_span))\n        ParamStruct.zGW_dates = ClockStruct.time_span\n        ParamStruct.WTMethod = \"None\"\n    elif WT == \"Y\":\n        ParamStruct.water_table = 1\n\n        df = pd.DataFrame([GwStruct.dates, GwStruct.values]).T\n        df.columns = [\"Date\", \"Depth(mm)\"]\n\n        # get date in correct format\n        df.Date = pd.DatetimeIndex(df.Date)\n        # print(f'DF length: {len(df)}')\n        # print(f'Index length: {len(df.index)}')\n\n        if len(df) == 1:\n\n            # if only 1 watertable depth then set that value to be constant\n            # accross whole simulation            \n            z_gw = pd.DataFrame(\n                data=df[\"Depth(mm)\"].iloc[0]*np.ones(len(ClockStruct.time_span)),\n                index=pd.to_datetime(ClockStruct.time_span),\n                columns=['Depth(mm)']\n            )['Depth(mm)']\n\n        elif len(df) &gt; 1:\n            # check water table method\n            if WTMethod == \"Constant\":\n\n                # No interpolation between dates\n\n                # create daily depths for each simulation day\n                z_gw = pd.Series(\n                    np.nan * np.ones(len(ClockStruct.time_span)), index=ClockStruct.time_span\n                )\n\n                # assign constant depth for all dates in between\n                for row in range(len(df)):\n                    date = df.Date.iloc[row]\n                    depth = df[\"Depth(mm)\"].iloc[row]\n                    z_gw.loc[z_gw.index &gt;= date] = depth\n                    if row == 0:\n                        z_gw.loc[z_gw.index &lt;= date] = depth\n\n            elif WTMethod == \"Variable\":\n\n                # Linear interpolation between dates\n\n                # create daily depths for each simulation day\n                # fill unspecified days with NaN\n                z_gw = pd.Series(\n                    np.nan * np.ones(len(ClockStruct.time_span)), index=ClockStruct.time_span\n                )\n\n                for row in range(len(df)):\n                    date = df.Date.iloc[row]\n                    depth = df[\"Depth(mm)\"].iloc[row]\n                    z_gw.loc[date] = depth\n\n                # Interpolate daily groundwater depths\n                z_gw = z_gw.interpolate()\n\n        # assign values to Paramstruct object\n        ParamStruct.z_gw = z_gw.values\n        ParamStruct.zGW_dates = z_gw.index.values\n        ParamStruct.WTMethod = WTMethod\n\n    return ParamStruct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_irrigation_management","title":"<code>read_irrigation_management(ParamStruct, IrrMngt, ClockStruct)</code>","text":"<p>initilize irrigation management and store as IrrMngtStruct object</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\nIrrMngt (IrrigationManagement):  irr mngt params object\n\nClockStruct (ClockStruct):  time paramaters\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated model paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_irrigation_management.py</code> <pre><code>def read_irrigation_management(\n    ParamStruct: \"ParamStruct\",\n    IrrMngt: \"IrrigationManagement\",\n    ClockStruct: \"ClockStruct\") -&gt; \"ParamStruct\":\n    \"\"\"\n    initilize irrigation management and store as IrrMngtStruct object\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model crop and soil paramaters\n\n        IrrMngt (IrrigationManagement):  irr mngt params object\n\n        ClockStruct (ClockStruct):  time paramaters\n\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated model paramaters\n\n\n\n    \"\"\"\n    # If specified, read input irrigation time-series\n    if IrrMngt.irrigation_method == 3:\n\n        df = IrrMngt.Schedule.copy()\n        # change the index to the date\n        df.index = pd.DatetimeIndex(df.Date)\n\n        try:\n            # create a dateframe containing the daily irrigation to\n            # be applied for every day in the simulation\n            df = df.reindex(ClockStruct.time_span, fill_value=0).drop(\"Date\", axis=1)\n\n            IrrMngt.Schedule = np.array(df.values, dtype=float).flatten()\n\n        except TypeError:\n            # older version of pandas with not reindex\n\n            # create new dataframe for whole simulation\n            # populate new dataframe with old values\n            new_df = pd.DataFrame(data=np.zeros(len(ClockStruct.time_span)),\n                index=pd.to_datetime(ClockStruct.time_span),\n                columns=['Depth']\n                )\n\n            # fill in the new dataframe with irrigation schedule\n            new_df.loc[df.index]=df.Depth.values\n\n            IrrMngt.Schedule = np.array(new_df.values, dtype=float).flatten()\n\n    else:\n\n        IrrMngt.Schedule = np.zeros(len(ClockStruct.time_span))\n\n    IrrMngt.SMT = np.array(IrrMngt.SMT, dtype=float)\n\n    irr_mngt_struct = IrrMngtStruct(len(ClockStruct.time_span))\n    for a, v in IrrMngt.__dict__.items():\n        if hasattr(irr_mngt_struct, a):\n            irr_mngt_struct.__setattr__(a, v)\n\n    ParamStruct.IrrMngt = irr_mngt_struct\n    ParamStruct.FallowIrrMngt = IrrMngtStruct(len(ClockStruct.time_span))\n\n    return ParamStruct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_model_initial_conditions","title":"<code>read_model_initial_conditions(ParamStruct, ClockStruct, InitWC, crop)</code>","text":"<p>Function to set up initial model conditions</p> <p>Arguments:</p> <pre><code>ParamStruct (ParamStruct):  Contains model paramaters\n\nClockStruct (ClockStruct):  time paramaters\n\nInitWC (InitialWaterContent):  initial water content\n\ncrop (Crop): crop parameters\n</code></pre> <p>Returns:</p> <pre><code>ParamStruct (ParamStruct):  updated ParamStruct object\n\nInitCond (InitialCondition):  containing initial model conditions/counters\n</code></pre> Source code in <code>aquacrop/initialize/read_model_initial_conditions.py</code> <pre><code>def read_model_initial_conditions(\n    ParamStruct: \"ParamStruct\",\n    ClockStruct: \"ClockStruct\",\n    InitWC: \"InitialWaterContent\",\n    crop: \"Crop\") -&gt; Tuple[\"ParamStruct\", \"InitialCondition\"]:\n    \"\"\"\n    Function to set up initial model conditions\n\n    Arguments:\n\n        ParamStruct (ParamStruct):  Contains model paramaters\n\n        ClockStruct (ClockStruct):  time paramaters\n\n        InitWC (InitialWaterContent):  initial water content\n\n        crop (Crop): crop parameters\n\n\n    Returns:\n\n        ParamStruct (ParamStruct):  updated ParamStruct object\n\n        InitCond (InitialCondition):  containing initial model conditions/counters\n\n    \"\"\"\n\n    ###################\n    # creat initial condition class\n    ###################\n\n    InitCond = InitialCondition(len(ParamStruct.Soil.profile))\n\n    # class_args = {key:value for key, value in InitCond_class.__dict__.items() if not key.startswith('__') and not callable(key)}\n    # InitCond = InitCondStruct(**class_args)\n\n    if ClockStruct.season_counter == -1:\n        InitCond.z_root = 0.\n        InitCond.cc0_adj = 0.\n\n    elif ClockStruct.season_counter == 0:\n        InitCond.z_root = ParamStruct.Seasonal_Crop_List[0].Zmin\n        InitCond.cc0_adj = ParamStruct.Seasonal_Crop_List[0].CC0\n\n    # Set HIfinal to crop's reference harvest index\n    InitCond.HIfinal = crop.HI0\n\n    ##################\n    # save field management\n    ##################\n\n    # Initial surface storage between any soil bunds\n    if ClockStruct.season_counter == -1:\n        # First day of simulation is in fallow period\n        if (ParamStruct.FallowFieldMngt.bunds) and (\n            float(ParamStruct.FallowFieldMngt.z_bund) &gt; 0.001\n        ):\n            # Get initial storage between surface bunds\n            InitCond.surface_storage = float(ParamStruct.FallowFieldMngt.bund_water)\n            if InitCond.surface_storage &gt; float(ParamStruct.FallowFieldMngt.z_bund):\n                InitCond.surface_storage = float(ParamStruct.FallowFieldMngt.z_bund)\n        else:\n            # No surface bunds\n            InitCond.surface_storage = 0\n\n    elif ClockStruct.season_counter == 0:\n        # First day of simulation is in first growing season\n        # Get relevant field management structure parameters\n        FieldMngtTmp = ParamStruct.FieldMngt\n        if (FieldMngtTmp.bunds) and (float(FieldMngtTmp.z_bund) &gt; 0.001):\n            # Get initial storage between surface bunds\n            InitCond.surface_storage = float(FieldMngtTmp.bund_water)\n            if InitCond.surface_storage &gt; float(FieldMngtTmp.z_bund):\n                InitCond.surface_storage = float(FieldMngtTmp.z_bund)\n        else:\n            # No surface bunds\n            InitCond.surface_storage = 0\n\n    ############\n    # watertable\n    ############\n\n    profile = ParamStruct.Soil.profile\n\n    # Check for presence of groundwater table\n    if ParamStruct.water_table == 0:  # No water table present\n        # Set initial groundwater level to dummy value\n        InitCond.z_gw = ModelConstants.NO_VALUE\n        InitCond.wt_in_soil = False\n        # Set adjusted field capacity to default field capacity\n        InitCond.th_fc_Adj = profile.th_fc.values\n    elif ParamStruct.water_table == 1:  # Water table is present\n        # Set initial groundwater level\n        InitCond.z_gw = float(ParamStruct.z_gw[ClockStruct.time_step_counter])\n        # Find compartment mid-points\n        zMid = profile.zMid\n        # Check if water table is within modelled soil profile\n        if InitCond.z_gw &gt;= 0:\n            idx = zMid[zMid &gt;= InitCond.z_gw].index\n            if idx.shape[0] == 0:\n                InitCond.wt_in_soil = False\n            else:\n                InitCond.wt_in_soil = True\n        else:\n            InitCond.wt_in_soil = False\n\n        # Adjust compartment field capacity\n        compi = int(len(profile)) - 1\n        thfcAdj = np.zeros(compi + 1)\n        while compi &gt;= 0:\n            # get soil layer of compartment\n            compdf = profile.loc[compi]\n            if compdf.th_fc &lt;= 0.1:\n                Xmax = 1\n            else:\n                if compdf.th_fc &gt;= 0.3:\n                    Xmax = 2\n                else:\n                    pF = 2 + 0.3 * (compdf.th_fc - 0.1) / 0.2\n                    Xmax = (np.exp(pF * np.log(10))) / 100\n\n            if (InitCond.z_gw &lt; 0) or ((InitCond.z_gw - zMid.iloc[compi]) &gt;= Xmax):\n                for ii in range(compi+1):\n                    compdfii = profile.loc[ii]\n                    thfcAdj[ii] = compdfii.th_fc\n\n                compi = -1\n            else:\n                if compdf.th_fc &gt;= compdf.th_s:\n                    thfcAdj[compi] = compdf.th_fc\n                else:\n                    if zMid.iloc[compi] &gt;= InitCond.z_gw:\n                        thfcAdj[compi] = compdf.th_s\n                    else:\n                        dV = compdf.th_s - compdf.th_fc\n                        dFC = (dV / (Xmax ** 2)) * ((zMid.iloc[compi] - (InitCond.z_gw - Xmax)) ** 2)\n                        thfcAdj[compi] = compdf.th_fc + dFC\n\n                compi = compi - 1\n\n        # Store adjusted field capacity values\n        InitCond.th_fc_Adj = np.round(thfcAdj, 3)\n\n    profile[\"th_fc_Adj\"] = np.round(InitCond.th_fc_Adj, 3)\n\n    # create hydrology df to group by layer instead of compartment\n    ParamStruct.Soil.Hydrology = profile.groupby(\"Layer\").mean().drop([\"dz\", \"dzsum\"], axis=1)\n    ParamStruct.Soil.Hydrology[\"dz\"] = profile.groupby(\"Layer\").sum().dz\n\n    ###################\n    # initial water contents\n    ###################\n\n    typestr = InitWC.wc_type\n    methodstr = InitWC.method\n\n    depth_layer = InitWC.depth_layer\n    datapoints = InitWC.value\n\n    values = np.zeros(len(datapoints))\n\n    hydf = ParamStruct.Soil.Hydrology\n\n    # Assign data\n    if typestr == \"Num\":\n        # Values are defined as numbers (m3/m3) so no calculation required\n        depth_layer = np.array(depth_layer, dtype=float)\n        values = np.array(datapoints, dtype=float)\n\n    elif typestr == \"Pct\":\n        # Values are defined as percentage of taw. Extract and assign value for\n        # each soil layer based on calculated/input soil hydraulic properties\n        depth_layer = np.array(depth_layer, dtype=float)\n        datapoints = np.array(datapoints, dtype=float)\n\n        for ii in range(len(values)):\n            if methodstr == \"Depth\":\n                depth = depth_layer[ii]\n                value = datapoints[ii]\n\n                # Find layer at specified depth\n                if depth &lt; profile.dzsum.iloc[-1]:\n                    layer = profile.query(f\"{depth}&lt;dzsum\").Layer.iloc[0]\n                else:\n                    layer = profile.Layer.iloc[-1]\n\n                compdf = hydf.loc[layer]\n\n                # Calculate moisture content at specified depth\n                values[ii] = compdf.th_wp + ((value / 100) * (compdf.th_fc - compdf.th_wp))\n            elif methodstr == \"Layer\":\n                # Calculate moisture content at specified layer\n                layer = depth_layer[ii]\n                value = datapoints[ii]\n\n                compdf = hydf.loc[layer]\n\n                values[ii] = compdf.th_wp + ((value / 100) * (compdf.th_fc - compdf.th_wp))\n\n    elif typestr == \"Prop\":\n        # Values are specified as soil hydraulic properties (SAT, FC, or WP).\n        # Extract and assign value for each soil layer\n        depth_layer = np.array(depth_layer, dtype=float)\n        datapoints = np.array(datapoints, dtype=str)\n\n        for ii in range(len(values)):\n            if methodstr == \"Depth\":\n                # Find layer at specified depth\n                depth = depth_layer[ii]\n                value = datapoints[ii]\n\n                # Find layer at specified depth\n                if depth &lt; profile.dzsum.iloc[-1]:\n                    layer = profile.query(f\"{depth}&lt;dzsum\").Layer.iloc[0]\n                else:\n                    layer = profile.Layer.iloc[-1]\n\n                compdf = hydf.loc[layer]\n\n                # Calculate moisture content at specified depth\n                if value == \"SAT\":\n                    values[ii] = compdf.th_s\n                if value == \"FC\":\n                    values[ii] = compdf.th_fc\n                if value == \"WP\":\n                    values[ii] = compdf.th_wp\n\n            elif methodstr == \"Layer\":\n                # Calculate moisture content at specified layer\n                layer = depth_layer[ii]\n                value = datapoints[ii]\n\n                compdf = hydf.loc[layer]\n\n                if value == \"SAT\":\n                    values[ii] = compdf.th_s\n                if value == \"FC\":\n                    values[ii] = compdf.th_fc\n                if value == \"WP\":\n                    values[ii] = compdf.th_wp\n\n    # Interpolate values to all soil compartments\n\n    thini = np.zeros(int(profile.shape[0]))\n    if methodstr == \"Layer\":\n        for ii in range(len(values)):\n            layer = depth_layer[ii]\n            value = values[ii]\n\n            idx = profile.query(f\"Layer=={int(layer)}\").index\n\n            thini[idx] = value\n\n        InitCond.th = thini\n\n    elif methodstr == \"Depth\":\n        depths = depth_layer\n\n        # Add zero point\n        if depths[0] &gt; 0:\n            depths = np.append([0], depths)\n            values = np.append([values[0]], values)\n\n        # Add end point (bottom of soil profile)\n        if depths[-1] &lt; ParamStruct.Soil.zSoil:\n            depths = np.append(depths, [ParamStruct.Soil.zSoil])\n            values = np.append(values, [values[-1]])\n\n        # Find centroids of compartments\n        SoilDepths = profile.dzsum.values\n        comp_top = np.append([0], SoilDepths[:-1])\n        comp_bot = SoilDepths\n        comp_mid = (comp_top + comp_bot) / 2\n        # Interpolate initial water contents to each compartment\n        thini = np.interp(comp_mid, depths, values)\n        InitCond.th = thini\n\n    # If groundwater table is present and calculating water contents based on\n    # field capacity, then reset value to account for possible changes in field\n    # capacity caused by capillary rise effects\n    if ParamStruct.water_table == 1:\n        if (typestr == \"Prop\") and (datapoints[-1] == \"FC\"):\n            InitCond.th = InitCond.th_fc_Adj\n\n    # If groundwater table is present in soil profile then set all water\n    # contents below the water table to saturation\n    if InitCond.wt_in_soil is True:\n        # Find compartment mid-points\n        SoilDepths = profile.dzsum.values\n        comp_top = np.append([0], SoilDepths[:-1])\n        comp_bot = SoilDepths\n        comp_mid = (comp_top + comp_bot) / 2\n        idx = np.where(comp_mid &gt;= InitCond.z_gw)[0][0]\n        for ii in range(idx, len(profile)):\n            layeri = profile.loc[ii].Layer\n            InitCond.th[ii] = hydf.th_s.loc[layeri]\n\n    InitCond.thini = InitCond.th\n\n    ParamStruct.Soil.profile = profile\n    ParamStruct.Soil.Hydrology = hydf\n\n    return ParamStruct, InitCond\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_model_parameters","title":"<code>read_model_parameters(clock_struct, soil, crop, weather_df)</code>","text":"<p>Finalise soil and crop paramaters including planting and harvest dates save to new object param_struct</p> <p>Arguments:</p> <pre><code>clock_struct (ClockStruct):  time params\n\nsoil (Soil):  soil object\n\ncrop (Crop):  crop object\n\nweather_df (DataFrame): list of datetimes\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct): updated time paramaters\n\nparam_struct (ParamStruct):  Contains model crop and soil paramaters\n</code></pre> Source code in <code>aquacrop/initialize/read_model_parameters.py</code> <pre><code>def read_model_parameters(\n    clock_struct: \"ClockStruct\",\n    soil: \"Soil\",\n    crop: \"Crop\",\n    weather_df: \"DataFrame\"):\n\n    \"\"\"\n    Finalise soil and crop paramaters including planting and harvest dates\n    save to new object param_struct\n\n\n    Arguments:\n\n        clock_struct (ClockStruct):  time params\n\n        soil (Soil):  soil object\n\n        crop (Crop):  crop object\n\n        weather_df (DataFrame): list of datetimes\n\n    Returns:\n\n        clock_struct (ClockStruct): updated time paramaters\n\n        param_struct (ParamStruct):  Contains model crop and soil paramaters\n\n    \"\"\"\n    # create param_struct object\n    param_struct = ParamStruct()\n\n    soil.fill_nan()\n\n    # Assign soil object to param_struct\n    param_struct.Soil = soil\n\n    while soil.zSoil &lt; crop.Zmax + 0.1:\n        for i in soil.profile.index[::-1]:\n            if soil.profile.loc[i, \"dz\"] &lt; 0.25:\n                soil.profile.loc[i, \"dz\"] += 0.1\n                soil.fill_nan()\n                break\n\n    # TODO: Why all these commented lines? The model does not allow rotations now?\n    ###########\n    # crop\n    ###########\n\n    #     if isinstance(crop, Iterable):\n    #         cropList=list(crop)\n    #     else:\n    #         cropList = [crop]\n\n    #     # assign variables to paramstruct\n    #     paramStruct.nCrops = len(cropList)\n    #     if paramStruct.nCrops &gt; 1:\n    #         paramStruct.SpecifiedPlantcalendar = 'yield_'\n    #     else:\n    #         paramStruct.SpecifiedPlantcalendar = 'N'\n\n    #     # add crop list to paramStruct\n    #     paramStruct.cropList = cropList\n\n    ############################\n    # plant and harvest times\n    ############################\n\n    #     # find planting and harvest dates\n    #     # check if there is more than 1 crop or multiple plant dates in sim year\n    #     if paramStruct.SpecifiedPlantcalendar == \"yield_\":\n    #         # if here than crop rotation occours during same period\n\n    #         # create variables from dataframe\n    #         plantingDates = pd.to_datetime(planting_dates)\n    #         harvestDates = pd.to_datetime(harvest_dates)\n\n    #         if (paramStruct.nCrops &gt; 1):\n\n    #             cropChoices = [crop.name for crop in paramStruct.cropList]\n\n    #         assert len(cropChoices) == len(plantingDates) == len(harvestDates)\n\n    # elif paramStruct.nCrops == 1:\n    # Only one crop type considered during simulation - i.e. no rotations\n    # either within or between years\n    crop_list = [crop]\n    param_struct.CropList = crop_list\n    param_struct.NCrops = 1\n\n    # Get start and end years for full simulation\n    sim_start_date = clock_struct.simulation_start_date\n    sim_end_date = clock_struct.simulation_end_date\n\n    if crop.harvest_date is None:\n        crop = compute_crop_calendar(\n            crop,\n            clock_struct.planting_dates,\n            clock_struct.simulation_start_date,\n            clock_struct.simulation_end_date,\n            clock_struct.time_span,\n            weather_df,\n        )\n        mature = int(crop.MaturityCD + 30)\n        plant = pd.to_datetime(\"1990/\" + crop.planting_date)\n        harv = plant + np.timedelta64(mature, \"D\")\n        new_harvest_date = str(harv.month) + \"/\" + str(harv.day)\n        crop.harvest_date = new_harvest_date\n\n    # extract years from simulation start and end date\n    start_end_years = [sim_start_date.year, sim_end_date.year]\n\n    # check if crop growing season runs over calander year\n    # Planting and harvest dates are in days/months format so just add arbitrary year\n    single_year = pd.to_datetime(\"1990/\" + crop.planting_date) &lt; pd.to_datetime(\n        \"1990/\" + crop.harvest_date\n    )\n\n    if single_year:\n        # if normal year\n\n        # Check if the simulation in the following year does not exceed planting date.\n        mock_simulation_end_date = pd.to_datetime(\"1990/\" + f'{sim_end_date.month}' + \"/\" + f'{sim_end_date.day}')\n        mock_simulation_start_date = pd.to_datetime(\"1990/\" + crop.planting_date)\n        last_simulation_year_does_not_start = mock_simulation_end_date &lt;= mock_simulation_start_date\n\n        if last_simulation_year_does_not_start:\n            start_end_years[1] = start_end_years[1] - 1\n\n        # specify the planting and harvest years as normal\n        plant_years = list(range(start_end_years[0], start_end_years[1] + 1))\n        harvest_years = plant_years\n    else:\n        # if it takes over a year then the plant year finishes 1 year before end of sim\n        # and harvest year starts 1 year after sim start\n\n        if (\n            pd.to_datetime(str(start_end_years[1] + 2) + \"/\" + crop.harvest_date)\n            &lt; sim_end_date\n        ):\n\n            # specify shifted planting and harvest years\n            plant_years = list(range(start_end_years[0], start_end_years[1] + 1))\n            harvest_years = list(range(start_end_years[0] + 1, start_end_years[1] + 2))\n        else:\n\n            plant_years = list(range(start_end_years[0], start_end_years[1]))\n            harvest_years = list(range(start_end_years[0] + 1, start_end_years[1] + 1))\n\n    # Correct for partial first growing season (may occur when simulating\n    # off-season soil water balance)\n    if (\n        pd.to_datetime(str(plant_years[0]) + \"/\" + crop.planting_date)\n        &lt; clock_struct.simulation_start_date\n    ):\n        # shift everything by 1 year\n        plant_years = plant_years[1:]\n        harvest_years = harvest_years[1:]\n\n    # ensure number of planting and harvest years are the same\n    assert len(plant_years) == len(harvest_years)\n\n    # create lists to hold variables\n    planting_dates = []\n    harvest_dates = []\n    crop_choices = []\n\n    # save full harvest/planting dates and crop choices to lists\n    for i, _ in enumerate(plant_years):\n        planting_dates.append(\n            str(plant_years[i]) + \"/\" + param_struct.CropList[0].planting_date\n        )\n        harvest_dates.append(\n            str(harvest_years[i]) + \"/\" + param_struct.CropList[0].harvest_date\n        )\n        crop_choices.append(param_struct.CropList[0].Name)\n\n    # save crop choices\n    param_struct.CropChoices = list(crop_choices)\n\n    # save clock paramaters\n    clock_struct.planting_dates = pd.to_datetime(planting_dates)\n    clock_struct.harvest_dates = pd.to_datetime(harvest_dates)\n    clock_struct.n_seasons = len(planting_dates)\n\n    # Initialise growing season counter\n    if pd.to_datetime(clock_struct.step_start_time) == clock_struct.planting_dates[0]:\n        clock_struct.season_counter = 0\n    else:\n        clock_struct.season_counter = -1\n\n    # return the FileLocations object as i have added some elements\n    return clock_struct, param_struct\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.read_weather_inputs","title":"<code>read_weather_inputs(clock_sctruct, weather_df)</code>","text":"<p>Clip weather to start and end simulation dates</p> <p>Arguments:</p> <pre><code>clock_sctruct (ClockStruct): ClockStruct object\n\nweather_df (DataFrame): weather dataframe\n</code></pre> <p>Returns:</p> <pre><code>weather_df (DataFrame): clipped weather dataframe\n</code></pre> Source code in <code>aquacrop/initialize/read_weather_inputs.py</code> <pre><code>def read_weather_inputs(\n    clock_sctruct: \"ClockStruct\",\n    weather_df: \"DataFrame\") -&gt; \"DataFrame\":\n    \"\"\"\n    Clip weather to start and end simulation dates\n\n    Arguments:\n\n        clock_sctruct (ClockStruct): ClockStruct object\n\n        weather_df (DataFrame): weather dataframe\n\n    Returns:\n\n        weather_df (DataFrame): clipped weather dataframe\n\n    \"\"\"\n\n    # get the start and end dates of simulation\n    start_date = clock_sctruct.simulation_start_date\n    end_date = clock_sctruct.simulation_end_date\n\n    if weather_df.Date.iloc[0] &gt; start_date:\n        raise ValueError(\n            \"The first date of the climate data cannot be longer than the start date of the model.\"\n        )\n\n    if weather_df.Date.iloc[-1] &lt; end_date:\n        raise ValueError(\n            \"The model end date cannot be longer than the last date of climate data.\"\n        )\n\n    # remove weather data outside of simulation dates\n    weather_df = weather_df[weather_df.Date &gt;= start_date]\n    weather_df = weather_df[weather_df.Date &lt;= end_date]\n\n    return weather_df\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.solution_single_time_step","title":"<code>solution_single_time_step(init_cond, param_struct, clock_struct, weather_step, outputs)</code>","text":"<p>Function to perform AquaCrop solution for a single time step</p> <p>Arguments:</p> <pre><code>init_cond (InitialCondition):  containing current variables+counters\n\nparam_struct (ParamStruct):  contains model paramaters\n\nclock_struct (ClockStruct):  model time paramaters\n\nweather_step (numpy.ndarray):  contains precipitation,ET,temp_max,temp_min for current day\n\noutputs (Output):  object to store outputs\n</code></pre> <p>Returns:</p> <pre><code>NewCond (InitialCondition):  containing updated simulation variables+counters\n\nparam_struct (ParamStruct):  contains model paramaters\n\noutputs (Output):  object to store outputs\n</code></pre> Source code in <code>aquacrop/timestep/run_single_timestep.py</code> <pre><code>def solution_single_time_step(\n    init_cond: \"InitialCondition\",\n    param_struct: \"ParamStruct\",\n    clock_struct: \"ClockStruct\",\n    weather_step: \"ndarray\",\n    outputs:\"Output\",\n) -&gt;  Tuple[\"InitialCondition\", \"ParamStruct\",\"Output\"]:\n    \"\"\"\n    Function to perform AquaCrop solution for a single time step\n\n    Arguments:\n\n        init_cond (InitialCondition):  containing current variables+counters\n\n        param_struct (ParamStruct):  contains model paramaters\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        weather_step (numpy.ndarray):  contains precipitation,ET,temp_max,temp_min for current day\n\n        outputs (Output):  object to store outputs\n\n    Returns:\n\n        NewCond (InitialCondition):  containing updated simulation variables+counters\n\n        param_struct (ParamStruct):  contains model paramaters\n\n        outputs (Output):  object to store outputs\n\n    \"\"\"\n\n    # Unpack structures\n    Soil = param_struct.Soil\n    CO2 = param_struct.CO2\n    precipitation = weather_step[2]\n    temp_max = weather_step[1]\n    temp_min = weather_step[0]\n    et0 = weather_step[3]\n\n    # Store initial conditions in structure for updating %%\n    NewCond = init_cond\n    if param_struct.water_table == 1:\n        GroundWater = param_struct.z_gw[clock_struct.time_step_counter]\n    else:\n        GroundWater = 0\n\n    # Check if growing season is active on current time step %%\n    if clock_struct.season_counter &gt;= 0:\n        # Check if in growing season\n        CurrentDate = clock_struct.step_start_time\n        planting_date = clock_struct.planting_dates[clock_struct.season_counter]\n        harvest_date = clock_struct.harvest_dates[clock_struct.season_counter]\n\n        if (\n            (planting_date &lt;= CurrentDate)\n            and (harvest_date &gt;= CurrentDate)\n            and (NewCond.crop_mature is False)\n            and (NewCond.crop_dead is False)\n        ):\n            growing_season = True\n        else:\n            growing_season = False\n        # Assign crop, irrigation management, and field management structures\n        Crop_ = param_struct.Seasonal_Crop_List[clock_struct.season_counter]\n        Crop_Name = param_struct.CropChoices[clock_struct.season_counter]\n        IrrMngt = param_struct.IrrMngt\n\n        if growing_season is True:\n            FieldMngt = param_struct.FieldMngt\n        else:\n            FieldMngt = param_struct.FallowFieldMngt\n\n    else:\n        # Not yet reached start of first growing season\n        growing_season = False\n        # Assign crop, irrigation management, and field management structures\n        # Assign first crop as filler crop\n        Crop_ = param_struct.Fallow_Crop\n        Crop_Name = \"fallow\"\n\n        Crop_.Aer = 5\n        Crop_.Zmin = 0.3\n        IrrMngt = param_struct.FallowIrrMngt\n        FieldMngt = param_struct.FallowFieldMngt\n\n    # Increment time counters %%\n    if growing_season is True:\n        # Calendar days after planting\n        NewCond.dap = NewCond.dap + 1\n        # Growing degree days after planting\n        gdd = growing_degree_day(\n            Crop_.GDDmethod, Crop_.Tupp, Crop_.Tbase, temp_max, temp_min\n        )\n\n        # Update cumulative gdd counter\n        NewCond.gdd = gdd\n        NewCond.gdd_cum = NewCond.gdd_cum + gdd\n\n        NewCond.growing_season = True\n    else:\n        NewCond.growing_season = False\n\n        # Calendar days after planting\n        NewCond.dap = 0\n        # Growing degree days after planting\n        gdd = 0.3\n        NewCond.gdd_cum = 0\n\n    # save current timestep counter\n    NewCond.time_step_counter = clock_struct.time_step_counter\n    NewCond.precipitation = weather_step[2]\n    NewCond.temp_max = weather_step[1]\n    NewCond.temp_min = weather_step[0]\n    NewCond.et0 = weather_step[3]\n\n    crop = Crop_\n\n    # Run simulations %%\n    # 1. Check for groundwater table\n    NewCond.th_fc_Adj, NewCond.wt_in_soil, NewCond.z_gw = check_groundwater_table(\n        Soil.Profile,\n        NewCond.z_gw,\n        NewCond.th,\n        NewCond.th_fc_Adj,\n        param_struct.water_table,\n        GroundWater\n    )\n\n    # 2. Root development\n    NewCond.z_root, NewCond.r_cor = root_development(\n        crop,\n        Soil.Profile,\n        NewCond.dap,\n        NewCond.z_root,\n        NewCond.delayed_cds,\n        NewCond.gdd_cum,\n        NewCond.delayed_gdds,\n        NewCond.tr_ratio,\n        NewCond.th,\n        NewCond.canopy_cover,\n        NewCond.canopy_cover_ns,\n        NewCond.germination,\n        NewCond.r_cor,\n        NewCond.t_pot,\n        NewCond.z_gw,\n        gdd,\n        growing_season,\n        param_struct.water_table,\n    )\n\n    # 3. Pre-irrigation\n    NewCond, PreIrr = pre_irrigation(\n        Soil.Profile, crop, NewCond, growing_season, IrrMngt\n    )\n\n    # 4. Drainage\n\n    NewCond.th, DeepPerc, FluxOut = drainage(\n        Soil.Profile,\n        NewCond.th,\n        NewCond.th_fc_Adj,\n    )\n\n    # 5. Surface runoff\n    Runoff, Infl, NewCond.day_submerged = rainfall_partition(\n        precipitation,\n        NewCond.th,\n        NewCond.day_submerged,\n        FieldMngt.sr_inhb,\n        FieldMngt.bunds,\n        FieldMngt.z_bund,\n        FieldMngt.curve_number_adj_pct,\n        Soil.cn,\n        Soil.adj_cn,\n        Soil.z_cn,\n        Soil.nComp,\n        Soil.Profile,\n    )\n\n    # 6. Irrigation\n    NewCond.depletion, NewCond.taw, NewCond.irr_cum, Irr = irrigation(\n        IrrMngt.irrigation_method,\n        IrrMngt.SMT,\n        IrrMngt.AppEff,\n        IrrMngt.MaxIrr,\n        IrrMngt.IrrInterval,\n        IrrMngt.Schedule,\n        IrrMngt.depth,\n        IrrMngt.MaxIrrSeason,\n        NewCond.growth_stage,\n        NewCond.irr_cum,\n        NewCond.e_pot,\n        NewCond.t_pot,\n        NewCond.z_root,\n        NewCond.th,\n        NewCond.dap,\n        NewCond.time_step_counter,\n        crop,\n        Soil.Profile,\n        Soil.z_top,\n        growing_season,\n        precipitation,\n        Runoff,\n    )\n\n    # 7. Infiltration\n    (\n        NewCond.th,\n        NewCond.surface_storage,\n        DeepPerc,\n        Runoff,\n        Infl,\n        FluxOut,\n    ) = infiltration(\n        Soil.Profile,\n        NewCond.surface_storage,\n        NewCond.th_fc_Adj,\n        NewCond.th,\n        Infl,\n        Irr,\n        IrrMngt.AppEff,\n        FieldMngt.bunds,\n        FieldMngt.z_bund,\n        FluxOut,\n        DeepPerc,\n        Runoff,\n        growing_season,\n    )\n    # 8. Capillary Rise\n    NewCond, CR = capillary_rise(\n        Soil.Profile,\n        Soil.nLayer,\n        Soil.fshape_cr,\n        NewCond,\n        FluxOut,\n        param_struct.water_table,\n    )\n\n    # 9. Check germination\n    NewCond = germination(\n        NewCond,\n        Soil.z_germ,\n        Soil.Profile,\n        crop.GermThr,\n        crop.PlantMethod,\n        gdd,\n        growing_season,\n    )\n\n    # 10. Update growth stage\n    NewCond = growth_stage(crop, NewCond, growing_season)\n\n    # 11. Canopy cover development\n    NewCond = canopy_cover(\n        crop, Soil.Profile, Soil.z_top, NewCond, gdd, et0, growing_season\n    )\n\n    # 12. Soil evaporation\n    (\n        NewCond.e_pot,\n        NewCond.th,\n        NewCond.stage2,\n        NewCond.w_stage_2,\n        NewCond.w_surf,\n        NewCond.surface_storage,\n        NewCond.evap_z,\n        Es,\n        EsPot,\n    ) = soil_evaporation(\n        clock_struct.evap_time_steps,\n        clock_struct.sim_off_season,\n        clock_struct.time_step_counter,\n        Soil.Profile,\n        Soil.evap_z_min,\n        Soil.evap_z_max,\n        Soil.rew,\n        Soil.kex,\n        Soil.fwcc,\n        Soil.f_wrel_exp,\n        Soil.f_evap,\n        crop.CalendarType,\n        crop.Senescence,\n        IrrMngt.irrigation_method,\n        IrrMngt.WetSurf,\n        FieldMngt.mulches,\n        FieldMngt.f_mulch,\n        FieldMngt.mulch_pct,\n        NewCond.dap,\n        NewCond.w_surf,\n        NewCond.evap_z,\n        NewCond.stage2,\n        NewCond.th,\n        NewCond.delayed_cds,\n        NewCond.gdd_cum,\n        NewCond.delayed_gdds,\n        NewCond.ccx_w,\n        NewCond.canopy_cover_adj,\n        NewCond.ccx_act,\n        NewCond.canopy_cover,\n        NewCond.premat_senes,\n        NewCond.surface_storage,\n        NewCond.w_stage_2,\n        NewCond.e_pot,\n        et0,\n        Infl,\n        precipitation,\n        Irr,\n        growing_season,\n    )\n\n    # 13. Crop transpiration\n    Tr, TrPot_NS, TrPot, NewCond, IrrNet = transpiration(\n        Soil.Profile,\n        Soil.nComp,\n        Soil.z_top,\n        crop,\n        IrrMngt.irrigation_method,\n        IrrMngt.NetIrrSMT,\n        NewCond,\n        et0,\n        CO2,\n        growing_season,\n        gdd,\n    )\n\n    # 14. Groundwater inflow\n    NewCond, GwIn = groundwater_inflow(Soil.Profile, NewCond)\n\n    # 15. Reference harvest index\n    (NewCond.hi_ref, NewCond.yield_form, NewCond.pct_lag_phase) = HIref_current_day( # ,NewCond.HIfinal\n        NewCond.hi_ref,\n        NewCond.HIfinal,\n        NewCond.dap,\n        NewCond.delayed_cds,\n        NewCond.yield_form,\n        NewCond.pct_lag_phase,\n        NewCond.canopy_cover,\n        NewCond.cc_prev,\n        NewCond.ccx_w,\n        crop,\n        growing_season,\n    )\n\n    # 16. Biomass accumulation\n    (NewCond.biomass, NewCond.biomass_ns) = biomass_accumulation(\n        crop,\n        NewCond.dap,\n        NewCond.delayed_cds,\n        NewCond.hi_ref,\n        NewCond.pct_lag_phase,\n        NewCond.biomass,\n        NewCond.biomass_ns,\n        Tr,\n        TrPot_NS,\n        et0,\n        growing_season,\n    )\n\n    # 17. Harvest index\n    NewCond = harvest_index(\n        Soil.Profile, Soil.z_top, crop, NewCond, et0, temp_max, temp_min, growing_season\n    )\n\n    # 18. Yield potential\n    NewCond.YieldPot = (NewCond.biomass_ns / 100) * NewCond.harvest_index\n\n    # 19. Crop yield_ (dry and fresh)\n    if growing_season is True:\n        # Calculate crop yield_ (tonne/ha)\n        NewCond.DryYield = (NewCond.biomass / 100) * NewCond.harvest_index_adj\n        NewCond.FreshYield = NewCond.DryYield / (crop.YldWC / 100)\n        # print( clock_struct.time_step_counter,(NewCond.biomass/100),NewCond.harvest_index_adj)\n        # Check if crop has reached maturity\n        if ((crop.CalendarType == 1) and (NewCond.dap &gt;= crop.Maturity)) or (\n            (crop.CalendarType == 2) and (NewCond.gdd_cum &gt;= crop.Maturity)\n        ):\n            # Crop has reached maturity\n            NewCond.crop_mature = True\n\n    elif growing_season is False:\n        # Crop yield_ is zero outside of growing season\n        NewCond.DryYield = 0\n        NewCond.FreshYield = 0\n\n    # 20. Root zone water\n    _TAW = TAW()\n    _water_root_depletion = Dr()\n    # thRZ = RootZoneWater()\n\n    Wr, _water_root_depletion.Zt, _water_root_depletion.Rz, _TAW.Zt, _TAW.Rz, _, _, _, _, _, _ = root_zone_water(\n        Soil.Profile,\n        float(NewCond.z_root),\n        NewCond.th,\n        Soil.z_top,\n        float(crop.Zmin),\n        crop.Aer,\n    )\n\n    # 21. Update net irrigation to add any pre irrigation\n    IrrNet = IrrNet + PreIrr\n    NewCond.irr_net_cum = NewCond.irr_net_cum + PreIrr\n\n    # Update model outputs %%\n    row_day = clock_struct.time_step_counter\n    row_gs = clock_struct.season_counter\n\n    # Irrigation\n    if growing_season is True:\n        if IrrMngt.irrigation_method == 4:\n            # Net irrigation\n            IrrDay = IrrNet\n            IrrTot = NewCond.irr_net_cum\n        else:\n            # Irrigation\n            IrrDay = Irr\n            IrrTot = NewCond.irr_cum\n\n    else:\n        IrrDay = 0\n        IrrTot = 0\n\n        NewCond.depletion = _water_root_depletion.Rz\n        NewCond.taw = _TAW.Rz\n\n    # Water contents\n    outputs.water_storage[row_day, :3] = np.array(\n        [clock_struct.time_step_counter, growing_season, NewCond.dap]\n    )\n    outputs.water_storage[row_day, 3:] = NewCond.th\n\n    # Water fluxes\n    # print(f'Saving NewCond.z_gw to outputs: {NewCond.z_gw}')\n    outputs.water_flux[row_day, :] = [\n        clock_struct.time_step_counter,\n        clock_struct.season_counter,\n        NewCond.dap,\n        Wr,\n        NewCond.z_gw,\n        NewCond.surface_storage,\n        IrrDay,\n        Infl,\n        Runoff,\n        DeepPerc,\n        CR,\n        GwIn,\n        Es,\n        EsPot,\n        Tr,\n        TrPot,\n    ]\n\n    # Crop growth\n    outputs.crop_growth[row_day, :] = [\n        clock_struct.time_step_counter,\n        clock_struct.season_counter,\n        NewCond.dap,\n        gdd,\n        NewCond.gdd_cum,\n        NewCond.z_root,\n        NewCond.canopy_cover,\n        NewCond.canopy_cover_ns,\n        NewCond.biomass,\n        NewCond.biomass_ns,\n        NewCond.harvest_index,\n        NewCond.harvest_index_adj,\n        NewCond.DryYield,\n        NewCond.FreshYield,\n        NewCond.YieldPot,\n    ]\n\n    # Final output (if at end of growing season)\n    if clock_struct.season_counter &gt; -1:\n        if (\n            (NewCond.crop_mature is True)\n            or (NewCond.crop_dead is True)\n            or (\n                clock_struct.harvest_dates[clock_struct.season_counter]\n                == clock_struct.step_end_time\n            )\n        ) and (NewCond.harvest_flag is False):\n\n            # Store final outputs\n            outputs.final_stats.loc[row_gs] = [\n                clock_struct.season_counter,\n                Crop_Name,\n                clock_struct.step_end_time,\n                clock_struct.time_step_counter,\n                NewCond.DryYield,\n                NewCond.FreshYield,\n                NewCond.YieldPot,\n                IrrTot,\n            ]\n\n            # Set harvest flag\n            NewCond.harvest_flag = True\n\n    return NewCond, param_struct, outputs\n</code></pre>"},{"location":"utils/#aquacrop.utils.lars.update_time","title":"<code>update_time(clock_struct, init_cond, param_struct, weather, crop)</code>","text":"<p>Function to update current time in model.</p> <p>Arguments:</p> <pre><code>clock_struct (ClockStruct):  model time paramaters\n\ninit_cond (InitialCondition):  containing sim variables+counters\n\nparam_struct (ParamStruct):  containing model paramaters\n\nweather (numpy.array):  weather data for simulation period\n</code></pre> <p>Returns:</p> <pre><code>clock_struct (ClockStruct):  model time paramaters\n\ninit_cond (InitialCondition):  containing reset model paramaters\n\nparam_struct (ParamStruct):  containing model paramaters\n</code></pre> Source code in <code>aquacrop/timestep/update_time.py</code> <pre><code>def update_time(\n    clock_struct: \"ClockStruct\",\n    init_cond: \"InitialCondition\",\n    param_struct: \"ParamStruct\",\n    weather: \"ndarray\",\n    crop: \"Crop\",\n    ) -&gt; Tuple[\"ClockStruct\",\"InitialCondition\", \"ParamStruct\"]:\n    \"\"\"\n    Function to update current time in model.\n\n    Arguments:\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        init_cond (InitialCondition):  containing sim variables+counters\n\n        param_struct (ParamStruct):  containing model paramaters\n\n        weather (numpy.array):  weather data for simulation period\n\n    Returns:\n\n        clock_struct (ClockStruct):  model time paramaters\n\n        init_cond (InitialCondition):  containing reset model paramaters\n\n        param_struct (ParamStruct):  containing model paramaters\n    \"\"\"\n    # Update time\n    if clock_struct.model_is_finished is False:\n        if (init_cond.harvest_flag is True) and (\n            (clock_struct.sim_off_season is False)\n        ):\n            # TODO: sim_off_season will always be False.\n\n            # End of growing season has been reached and not simulating\n            # off-season soil water balance. Advance time to the start of the\n            # next growing season.\n            # Check if in last growing season\n            if clock_struct.season_counter &lt; clock_struct.n_seasons - 1:\n                # Update growing season counter\n                clock_struct.season_counter = clock_struct.season_counter + 1\n                # Update time-step counter\n\n                clock_struct.time_step_counter = clock_struct.time_span.get_loc(\n                    clock_struct.planting_dates[clock_struct.season_counter]\n                )\n                # Update start time of time-step\n                clock_struct.step_start_time = clock_struct.time_span[\n                    clock_struct.time_step_counter\n                ]\n                # Update end time of time-step\n                clock_struct.step_end_time = clock_struct.time_span[\n                    clock_struct.time_step_counter + 1\n                ]\n                # Reset initial conditions for start of growing season\n                init_cond, param_struct = reset_initial_conditions(\n                    clock_struct, init_cond, param_struct, weather, crop\n                )\n\n        else:\n            # Simulation considers off-season, so progress by one time-step\n            # (one day)\n            # Time-step counter\n            clock_struct.time_step_counter = clock_struct.time_step_counter + 1\n            # Start of time step (beginning of current day)\n            # clock_struct.time_span = pd.Series(clock_struct.time_span)\n            clock_struct.step_start_time = clock_struct.time_span[\n                clock_struct.time_step_counter\n            ]\n            # End of time step (beginning of next day)\n            clock_struct.step_end_time = clock_struct.time_span[\n                clock_struct.time_step_counter + 1\n            ]\n            # Check if it is not the last growing season\n            if clock_struct.season_counter &lt; clock_struct.n_seasons - 1:\n                # Check if upcoming day is the start of a new growing season\n                if (\n                    clock_struct.step_start_time\n                    == clock_struct.planting_dates[clock_struct.season_counter + 1]\n                ):\n                    # Update growing season counter\n                    clock_struct.season_counter = clock_struct.season_counter + 1\n                    # Reset initial conditions for start of growing season\n                    init_cond, param_struct = reset_initial_conditions(\n                        clock_struct, init_cond, param_struct, weather, crop\n                    )\n\n    return clock_struct, init_cond, param_struct\n</code></pre>"},{"location":"utils/#aquacrop.utils.prepare_weather","title":"<code>aquacrop.utils.prepare_weather</code>","text":""},{"location":"utils/#aquacrop.utils.prepare_weather.prepare_weather","title":"<code>prepare_weather(weather_file_path)</code>","text":"<pre><code>function to read in weather data and return a dataframe containing\nthe weather data\n\nArguments:\n</code></pre> <p>FileLocations): <code>FileLocationsClass</code>:  input File Locations</p> <p>weather_file_path): `str):  file location of weather data</p> <pre><code>Returns:\n</code></pre> <p>weather_df (pandas.DataFrame):  weather data for simulation period</p> Source code in <code>aquacrop/utils/prepare_weather.py</code> <pre><code>def prepare_weather(weather_file_path):\n    \"\"\"\n    function to read in weather data and return a dataframe containing\n    the weather data\n\n    Arguments:\\n\n\nFileLocations): `FileLocationsClass`:  input File Locations\n\nweather_file_path): `str):  file location of weather data\n\n\n\n    Returns:\n\nweather_df (pandas.DataFrame):  weather data for simulation period\n\n    \"\"\"\n\n    weather_df = pd.read_csv(weather_file_path, header=0, sep='\\s+')\n\n    assert len(weather_df.columns) == 7\n\n    # rename the columns\n    weather_df.columns = str(\n        \"Day Month Year MinTemp MaxTemp Precipitation ReferenceET\").split()\n\n    # put the weather dates into datetime format\n    weather_df[\"Date\"] = pd.to_datetime(weather_df[[\"Year\", \"Month\", \"Day\"]])\n\n    # drop the day month year columns\n    weather_df = weather_df.drop([\"Day\", \"Month\", \"Year\"], axis=1)\n\n    # set limit on ET0 to avoid divide by zero errors\n    weather_df['ReferenceET'] = weather_df['ReferenceET'].clip(lower=0.1)\n\n    return weather_df\n</code></pre>"},{"location":"notebooks/05_comparison/","title":"Comparison with AquaCrop Windows","text":"In\u00a0[\u00a0]: Copied! In\u00a0[1]: Copied! <pre># uncomment if required\n# !pip install aquacrop matplotlib seaborn\n\n# from google.colab import output\n# output.clear()\n</pre> # uncomment if required # !pip install aquacrop matplotlib seaborn  # from google.colab import output # output.clear() <p>If for any reason you would rather not compile the aquacrop modules ahead-of-time, you can run the following cell to run the notebook in pure python (N.B. it will run slower).</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['DEVELOPMENT'] = 'True'\n</pre> # import os # os.environ['DEVELOPMENT'] = 'True' In\u00a0[2]: Copied! <pre>from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement,FieldMngt\nfrom aquacrop.utils import prepare_weather, get_filepath\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n</pre>  from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement,FieldMngt from aquacrop.utils import prepare_weather, get_filepath  import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns  In\u00a0[3]: Copied! <pre>#model.Outputs.Final\n</pre> #model.Outputs.Final In\u00a0[4]: Copied! <pre>#export\ndef run_comparison(model,name):\n    \"\"\"\n    Function to run a comparison between python matlab and windows. \n    Plots yields and prints mean and mean absolute error between them\n    \n    Arguments: \n\n    \nname (str): name of directory containing input files\n\n    Returns:\n\n    None\n\n        \n    \"\"\"    \n    Outputs = model._outputs\n    \n    py = Outputs.final_stats.round(3)\n    py.columns = [\"Season\",\"CropType\",\"HarvestDate\",\"Harvest Date (Step)\",\"Yield\",\"Seasonal irrigation (mm)\"]\n    \n    matlab = pd.read_csv(get_filepath(name+'_matlab.txt'),delim_whitespace=True,header=None)\n    matlab.columns = [\"season\",\"crop\",\"plantdate\",\"stepplant\",\"harvestdate\",\"stepharvest\",\"Yield\",\"tirr\"]\n\n    \n    windows_names = ('    RunNr     Day1   Month1    Year1     Rain      ETo       GD     CO2      Irri   Infilt   Runoff    Drain   Upflow        E     E/Ex       Tr      TrW   Tr/Trx    SaltIn   SaltOut    SaltUp  SaltProf     Cycle   SaltStr  FertStr  WeedStr  TempStr   ExpStr   StoStr  BioMass  Brelative   HI     Yield     WPet     DayN   MonthN    YearN'.split())\n    windows = pd.read_csv(get_filepath(name+'_windows.OUT'),skiprows=5,delim_whitespace=True,names=windows_names,encoding=\"ISO-8859-1\")\n\n    combined = pd.DataFrame([py.Yield,windows.Yield,matlab.Yield]).T\n\n    combined.columns = [\"py\", \"windows\",\"matlab\"]\n    mae = np.round(np.abs(combined.py - combined.windows).mean(),2)\n    pymean = combined.mean().py.round(2)\n    print(f'python seasonal mean: {pymean} kg/ha\\nMAE from windows: {mae} kg/ha')\n    \n    mae_mat = np.round(np.abs(combined.py - combined.matlab).mean(),3)\n    print(f'MAE from matlab:  {mae_mat} kg/ha')\n    \n    plt.style.use('seaborn')\n    \n    fig, ax = plt.subplots(2,1,sharex=True,figsize=(11,8))\n    \n    ax[0].plot(py.Yield,label='Python')\n    ax[0].plot(matlab.Yield,label='Matlab')\n    ax[0].plot(windows.Yield,'--',label='Windows')\n    ax[0].legend(fontsize = 18)\n    ax[0].set_ylabel('Yield',fontsize=18)\n    \n    #sns.jointplot(np.arange(len(py)), py.Yield - windows.Yield,\n      #            kind=\"resid\",color=\"m\",ratio=10)\n    \n    ax[1].scatter(np.arange(len(py)),py.Yield - windows.Yield,label='Python')\n    ax[1].scatter(np.arange(len(py)),matlab.Yield - windows.Yield,label='Matlab')\n    ax[1].plot([0,len(py)],[0,0],'--',color='black')\n    ax[1].set_xlabel('Season',fontsize=18)\n    ax[1].set_ylabel('Residuals',fontsize=18)\n    ax[1].legend(fontsize = 18)\n\n    \n\n\n\n    plt.show()\n    \n    \n    return Outputs,windows\n</pre> #export def run_comparison(model,name):     \"\"\"     Function to run a comparison between python matlab and windows.      Plots yields and prints mean and mean absolute error between them          Arguments:        name (str): name of directory containing input files      Returns:      None               \"\"\"         Outputs = model._outputs          py = Outputs.final_stats.round(3)     py.columns = [\"Season\",\"CropType\",\"HarvestDate\",\"Harvest Date (Step)\",\"Yield\",\"Seasonal irrigation (mm)\"]          matlab = pd.read_csv(get_filepath(name+'_matlab.txt'),delim_whitespace=True,header=None)     matlab.columns = [\"season\",\"crop\",\"plantdate\",\"stepplant\",\"harvestdate\",\"stepharvest\",\"Yield\",\"tirr\"]           windows_names = ('    RunNr     Day1   Month1    Year1     Rain      ETo       GD     CO2      Irri   Infilt   Runoff    Drain   Upflow        E     E/Ex       Tr      TrW   Tr/Trx    SaltIn   SaltOut    SaltUp  SaltProf     Cycle   SaltStr  FertStr  WeedStr  TempStr   ExpStr   StoStr  BioMass  Brelative   HI     Yield     WPet     DayN   MonthN    YearN'.split())     windows = pd.read_csv(get_filepath(name+'_windows.OUT'),skiprows=5,delim_whitespace=True,names=windows_names,encoding=\"ISO-8859-1\")      combined = pd.DataFrame([py.Yield,windows.Yield,matlab.Yield]).T      combined.columns = [\"py\", \"windows\",\"matlab\"]     mae = np.round(np.abs(combined.py - combined.windows).mean(),2)     pymean = combined.mean().py.round(2)     print(f'python seasonal mean: {pymean} kg/ha\\nMAE from windows: {mae} kg/ha')          mae_mat = np.round(np.abs(combined.py - combined.matlab).mean(),3)     print(f'MAE from matlab:  {mae_mat} kg/ha')          plt.style.use('seaborn')          fig, ax = plt.subplots(2,1,sharex=True,figsize=(11,8))          ax[0].plot(py.Yield,label='Python')     ax[0].plot(matlab.Yield,label='Matlab')     ax[0].plot(windows.Yield,'--',label='Windows')     ax[0].legend(fontsize = 18)     ax[0].set_ylabel('Yield',fontsize=18)          #sns.jointplot(np.arange(len(py)), py.Yield - windows.Yield,       #            kind=\"resid\",color=\"m\",ratio=10)          ax[1].scatter(np.arange(len(py)),py.Yield - windows.Yield,label='Python')     ax[1].scatter(np.arange(len(py)),matlab.Yield - windows.Yield,label='Matlab')     ax[1].plot([0,len(py)],[0,0],'--',color='black')     ax[1].set_xlabel('Season',fontsize=18)     ax[1].set_ylabel('Residuals',fontsize=18)     ax[1].legend(fontsize = 18)              plt.show()               return Outputs,windows In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[5]: Copied! <pre>wdf = prepare_weather(get_filepath('tunis_climate.txt'))\n\nsoil=Soil(soil_type='ac_TunisLocal')\ncrop = Crop('WheatGDD',planting_date= '10/15')\n\niwc = InitialWaterContent('Num','Depth',[0.3,0.9],[0.3,0.15])\n\nmodel = AquaCropModel('1979/10/15','2002/05/30',wdf,soil,crop,initial_water_content=iwc)\n\n\n\n%time model.run_model(till_termination=True)\n</pre> wdf = prepare_weather(get_filepath('tunis_climate.txt'))  soil=Soil(soil_type='ac_TunisLocal') crop = Crop('WheatGDD',planting_date= '10/15')  iwc = InitialWaterContent('Num','Depth',[0.3,0.9],[0.3,0.15])  model = AquaCropModel('1979/10/15','2002/05/30',wdf,soil,crop,initial_water_content=iwc)    %time model.run_model(till_termination=True) <pre>CPU times: user 1.42 s, sys: 4.93 ms, total: 1.42 s\nWall time: 1.42 s\n</pre> Out[5]: <pre>True</pre> In\u00a0[6]: Copied! <pre>res = run_comparison(model,'tunis_test_1')\n</pre> res = run_comparison(model,'tunis_test_1') <pre>python seasonal mean: 7.52 kg/ha\nMAE from windows: 0.02 kg/ha\nMAE from matlab:  0.002 kg/ha\n</pre> In\u00a0[7]: Copied! <pre>sandy_loam = Soil('SandyLoam')\nmodel = AquaCropModel('1979/01/01','2002/05/30',wdf,sandy_loam,crop,initial_water_content=iwc)\nmodel.run_model(till_termination=True)\nres = run_comparison(model,'tunis_test_1_SandyLoam')\n</pre> sandy_loam = Soil('SandyLoam') model = AquaCropModel('1979/01/01','2002/05/30',wdf,sandy_loam,crop,initial_water_content=iwc) model.run_model(till_termination=True) res = run_comparison(model,'tunis_test_1_SandyLoam') <pre>python seasonal mean: 8.64 kg/ha\nMAE from windows: 0.01 kg/ha\nMAE from matlab:  0.002 kg/ha\n</pre> In\u00a0[8]: Copied! <pre>local_wheat = Crop('WheatGDD',planting_date= '10/15',\n                        Emergence=289, \n                        MaxRooting = 1322,\n                        Senescence = 2835, \n                        Maturity = 3390,\n                        HIstart = 2252,\n                        Flowering = 264,\n                        YldForm = 1073,\n                        PlantPop=3_500_000,\n                        CCx=0.9,\n                        CDC=0.003888,\n                        CGC=0.002734)\n</pre> local_wheat = Crop('WheatGDD',planting_date= '10/15',                         Emergence=289,                          MaxRooting = 1322,                         Senescence = 2835,                          Maturity = 3390,                         HIstart = 2252,                         Flowering = 264,                         YldForm = 1073,                         PlantPop=3_500_000,                         CCx=0.9,                         CDC=0.003888,                         CGC=0.002734) In\u00a0[9]: Copied! <pre>model = AquaCropModel('1979/01/01','2002/05/31',wdf,sandy_loam,local_wheat,initial_water_content=iwc)\nmodel.run_model(till_termination=True)\n_ = run_comparison(model,'tunis_test_2_long')\n</pre> model = AquaCropModel('1979/01/01','2002/05/31',wdf,sandy_loam,local_wheat,initial_water_content=iwc) model.run_model(till_termination=True) _ = run_comparison(model,'tunis_test_2_long') <pre>python seasonal mean: 8.68 kg/ha\nMAE from windows: 0.04 kg/ha\nMAE from matlab:  0.042 kg/ha\n</pre> In\u00a0[10]: Copied! <pre>iwc30taw = InitialWaterContent('Pct','Layer',[1],[30])\n</pre> iwc30taw = InitialWaterContent('Pct','Layer',[1],[30]) In\u00a0[11]: Copied! <pre>model = AquaCropModel('1979/01/01','2002/05/31',wdf,sandy_loam,\n                      crop,initial_water_content=iwc30taw)\n\nmodel.run_model(till_termination=True)\n_ = run_comparison(model,'tunis_test_3_30taw')\n</pre> model = AquaCropModel('1979/01/01','2002/05/31',wdf,sandy_loam,                       crop,initial_water_content=iwc30taw)  model.run_model(till_termination=True) _ = run_comparison(model,'tunis_test_3_30taw') <pre>python seasonal mean: 5.85 kg/ha\nMAE from windows: 0.09 kg/ha\nMAE from matlab:  0.002 kg/ha\n</pre> In\u00a0[12]: Copied! <pre>net_irr = IrrigationManagement(irrigation_method=4,net_irr=78.26)\nwp = InitialWaterContent(value=['WP'])\nwheat_dec = Crop('WheatGDD',planting_date='12/01',harvest_date='07/30')\n</pre> net_irr = IrrigationManagement(irrigation_method=4,net_irr=78.26) wp = InitialWaterContent(value=['WP']) wheat_dec = Crop('WheatGDD',planting_date='12/01',harvest_date='07/30') In\u00a0[13]: Copied! <pre>model = AquaCropModel('1979/08/15','2001/07/30',wdf,sandy_loam,\n                      wheat_dec,initial_water_content=wp,irrigation_management=net_irr)\nmodel.run_model(till_termination=True)\nres = run_comparison(model,'tunis_test_6')\n</pre> model = AquaCropModel('1979/08/15','2001/07/30',wdf,sandy_loam,                       wheat_dec,initial_water_content=wp,irrigation_management=net_irr) model.run_model(till_termination=True) res = run_comparison(model,'tunis_test_6') <pre>python seasonal mean: 8.38 kg/ha\nMAE from windows: 0.01 kg/ha\nMAE from matlab:  0.003 kg/ha\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[14]: Copied! <pre>wdf = prepare_weather(get_filepath('hyderabad_climate.txt'))\n\nwdf.Date.min(),wdf.Date.max()\n</pre> wdf = prepare_weather(get_filepath('hyderabad_climate.txt'))  wdf.Date.min(),wdf.Date.max() Out[14]: <pre>(Timestamp('2000-01-01 00:00:00'), Timestamp('2010-12-31 00:00:00'))</pre> In\u00a0[15]: Copied! <pre>rice = Crop('localpaddy',planting_date= '08/01',)\npaddy = Soil('Paddy')\niwc_paddy = InitialWaterContent(depth_layer=[1,2],value=['FC','FC'])\nfm = FieldMngt(bunds=True,z_bund=0.2)\nmodel = AquaCropModel('2000/01/01','2010/12/31',wdf,paddy,\n                      rice,initial_water_content=iwc_paddy,field_management=fm,\n                      fallow_field_management=fm)\nmodel.run_model(till_termination=True)\n_ = run_comparison(model,'paddyrice_hyderabad')\n</pre> rice = Crop('localpaddy',planting_date= '08/01',) paddy = Soil('Paddy') iwc_paddy = InitialWaterContent(depth_layer=[1,2],value=['FC','FC']) fm = FieldMngt(bunds=True,z_bund=0.2) model = AquaCropModel('2000/01/01','2010/12/31',wdf,paddy,                       rice,initial_water_content=iwc_paddy,field_management=fm,                       fallow_field_management=fm) model.run_model(till_termination=True) _ = run_comparison(model,'paddyrice_hyderabad') <pre>python seasonal mean: 6.43 kg/ha\nMAE from windows: 0.01 kg/ha\nMAE from matlab:  0.013 kg/ha\n</pre> In\u00a0[16]: Copied! <pre>wdf = prepare_weather(get_filepath('brussels_climate.txt'))\n\nwdf.Date.min(),wdf.Date.max()\n</pre> wdf = prepare_weather(get_filepath('brussels_climate.txt'))  wdf.Date.min(),wdf.Date.max() Out[16]: <pre>(Timestamp('1976-01-01 00:00:00'), Timestamp('2005-12-31 00:00:00'))</pre> In\u00a0[17]: Copied! <pre>potato = Crop('PotatoLocal',planting_date= '04/25')\nloam = Soil('Loam')\nmodel = AquaCropModel('1976/01/01','2005/12/31',wdf,loam,potato,InitialWaterContent())\nmodel.run_model(till_termination=True)\n_ = run_comparison(model,'potato')\n</pre> potato = Crop('PotatoLocal',planting_date= '04/25') loam = Soil('Loam') model = AquaCropModel('1976/01/01','2005/12/31',wdf,loam,potato,InitialWaterContent()) model.run_model(till_termination=True) _ = run_comparison(model,'potato') <pre>python seasonal mean: 9.69 kg/ha\nMAE from windows: 0.1 kg/ha\nMAE from matlab:  0.029 kg/ha\n</pre> In\u00a0[18]: Copied! <pre>windows_names = ('    RunNr     Day1   Month1    Year1     Rain      ETo       GD     CO2      Irri   Infilt   Runoff    Drain   Upflow        E     E/Ex       Tr      TrW   Tr/Trx    SaltIn   SaltOut    SaltUp  SaltProf     Cycle   SaltStr  FertStr  WeedStr  TempStr   ExpStr   StoStr  BioMass  Brelative   HI     Yield     WPet     DayN   MonthN    YearN'.split())\nwindows = pd.read_csv(get_filepath('potato'+'_windows.OUT'),skiprows=5,delim_whitespace=True,names=windows_names,encoding=\"ISO-8859-1\")\n</pre>  windows_names = ('    RunNr     Day1   Month1    Year1     Rain      ETo       GD     CO2      Irri   Infilt   Runoff    Drain   Upflow        E     E/Ex       Tr      TrW   Tr/Trx    SaltIn   SaltOut    SaltUp  SaltProf     Cycle   SaltStr  FertStr  WeedStr  TempStr   ExpStr   StoStr  BioMass  Brelative   HI     Yield     WPet     DayN   MonthN    YearN'.split()) windows = pd.read_csv(get_filepath('potato'+'_windows.OUT'),skiprows=5,delim_whitespace=True,names=windows_names,encoding=\"ISO-8859-1\")  In\u00a0[19]: Copied! <pre>infil = windows.Infilt.values\nrunoff = windows.Runoff.values\ndrain = windows.Drain.values\ne = windows.E.values\ntr = windows.Tr.values\nbio = windows.BioMass*100\nhi = windows.HI/100\n</pre> infil = windows.Infilt.values runoff = windows.Runoff.values drain = windows.Drain.values e = windows.E.values tr = windows.Tr.values bio = windows.BioMass*100 hi = windows.HI/100   In\u00a0[20]: Copied! <pre>grouped1 = model._outputs.crop_growth.groupby('season_counter').max()\ngrouped1.head()\n</pre> grouped1 = model._outputs.crop_growth.groupby('season_counter').max() grouped1.head() Out[20]: time_step_counter dap gdd gdd_cum z_root canopy_cover canopy_cover_ns biomass biomass_ns harvest_index harvest_index_adj yield_ season_counter -1.0 114.0 0.0 0.3 0.00 0.0 0.000000 0.000000 0.000000 0.000000 0.00 0.000000 0.000000 0.0 239.0 125.0 21.7 1884.25 0.6 0.862350 0.901142 727.594299 1336.718464 0.85 0.783289 5.699169 1.0 604.0 125.0 19.7 1604.70 0.6 0.919523 0.919523 1365.151078 1372.454625 0.85 0.849932 11.602858 2.0 969.0 125.0 20.7 1608.35 0.6 0.919523 0.919523 1200.169603 1376.180500 0.85 0.837747 10.054389 3.0 1334.0 125.0 20.0 1599.15 0.6 0.892085 0.901142 1191.474260 1373.349628 0.85 0.837168 9.974647 In\u00a0[21]: Copied! <pre>grouped = model._outputs.water_flux.groupby('season_counter').sum()\ngrouped.head()\n</pre> grouped = model._outputs.water_flux.groupby('season_counter').sum() grouped.head() Out[21]: time_step_counter dap Wr z_gw surface_storage IrrDay Infl Runoff DeepPerc CR GwIn Es EsPot Tr TrPot season_counter -1.0 6555.0 0.0 10019.89 -114885.0 0.0 0.0 131.882145 4.117855 71.117311 0.0 0.0 82.601730 135.080000 0.000000 0.000000 0.0 22125.0 7875.0 13719.62 -124875.0 0.0 0.0 148.172417 2.127583 0.000000 0.0 0.0 70.200175 223.026573 162.839113 304.919138 1.0 67750.0 7875.0 17299.10 -124875.0 0.0 0.0 303.077344 5.722656 48.054092 0.0 0.0 95.621728 139.812879 220.522103 220.566948 2.0 113375.0 7875.0 16867.71 -124875.0 0.0 0.0 307.410487 35.189513 105.719399 0.0 0.0 91.846257 138.356508 200.043602 229.744565 3.0 159000.0 7875.0 16196.70 -124875.0 0.0 0.0 270.007475 8.392525 30.311757 0.0 0.0 96.987000 137.950148 196.763470 225.579405 In\u00a0[22]: Copied! <pre>print('runoff',(((grouped.Runoff.values[1:]-runoff)**2).mean()**(0.5))/runoff.mean())\nprint('infil',(((grouped.Infl.values[1:]-infil)**2).mean()**(0.5))/infil.mean())\nprint('drain',(((grouped.DeepPerc.values[1:]-drain)**2).mean()**(0.5))/drain.mean())\nprint('es',(((grouped.Es.values[1:]-e)**2).mean()**(0.5))/e.mean())\nprint('tr',(((grouped.Tr.values[1:]-tr)**2).mean()**(0.5))/tr.mean())\nprint('bio',(((grouped1.biomass.values[1:]-bio)**2).mean()**(0.5))/bio.mean())\nprint('hi',(((grouped1.harvest_index.values[1:]-hi)**2).mean()**(0.5))/hi.mean())\n</pre> print('runoff',(((grouped.Runoff.values[1:]-runoff)**2).mean()**(0.5))/runoff.mean()) print('infil',(((grouped.Infl.values[1:]-infil)**2).mean()**(0.5))/infil.mean()) print('drain',(((grouped.DeepPerc.values[1:]-drain)**2).mean()**(0.5))/drain.mean()) print('es',(((grouped.Es.values[1:]-e)**2).mean()**(0.5))/e.mean()) print('tr',(((grouped.Tr.values[1:]-tr)**2).mean()**(0.5))/tr.mean()) print('bio',(((grouped1.biomass.values[1:]-bio)**2).mean()**(0.5))/bio.mean()) print('hi',(((grouped1.harvest_index.values[1:]-hi)**2).mean()**(0.5))/hi.mean()) <pre>runoff 0.028950898501130966\ninfil 0.001118950747288327\ndrain 0.018606817721937778\nes 0.02097557914397535\ntr 0.011832327627400175\nbio 0.012778083976522187\nhi 0.05034387357901827\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/05_comparison/#aquacrop-ospy-bridging-the-gap-between-research-and-practice-in-crop-water-modelling","title":"AquaCrop-OSPy: Bridging the gap between research and practice in crop-water modelling\u00b6","text":""},{"location":"notebooks/05_comparison/#comparison-with-aquacrop-windows","title":"Comparison with AquaCrop Windows\u00b6","text":"<p>AquaCrop-OSPy | AquaCrop-OS | AquaCrop | Test Comparison</p>"},{"location":"notebooks/05_comparison/#excersise-7-wheat-production-in-tunis","title":"Excersise 7: Wheat production in Tunis\u00b6","text":""},{"location":"notebooks/05_comparison/#from-chapter-7-of-aquacrop-training-handbook-pg-64","title":"From Chapter 7 of  AquaCrop Training Handbook (pg. 64)\u00b6","text":""},{"location":"notebooks/05_comparison/#exercise-71-assessing-crop-yield-for-local-soils","title":"Exercise 7.1: Assessing crop yield for local soils\u00b6","text":""},{"location":"notebooks/05_comparison/#imports","title":"Imports\u00b6","text":""},{"location":"notebooks/05_comparison/#run-comparison","title":"Run comparison\u00b6","text":""},{"location":"notebooks/05_comparison/#sandy-loam-soil","title":"Sandy loam soil\u00b6","text":""},{"location":"notebooks/05_comparison/#excercise-72-local-wheat-variety","title":"Excercise 7.2 Local Wheat variety\u00b6","text":""},{"location":"notebooks/05_comparison/#excercise-73-different-initial-conditions","title":"Excercise 7.3 Different initial conditions\u00b6","text":""},{"location":"notebooks/05_comparison/#excercise-76-net-irrigation-requirement","title":"Excercise 7.6 Net irrigation requirement\u00b6","text":""},{"location":"notebooks/05_comparison/#excersise-8-hyderabad-chapter-8-of-aquacrop-training-handbook","title":"Excersise 8 : Hyderabad : Chapter 8 of  AquaCrop Training Handbook\u00b6","text":""},{"location":"notebooks/05_comparison/#excersise-81","title":"Excersise 8.1\u00b6","text":""},{"location":"notebooks/05_comparison/#excersise-9-brussels-chapter-9-of-aquacrop-training-handbook","title":"Excersise 9 : Brussels : Chapter 9 of  AquaCrop Training Handbook\u00b6","text":""},{"location":"notebooks/05_comparison/#excersise-91","title":"Excersise 9.1\u00b6","text":""},{"location":"notebooks/05_comparison/#calculate-rmse-for-particular-variables-for-debugging","title":"Calculate RMSE for particular variables (for debugging)\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/","title":"Getting Started","text":"<p>This series of notebooks provides users with an introduction to AquaCrop-OSPy, an open-source Python implementation of the U.N. Food and Agriculture Organization (FAO) AquaCrop model. AquaCrop-OSPy is accompanied by a series of Jupyter notebooks, which guide users interactively through a range of common applications of the model. Only basic Python experience is required, and the notebooks can easily be extended and adapted by users for their own applications and needs.</p> <p>This notebook series consists of four parts:</p> <ol> <li>Running an AquaCrop-OSPy model</li> <li>Estimation of irrigation water demands</li> <li>Optimisation of irrigation management strategies</li> <li>Projection of climate change impacts</li> </ol> <p>In this notebook, you will learn interactively how to setup and run you first AquaCrop-OSPy simulation. We begin by showing how to define key model input parameters and variables, and then show how to execute a model simulation and interpret output files.</p> <p>The first of these notebooks outlines how to setup and run single and multi-season simulations for a selected cropping system. Examples are provided about how to setup and define relevant crop, soil, weather and management parameter values and inputs, with more advanced customization guides given in the Appendices A-D.</p> <p></p> <p>In order to use AquaCrop-OSPy inside this notebook we first need to install and import it. Installing aquacrop is as simple as running <code>pip install aquacrop</code> or <code>!pip install aquacrop==VERSION</code> to install a specific version. In cell below we also use the <code>output.clear</code> function to keep everything tidy.</p> In\u00a0[1]: Copied! <pre># !pip install aquacrop\n\n# from google.colab import output\n# output.clear()\n</pre> # !pip install aquacrop  # from google.colab import output # output.clear() <p>In case the installation through pip fails for any reason, you can install direct from GitHub using the cell below.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install git+https://github.com/aquacropos/aquacrop\n\n# from google.colab import output\n# output.clear()\n</pre> # !pip install git+https://github.com/aquacropos/aquacrop  # from google.colab import output # output.clear() <p>If for any reason you would rather not compile the aquacrop modules ahead-of-time, you can run the following cell to run the notebook in pure python (N.B. it will run slower).</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['DEVELOPMENT'] = 'True'\n</pre> # import os # os.environ['DEVELOPMENT'] = 'True' <p>Now that <code>aquacrop</code> is installed we need to import the various components into the notebook. All these functions do not have to be imported at once as we have done in the cell below but it will help keep things clearer throughout this notebook.</p> In\u00a0[2]: Copied! <pre>from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, FieldMngt, GroundWater\nfrom aquacrop.utils import prepare_weather, get_filepath\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n</pre> from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, FieldMngt, GroundWater from aquacrop.utils import prepare_weather, get_filepath  import pandas as pd import matplotlib.pyplot as plt import seaborn as sns <p>Running an AquaCrop-OSPy model requires the selection of 5 components:</p> <ol> <li>Daily climate measurements</li> <li>Soil selection</li> <li>Crop selection</li> <li>Initial water content</li> <li>Simulation start and end dates</li> </ol> <p>We will go through the selection of these components in turn below.</p> <p>AquaCrop-OSPy requires weather data to be specified over the cropping period being simulated. This includes a daily time series of minimum and maximum temperatures [C], precipitation [mm], and reference crop evapotranspiration [mm].</p> <p>To import these data into the model, a .txt file containing relevant weather data must be created by the user in the following space delimited format.</p> <p></p> <p>If you are running this notebook locally you will need to specify the file path to the weather data file on your computer. If you are running the notebook via Google Colab you can upload the file through the tab on the left so that it is available in the current directory.</p> <p></p> <p>To load the weather data into the model, use the <code>prepare_weather</code> function, passing in the filepath of the .txt file. This <code>prepare_weather</code> function will create a pandas DataFrame in Python storing the imported weather data in the correct format for subsequent simulations.</p> In\u00a0[3]: Copied! <pre># specify filepath to weather file (either locally or imported to colab)\n# filepath= 'YOUR_WEATHER_FILE.TXT'\n\n# weather_data = prepare_weather(filepath)\n# weather_data\n</pre> # specify filepath to weather file (either locally or imported to colab) # filepath= 'YOUR_WEATHER_FILE.TXT'  # weather_data = prepare_weather(filepath) # weather_data <p>AquaCrop-OSPy also contains a number of in-built example weather files. These can be accessed using the <code>get_filepath</code> function as shown below. Once run then use the <code>prep_weather</code> function as above to convert the data to a pandas DataFrame ready for use. A full list of the built-in weather files can be found in Appendix A.</p> In\u00a0[4]: Copied! <pre># locate built in weather file\nfilepath=get_filepath('tunis_climate.txt')\n\nweather_data = prepare_weather(filepath)\nweather_data\n</pre> # locate built in weather file filepath=get_filepath('tunis_climate.txt')  weather_data = prepare_weather(filepath) weather_data Out[4]: MinTemp MaxTemp Precipitation ReferenceET Date 0 15.0 20.0 0.0 1.5 1979-01-01 1 8.0 15.0 0.0 1.3 1979-01-02 2 3.0 12.0 0.0 1.2 1979-01-03 3 5.0 19.0 0.0 1.8 1979-01-04 4 10.0 17.0 0.0 1.4 1979-01-05 ... ... ... ... ... ... 8547 17.3 32.5 0.0 7.0 2002-05-27 8548 16.8 24.4 0.0 4.9 2002-05-28 8549 15.0 27.8 0.0 6.0 2002-05-29 8550 14.1 30.0 0.0 6.4 2002-05-30 8551 17.0 29.2 0.0 5.9 2002-05-31 <p>8552 rows \u00d7 5 columns</p> <p>Selecting a soil type for an AquaCrop-OSPy simulation is done via the <code>Soil</code> object. This object contains all the compositional and hydraulic properties needed for the simulation. The simplest way to select a <code>Soil</code> is to use one of the built-in soil types taken from AquaCrop defaults. A visual representation of these defaults is shown below.</p> <p></p> <p>As an example, to select a 'sandy loam' soil, run the cell below. Appendix B details how a user can edit any of these built-in soil types or create their own custom soil profile.</p> In\u00a0[5]: Copied! <pre>sandy_loam = Soil(soil_type='SandyLoam')\n</pre> sandy_loam = Soil(soil_type='SandyLoam') <p>The crop type used in the simulation is selected in a similar way to soil via a <code>Crop</code>. To select a <code>Crop</code> you need to specify the crop type and planting date. Any of the built-in crop types (currently Maize, Wheat, Rice, Potato) can be selected by running the cell below. Appendix C details how a user can edit any of the built-in crop parameters or create custom crops.</p> In\u00a0[6]: Copied! <pre>wheat = Crop('Wheat', planting_date='10/01')\n</pre> wheat = Crop('Wheat', planting_date='10/01') In\u00a0[7]: Copied! <pre>InitWC = InitialWaterContent(value=['FC'])\n</pre> InitWC = InitialWaterContent(value=['FC']) <p>Additional model components you can specify include irrigation management, field management and groundwater conditions as well as field management during fallow periods. Details on how to specify these are detailed in Appendix D however they will all default to none if not specified.</p> <p>Once you have defined your weather data, <code>Crop</code>,  <code>Soil</code> and <code>InitWC</code> then you're ready to run your simulation.</p> <p>To run a simulation we need to combine the components we have selected into an <code>AquaCropModel</code>. It is here where we specify the simulation start date and end date (YYYY/MM/DD). Running the cell below will create an AquaCropModel simulation with all the parameters we have specified so far.</p> In\u00a0[8]: Copied! <pre># combine into aquacrop model and specify start and end simulation date\nmodel = AquaCropModel(sim_start_time=f'{1979}/10/01',\n                      sim_end_time=f'{1985}/05/30',\n                      weather_df=weather_data,\n                      soil=sandy_loam,\n                      crop=wheat,\n                      initial_water_content=InitWC)\n</pre> # combine into aquacrop model and specify start and end simulation date model = AquaCropModel(sim_start_time=f'{1979}/10/01',                       sim_end_time=f'{1985}/05/30',                       weather_df=weather_data,                       soil=sandy_loam,                       crop=wheat,                       initial_water_content=InitWC) <p>The model can then be run forwards N days using <code>.run_model(N)</code>. Most of the time you will want to instead run the model till the end of the simulation which is done by running <code>.run_model(till_termination=True)</code></p> In\u00a0[9]: Copied! <pre># run model till termination\nmodel.run_model(till_termination=True)\n</pre> # run model till termination model.run_model(till_termination=True) Out[9]: <pre>True</pre> <p>Once the model has finished running, four different output files will be produced. The <code>water_flux</code> output shows daily water flux variables such as total water storage. The <code>water_storage</code> output shows daily water storage in each compartment. The <code>crop_growth</code> output details daily crop variables such as canopy cover. The <code>final_stats</code> output lists the final Yield and total Irrigation for each season. These outputs can be accessed through the cell below. Use <code>.head(N)</code> to view the first <code>N</code> rows. Full details on the output files can be found in Appendix E.</p> In\u00a0[10]: Copied! <pre># model._outputs.water_flux.head()\n# model._outputs.water_storage.head()\n# model._outputs.crop_growth.head()\nmodel._outputs.final_stats.head()\n</pre> # model._outputs.water_flux.head() # model._outputs.water_storage.head() # model._outputs.crop_growth.head() model._outputs.final_stats.head() Out[10]: Season crop Type Harvest Date (YYYY/MM/DD) Harvest Date (Step) Yield (tonne/ha) Seasonal irrigation (mm) 0 0 Wheat 1980-04-15 196 8.940140 0 1 1 Wheat 1981-04-16 562 8.310045 0 2 2 Wheat 1982-04-16 927 9.136122 0 3 3 Wheat 1983-04-16 1292 8.811568 0 4 4 Wheat 1984-04-15 1657 8.682660 0 <p>Congratulations, you have run your first AquaCrop-OSPy model. As a final example, let's create and run another model with a different soil type and compare the results.</p> In\u00a0[11]: Copied! <pre># combine into aquacrop model and specify start and end simulation date\nmodel_clay = AquaCropModel(sim_start_time=f'{1979}/10/01',\n                      sim_end_time=f'{1985}/05/30',\n                      weather_df=weather_data,\n                      soil=Soil('Clay'),\n                      crop=wheat,\n                      initial_water_content=InitWC)\n\nmodel_clay.run_model(till_termination=True)\n</pre> # combine into aquacrop model and specify start and end simulation date model_clay = AquaCropModel(sim_start_time=f'{1979}/10/01',                       sim_end_time=f'{1985}/05/30',                       weather_df=weather_data,                       soil=Soil('Clay'),                       crop=wheat,                       initial_water_content=InitWC)  model_clay.run_model(till_termination=True) Out[11]: <pre>True</pre> <p>Let's use the pandas library to collate our seasonal yields so we can visualize our results.</p> In\u00a0[12]: Copied! <pre>import pandas as pd # import pandas library\n\nnames=['Sandy Loam','Clay']\n\n#combine our two output files\ndflist=[model._outputs.final_stats,\n        model_clay._outputs.final_stats] \n\noutlist=[]\nfor i in range(len(dflist)): # go through our two output files\n    temp = pd.DataFrame(dflist[i]['Yield (tonne/ha)']) # extract the seasonal yield data\n    temp['label']=names[i] # add the soil type label\n    outlist.append(temp) # save processed results\n\n# combine results\nall_outputs = pd.concat(outlist,axis=0)\n</pre> import pandas as pd # import pandas library  names=['Sandy Loam','Clay']  #combine our two output files dflist=[model._outputs.final_stats,         model_clay._outputs.final_stats]   outlist=[] for i in range(len(dflist)): # go through our two output files     temp = pd.DataFrame(dflist[i]['Yield (tonne/ha)']) # extract the seasonal yield data     temp['label']=names[i] # add the soil type label     outlist.append(temp) # save processed results  # combine results all_outputs = pd.concat(outlist,axis=0) <p>Now we can leverage some of pythons great plotting libraries <code>seaborn</code> and <code>matplotlib</code> to visualize and compare the yields from the two different soil types.</p> In\u00a0[13]: Copied! <pre>import matplotlib.pyplot as plt\nimport seaborn as sns\n\n#create figure\nfig,ax=plt.subplots(1,1,figsize=(10,7),)\n\n# create box plot\nsns.boxplot(data=all_outputs,x='label',y='Yield (tonne/ha)',ax=ax,)\n\n# labels and font sizes\nax.tick_params(labelsize=15)\nax.set_xlabel(' ')\nax.set_ylabel('Yield (tonne/ha)',fontsize=18)\n</pre> import matplotlib.pyplot as plt import seaborn as sns  #create figure fig,ax=plt.subplots(1,1,figsize=(10,7),)  # create box plot sns.boxplot(data=all_outputs,x='label',y='Yield (tonne/ha)',ax=ax,)  # labels and font sizes ax.tick_params(labelsize=15) ax.set_xlabel(' ') ax.set_ylabel('Yield (tonne/ha)',fontsize=18) Out[13]: <pre>Text(0, 0.5, 'Yield (tonne/ha)')</pre> <p>And this brings an end to Notebook 1. Feel free to edit any of the code cells, import your own weather data, try new soils and crops.</p> <p>In Notebook 2 we use the model to estimate irrigation water demands.</p> <p>AquaCrop-OSPy includes a number of in-built weather files for different locations around the world, which users can select for model simulations. These have been taken from AquaCrop defaults (with the exception of Champion Nebraska link). In-built weather files currently include:</p> <ol> <li>Tunis (date) | 'tunis_climate.txt'</li> <li>Brussels (date) | 'brussels_climate.txt'</li> <li>Hyderabad (date) | 'hyderabad_climate.txt'</li> <li>Champion, Nebraska (date) | 'champion_climate.txt'</li> </ol> <p>The filepath to these can be found using the <code>get_filepath</code> function and the data can be read in using the <code>prepare_weather</code> function.</p> In\u00a0[14]: Copied! <pre># get location of built in weather data file\npath = get_filepath('hyderabad_climate.txt')\n# read in weather data file and put into correct format\nwdf = prepare_weather(path)\n# show weather data\nwdf.head()\n</pre> # get location of built in weather data file path = get_filepath('hyderabad_climate.txt') # read in weather data file and put into correct format wdf = prepare_weather(path) # show weather data wdf.head() Out[14]: MinTemp MaxTemp Precipitation ReferenceET Date 0 11.3 27.3 0.0 3.6 2000-01-01 1 11.3 26.7 0.0 3.7 2000-01-02 2 8.6 26.7 0.0 3.4 2000-01-03 3 7.6 27.2 0.0 3.4 2000-01-04 4 9.1 27.9 0.0 3.4 2000-01-05 <p>Custom soil classes can be created by passing 'custom' as the soil type when creating a <code>Soil</code>. In the cell below we create a custom soil with a curve number (CN=46) and readily evaporable water (REW=7). Here is a full list of the parameters you can specify:</p> Variable Name Description Default soilType Soil classification e.g. 'sandy_loam' REQUIRED dz thickness of each soil compartment e.g. 12 compartments of thickness 0.1m [0.1]*12 CalcSHP Calculate soil hydraulic properties (0 = No, 1 = Yes) 0 AdjREW Adjust default value for readily evaporable water (0 = No, 1 = Yes) 1 REW Readily evaporable water (mm) 9.0 CalcCN Calculate curve number (0 = No, 1 = Yes) 1 CN Curve Number 61.0 zRes Depth of restrictive soil layer (negative value if not present) -999 The parameters below should not be changed without expert knowledge EvapZsurf Thickness of soil surface skin evaporation layer (m) 0.04 EvapZmin Minimum thickness of full soil surface evaporation layer (m) 0.15 EvapZmax Maximum thickness of full soil surface evaporation layer (m) 0.30 Kex Maximum soil evaporation coefficient 1.1 fevap Shape factor describing reduction in soil evaporation in stage 2. 4 fWrelExp Proportional value of Wrel at which soil evaporation layer expands 0.4 fwcc Maximum coefficient for soil evaporation reduction due to sheltering effect of withered canopy 50 zCN Thickness of soil surface (m) used to calculate water content to adjust curve number 0.3 zGerm Thickness of soil surface (m) used to calculate water content for germination 0.3 AdjCN Adjust curve number for antecedent moisture content (0: No, 1: Yes) 1 fshape_cr Capillary rise shape factor 16 zTop Thickness of soil surface layer for water stress comparisons (m) 0.1 In\u00a0[15]: Copied! <pre>custom = Soil('custom',cn=46,rew=7)\n</pre> custom = Soil('custom',cn=46,rew=7) <p>Soil hydraulic properties are then specified using <code>.add_layer()</code>. This function needs the thickness of the soil layer [m] (just the depth of soil profile if only using 1 layer), the water content at Wilting Point [m^3/m^3], Field Capacity [m^3/m^3], Saturation [m^3/m^3], as well as the hydraulic conductivity [mm/day] and soil penetrability [%].</p> In\u00a0[16]: Copied! <pre>custom.add_layer(thickness=custom.zSoil,thWP=0.24,\n                 thFC=0.40,thS=0.50,Ksat=155,\n                 penetrability=100)\n</pre> custom.add_layer(thickness=custom.zSoil,thWP=0.24,                  thFC=0.40,thS=0.50,Ksat=155,                  penetrability=100) <p>Soil hydraulic properties can also be specified using the soil textural composition. This is done using the <code>.add_layer_from_texture()</code> function. This function needs the soil thickness [m], sand, clay, organic matter content [%], and the penetrability [%]</p> In\u00a0[17]: Copied! <pre>custom = Soil('custom',cn=46,rew=7)\ncustom.add_layer_from_texture(thickness=custom.zSoil,\n                              Sand=10,Clay=35,\n                              OrgMat=2.5,penetrability=100)\n</pre> custom = Soil('custom',cn=46,rew=7) custom.add_layer_from_texture(thickness=custom.zSoil,                               Sand=10,Clay=35,                               OrgMat=2.5,penetrability=100) <p>To view your custom soil profile simple run the cell below.</p> In\u00a0[18]: Copied! <pre>custom.profile\n</pre> custom.profile Out[18]: Comp Layer dz dzsum zBot z_top zMid th_dry th_wp th_fc th_s Ksat penetrability tau 0 0 1.0 0.1 0.1 0.1 0.0 0.05 0.1075 0.215 0.382 0.511 136.4 100 0.48 1 1 1.0 0.1 0.2 0.2 0.1 0.15 0.1075 0.215 0.382 0.511 136.4 100 0.48 2 2 1.0 0.1 0.3 0.3 0.2 0.25 0.1075 0.215 0.382 0.511 136.4 100 0.48 3 3 1.0 0.1 0.4 0.4 0.3 0.35 0.1075 0.215 0.382 0.511 136.4 100 0.48 4 4 1.0 0.1 0.5 0.5 0.4 0.45 0.1075 0.215 0.382 0.511 136.4 100 0.48 5 5 1.0 0.1 0.6 0.6 0.5 0.55 0.1075 0.215 0.382 0.511 136.4 100 0.48 6 6 1.0 0.1 0.7 0.7 0.6 0.65 0.1075 0.215 0.382 0.511 136.4 100 0.48 7 7 1.0 0.1 0.8 0.8 0.7 0.75 0.1075 0.215 0.382 0.511 136.4 100 0.48 8 8 1.0 0.1 0.9 0.9 0.8 0.85 0.1075 0.215 0.382 0.511 136.4 100 0.48 9 9 1.0 0.1 1.0 1.0 0.9 0.95 0.1075 0.215 0.382 0.511 136.4 100 0.48 10 10 1.0 0.1 1.1 1.1 1.0 1.05 0.1075 0.215 0.382 0.511 136.4 100 0.48 11 11 1.0 0.1 1.2 1.2 1.1 1.15 0.1075 0.215 0.382 0.511 136.4 100 0.48 <p>Both these layer creation methods can be combined together to create multi layered soils. N.B. It is important to note that when you are using a multi layered soil profile, you must also specify a multi layered InitialWaterContent profile, otherwise the model will set all layers to the default Field Capacity (see Appendix D: Initial water content for full details).</p> In\u00a0[19]: Copied! <pre>custom = Soil('custom',cn=46,rew=7)\n\ncustom.add_layer(thickness=0.3,thWP=0.24,\n                 thFC=0.40,thS=0.50,Ksat=155,\n                 penetrability=100)\n\ncustom.add_layer_from_texture(thickness=1.5,\n                              Sand=10,Clay=35,\n                              OrgMat=2.5,penetrability=100)\n\ncustom.profile\n</pre> custom = Soil('custom',cn=46,rew=7)  custom.add_layer(thickness=0.3,thWP=0.24,                  thFC=0.40,thS=0.50,Ksat=155,                  penetrability=100)  custom.add_layer_from_texture(thickness=1.5,                               Sand=10,Clay=35,                               OrgMat=2.5,penetrability=100)  custom.profile Out[19]: Comp Layer dz dzsum zBot z_top zMid th_dry th_wp th_fc th_s Ksat penetrability tau 0 0 1.0 0.1 0.1 0.1 0.0 0.05 0.1200 0.240 0.400 0.500 155.0 100.0 0.51 1 1 1.0 0.1 0.2 0.2 0.1 0.15 0.1200 0.240 0.400 0.500 155.0 100.0 0.51 2 2 1.0 0.1 0.3 0.3 0.2 0.25 0.1200 0.240 0.400 0.500 155.0 100.0 0.51 3 3 2.0 0.1 0.4 0.4 0.3 0.35 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 4 4 2.0 0.1 0.5 0.5 0.4 0.45 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 5 5 2.0 0.1 0.6 0.6 0.5 0.55 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 6 6 2.0 0.1 0.7 0.7 0.6 0.65 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 7 7 2.0 0.1 0.8 0.8 0.7 0.75 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 8 8 2.0 0.1 0.9 0.9 0.8 0.85 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 9 9 2.0 0.1 1.0 1.0 0.9 0.95 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 10 10 2.0 0.1 1.1 1.1 1.0 1.05 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 11 11 2.0 0.1 1.2 1.2 1.1 1.15 0.1075 0.215 0.382 0.511 136.4 100.0 0.48 <p>In AquaCrop-OSPy, as in AquaCrop and AquaCrop-OS, the soil is split into compartments. By default these are 12 compartments of thickness 0.1m where the bottom layers will expand in order to exceed the maximum crop root depth.</p> <p>This depth (<code>dz</code>) can be also be altered by the user by changing the <code>dz</code> argument. For example: Lets say we want the top 6 compartments to be 0.1m each and the bottom 6 compartments to be 0.2m each...</p> In\u00a0[20]: Copied! <pre>sandy_loam = Soil('SandyLoam',dz=[0.1]*6+[0.2]*6)\n</pre> sandy_loam = Soil('SandyLoam',dz=[0.1]*6+[0.2]*6) <p>Similarly default soil types can be adjust by passing in the changed variables.</p> In\u00a0[21]: Copied! <pre>local_sandy_loam = Soil('SandyLoam',dz=[0.1]*6+[0.2]*6,cn=46,rew=7)\nlocal_sandy_loam.profile.head()\n</pre> local_sandy_loam = Soil('SandyLoam',dz=[0.1]*6+[0.2]*6,cn=46,rew=7) local_sandy_loam.profile.head() Out[21]: Comp Layer dz dzsum zBot z_top zMid th_dry th_wp th_fc th_s Ksat penetrability tau 0 0 1.0 0.1 0.1 0.1 0.0 0.05 0.05 0.1 0.22 0.41 1200 100 1 1 1 1.0 0.1 0.2 0.2 0.1 0.15 0.05 0.1 0.22 0.41 1200 100 1 2 2 1.0 0.1 0.3 0.3 0.2 0.25 0.05 0.1 0.22 0.41 1200 100 1 3 3 1.0 0.1 0.4 0.4 0.3 0.35 0.05 0.1 0.22 0.41 1200 100 1 4 4 1.0 0.1 0.5 0.5 0.4 0.45 0.05 0.1 0.22 0.41 1200 100 1 <p>It is more likely that the user will want to modify one of the built in crops (as opposed to modelling a brand new crop. To do this simply pass in the altered parameters when you create the <code>Crop</code>. Any parameters you specify here will override the crop defaults. To model a crop that does not have built in defaults, you can specify the crop type 'custom' and pass in all the parameters listed in the table below.</p> In\u00a0[22]: Copied! <pre>local_wheat = Crop('Wheat',\n                        planting_date='11/01',\n                        harvest_date='06/30',\n                        CGC = 0.0051,CDC = 0.0035)\n</pre> local_wheat = Crop('Wheat',                         planting_date='11/01',                         harvest_date='06/30',                         CGC = 0.0051,CDC = 0.0035) <p>Below is a full list of the crop parameters that can be altered.</p> <p>Variable Name | Default | Description --- | --- | --- Name | | Crop Name e.ge. 'maize' CropType | | Crop Type (1 = Leafy vegetable, 2 = Root/tuber, 3 = Fruit/grain) PlantMethod | | Planting method (0 = Transplanted, 1 =  Sown) CalendarType | | Calendar Type (1 = Calendar days, 2 = Growing degree days) SwitchGDD | | Convert calendar to GDD mode if inputs are given in calendar days (0 = No; 1 = Yes) PlantingDate | | Planting Date (mm/dd) HarvestDate | | Latest Harvest Date (mm/dd) Emergence  | | Growing degree/Calendar days from sowing to emergence/transplant recovery MaxRooting  | | Growing degree/Calendar days from sowing to maximum rooting Senescence  | | Growing degree/Calendar days from sowing to senescence Maturity  | | Growing degree/Calendar days from sowing to maturity HIstart  | | Growing degree/Calendar days from sowing to start of yield formation Flowering  | | Duration of flowering in growing degree/calendar days (-999 for non-fruit/grain crops) YldForm  | | Duration of yield formation in growing degree/calendar days GDDmethod  | | Growing degree day calculation method Tbase  | | Base temperature (degC) below which growth does not progress Tupp  | | Upper temperature (degC) above which crop development no longer increases PolHeatStress  | | Pollination affected by heat stress (0 = No, 1 = Yes) Tmax_up  | | Maximum air temperature (degC) above which pollination begins to fail Tmax_lo  | | Maximum air temperature (degC) at which pollination completely fails PolColdStress | | Pollination affected by cold stress (0 = No, 1 = Yes) Tmin_up  | | Minimum air temperature (degC) below which pollination begins to fail Tmin_lo  | | Minimum air temperature (degC) at which pollination completely fails TrColdStress  | | Transpiration affected by cold temperature stress (0 = No, 1 = Yes) GDD_up  | | Minimum growing degree days (degC/day) required for full crop transpiration potential GDD_lo | | Growing degree days (degC/day) at which no crop transpiration occurs Zmin  | | Minimum effective rooting depth (m) Zmax  | | Maximum rooting depth (m) fshape_r | | Shape factor describing root expansion SxTopQ  | | Maximum root water extraction at top of the root zone (m3/ m3/ day) SxBotQ  | | Maximum root water extraction at the bottom of the root zone (m3/ m3/ day) SeedSize | | Soil surface area (cm2) covered by an individual seedling at 90% emergence PlantPop | | Number of plants per hectare CCx   | | Maximum canopy cover (fraction of soil cover) CDC  | | Canopy decline coefficient (fraction per GDD/calendar day) CGC | | Canopy growth coefficient (fraction per GDD) Kcb  | | Crop coefficient when canopy growth is complete but prior to senescence fage | |  Decline of crop coefficient due to ageing (%/day) WP  | | Water productivity normalized for ET0 and C02 (g/m2) WPy | | Adjustment of water productivity in yield formation stage (% of WP) fsink  | | Crop performance under elevated atmospheric CO2 concentration (%/100) HI0  | | Reference harvest index dHI_pre  | | Possible increase of harvest index due to water stress before flowering (%) a_HI  | | Coefficient describing positive impact on harvest index of restricted vegetative growth during yield formation b_HI | | Coefficient describing negative impact on harvest index of stomatal closure during yield formation dHI0 | | Maximum allowable increase of harvest index above reference value Determinant  | | Crop Determinacy (0 = Indeterminant, 1 = Determinant) exc  | | Excess of potential fruits p_up1 | | Upper soil water depletion threshold for water stress effects on affect canopy expansion p_up2  | | Upper soil water depletion threshold for water stress effects on canopy stomatal control p_up3  | | Upper soil water depletion threshold for water stress effects on canopy senescence p_up4  | | Upper soil water depletion threshold for water stress effects on canopy pollination p_lo1  | | Lower soil water depletion threshold for water stress effects on canopy expansion p_lo2 | | Lower soil water depletion threshold for water stress effects on canopy stomatal control p_lo3 | |  Lower soil water depletion threshold for water stress effects on canopy senescence p_lo4  | | Lower soil water depletion threshold for water stress effects on canopy pollination fshape_w1  | | Shape factor describing water stress effects on canopy expansion fshape_w2 | | Shape factor describing water stress effects on stomatal control fshape_w3  | | Shape factor describing water stress effects on canopy senescence fshape_w4 | | Shape factor describing water stress effects on pollination | | The paramaters below should not be changed without expert knowledge fshape_b | 13.8135 | Shape factor describing the reduction in biomass production for insufficient growing degree days PctZmin | 70 | Initial percentage of minimum effective rooting depth fshape_ex | -6 | Shape factor describing the effects of water stress on root expansion ETadj | 1 | Adjustment to water stress thresholds depending on daily ET0 (0 | No, 1 | Yes) Aer | 5 | Vol (%) below saturation at which stress begins to occur due to deficient aeration LagAer | 3 | Number of days lag before aeration stress affects crop growth beta | 12 | Reduction (%) to p_lo3 when early canopy senescence is triggered a_Tr | 1 | Exponent parameter for adjustment of Kcx once senescence is triggered GermThr | 0.2 | Proportion of total water storage needed for crop to germinate CCmin | 0.05 | Minimum canopy size below which yield formation cannot occur MaxFlowPct | 33.3 | Proportion of total flowering time (%) at which peak flowering occurs HIini | 0.01 | Initial harvest index bsted | 0.000138 | WP co2 adjustment parameter given by Steduto et al. 2007 bface | 0.001165 | WP co2 adjustment parameter given by FACE experiments</p> <p>Field management and groundwater conditions can also be specified in an AquaCrop-OSPy with a <code>FieldMngt</code> and <code>GroundWater</code> class object respectively. If these are not specified then they will default to None.</p> <p>Field Management is specified via the <code>FieldMngt</code>. These are largely based around the inclusion of either mulches or bunds. Two <code>FieldMngt</code> objects can be created for the fallow and growing period. The parameters you can specify in a <code>FieldMngt</code> are:</p> Variable Name Type Description Default Mulches <code>bool</code> Soil surface covered by mulches (True or False) False MulchPct <code>float</code> Area of soil surface covered by mulches (%) 50 fMulch <code>float</code> Soil evaporation adjustment factor due to effect of mulches 0.5 Bunds <code>bool</code> Surface bunds present (True or False) False zBund <code>float</code> Bund height (m) 0 BundWater <code>float</code> Initial water height in surface bunds (mm) 0. CNadj <code>bool</code> field conditions affect curve number (True or False) False CNadjPct <code>float</code> Change in curve number (positive or negative) (%) 0 SRinhb <code>bool</code> Management practices fully inhibit surface runoff (True or False) False <p>In the cell below we create an <code>AquaCropModel</code> passing in a <code>FieldMngt</code> with 100% field covering by mulches.</p> In\u00a0[23]: Copied! <pre>mulches_model = AquaCropModel(sim_start_time=f'{1979}/10/01',\n                      sim_end_time=f'{1985}/05/30',\n                      weather_df=weather_data,\n                      soil=sandy_loam,\n                      crop=wheat,\n                      initial_water_content=InitWC,                      \n                      field_management=FieldMngt(mulches=True,\n                                               mulch_pct=100,\n                                               f_mulch=0.5))\n</pre> mulches_model = AquaCropModel(sim_start_time=f'{1979}/10/01',                       sim_end_time=f'{1985}/05/30',                       weather_df=weather_data,                       soil=sandy_loam,                       crop=wheat,                       initial_water_content=InitWC,                                             field_management=FieldMngt(mulches=True,                                                mulch_pct=100,                                                f_mulch=0.5))  In\u00a0[24]: Copied! <pre>mulches_model.run_model(till_termination=True)\n</pre> mulches_model.run_model(till_termination=True)  Out[24]: <pre>True</pre> In\u00a0[25]: Copied! <pre># get final output\nmulches_model._outputs.final_stats\n</pre> # get final output mulches_model._outputs.final_stats Out[25]: Season crop Type Harvest Date (YYYY/MM/DD) Harvest Date (Step) Yield (tonne/ha) Seasonal irrigation (mm) 0 0 Wheat 1980-04-15 196 8.940140 0 1 1 Wheat 1981-04-16 562 8.310045 0 2 2 Wheat 1982-04-16 927 9.136756 0 3 3 Wheat 1983-04-16 1292 8.811568 0 4 4 Wheat 1984-04-15 1657 8.682660 0 5 5 Wheat 1985-04-16 2023 8.924816 0 <p>We can also take a look at how to specify groundwater depth. This is done via the <code>GroundWater</code> which takes in the following parameters:</p> Variable Name Type Description Default WaterTable <code>str</code> water table considered 'Y' or 'N' 'N' Method <code>str</code> Water table input data = 'Constant' / 'Variable' 'Constant' dates <code>list[str]</code> water table observation dates 'YYYYMMDD' [] values <code>list[float]</code> value at that location [] <p>The <code>GroundWater</code> needs a list of dates and water table depths. If <code>Method='Variable'</code> the water table depth will be linearly interpolated between these dates. The cell below creates a model with a constant groundwater depth of 2m</p> In\u00a0[26]: Copied! <pre># constant groundwater depth of 2m\ngw_model = AquaCropModel(sim_start_time=f'{1979}/10/01',\n                      sim_end_time=f'{1985}/05/30',\n                      weather_df=weather_data,\n                      soil=sandy_loam,\n                      crop=wheat,\n                      initial_water_content=InitWC,            \n                      groundwater=GroundWater(water_table='Y',\n                                       dates=[f'{1979}/10/01'],\n                                       values=[2])\n                    )\n</pre> # constant groundwater depth of 2m gw_model = AquaCropModel(sim_start_time=f'{1979}/10/01',                       sim_end_time=f'{1985}/05/30',                       weather_df=weather_data,                       soil=sandy_loam,                       crop=wheat,                       initial_water_content=InitWC,                                   groundwater=GroundWater(water_table='Y',                                        dates=[f'{1979}/10/01'],                                        values=[2])                     ) In\u00a0[27]: Copied! <pre>gw_model.run_model(till_termination=True)\n</pre> gw_model.run_model(till_termination=True) Out[27]: <pre>True</pre> In\u00a0[28]: Copied! <pre>gw_model._outputs.final_stats\n</pre> gw_model._outputs.final_stats Out[28]: Season crop Type Harvest Date (YYYY/MM/DD) Harvest Date (Step) Yield (tonne/ha) Seasonal irrigation (mm) 0 0 Wheat 1980-04-15 196 8.940140 0 1 1 Wheat 1981-04-16 562 8.310045 0 2 2 Wheat 1982-04-16 927 9.136769 0 3 3 Wheat 1983-04-16 1292 8.811568 0 4 4 Wheat 1984-04-15 1657 8.682660 0 5 5 Wheat 1985-04-16 2023 8.924816 0 <p>Finally, we can look at how to modify the initial water content. As a reminder from earlier in the notebook, here are the input parameters to choose from:</p> Variable Name Type Description Default wc_type <code>str</code> Type of value 'Prop' 'Prop' = 'WP' / 'FC' / 'SAT' 'Num' = XXX m3/m3 'Pct' = % TAW Method <code>str</code> 'Depth' = Interpolate depth points; 'Layer' = Constant value for each soil layer 'Layer' depth_layer <code>list</code> locations in soil profile (soil layer or depth) [1] value <code>list</code> value at that location ['FC'] <p>In the cell below, we initialize the water content to be Field Capacity (FC) accross the whole soil profile like before, followed by an identical initial water content with all default values specified for clarity.</p> In\u00a0[\u00a0]: Copied! <pre># Default WC at Field Capacity:\nInitWC = InitialWaterContent(value=['FC'])\n\n# Same default WC but displaying all parameter values:\ndefaultWC = InitialWaterContent(wc_type = 'Prop',\n                               method = 'Layer',\n                               depth_layer= [1],\n                               value = ['FC'])\n</pre> # Default WC at Field Capacity: InitWC = InitialWaterContent(value=['FC'])  # Same default WC but displaying all parameter values: defaultWC = InitialWaterContent(wc_type = 'Prop',                                method = 'Layer',                                depth_layer= [1],                                value = ['FC']) <p>For illustrative purposes, here is a range of possible initial water content specifications using the full range of AquaCrop's options:</p> In\u00a0[\u00a0]: Copied! <pre># Specify WC by Wilting Point (WP)\nwpWC =  InitialWaterContent(wc_type = 'Prop',\n                            method = 'Layer',\n                            depth_layer= [1],\n                            value = ['WP'])\n\n# Specify WC by saturation (SAT)\nsatWC = InitialWaterContent(wc_type = 'Prop',\n                            method = 'Layer',\n                            depth_layer= [1],\n                            value = ['SAT'])\n\n# Specify WC by percentage of Total Available Water (% TAW)\ntawWC = InitialWaterContent(wc_type = 'Pct',\n                            method = 'Layer',\n                            depth_layer= [1],\n                            value = [80])\n\n# Specify WC by an amount of water (m3/m3)\nnumWC = InitialWaterContent(wc_type = 'Prop',\n                            method = 'Layer',\n                            depth_layer= [1],\n                            value = [0.2])\n</pre> # Specify WC by Wilting Point (WP) wpWC =  InitialWaterContent(wc_type = 'Prop',                             method = 'Layer',                             depth_layer= [1],                             value = ['WP'])  # Specify WC by saturation (SAT) satWC = InitialWaterContent(wc_type = 'Prop',                             method = 'Layer',                             depth_layer= [1],                             value = ['SAT'])  # Specify WC by percentage of Total Available Water (% TAW) tawWC = InitialWaterContent(wc_type = 'Pct',                             method = 'Layer',                             depth_layer= [1],                             value = [80])  # Specify WC by an amount of water (m3/m3) numWC = InitialWaterContent(wc_type = 'Prop',                             method = 'Layer',                             depth_layer= [1],                             value = [0.2]) <p>You can also create multi layered initial water content (IWC) profiles by increasing the length of the 'depth_layer' and 'value' lists, where the first value relates to the first (uppermost) soil layer. This is especially important when specifying custom multi layered soil profiles - if the number of layers in your IWC profile does not match the number of layers in your soil profile, the IWC of all soil layers will be set to Field Capacity.</p> In\u00a0[\u00a0]: Copied! <pre># If you have more than one soil layer, you can specify the initial water content of each layer. \n# e.g. for soil profile with two layers, first filled to Field Capacity, second to Wilting Point:\nmultiWC =   InitialWaterContent(wc_type = 'Prop',\n                                method = 'Layer',\n                                depth_layer= [1,2],\n                                value = ['FC', 'WP'])\n\n# Alternatively you could specify two different % TAWs:\nmultiTawWC = InitialWaterContent(wc_type = 'Pct',\n                                method = 'Layer',\n                                depth_layer= [1,2],\n                                value = [80, 50])\n</pre> # If you have more than one soil layer, you can specify the initial water content of each layer.  # e.g. for soil profile with two layers, first filled to Field Capacity, second to Wilting Point: multiWC =   InitialWaterContent(wc_type = 'Prop',                                 method = 'Layer',                                 depth_layer= [1,2],                                 value = ['FC', 'WP'])  # Alternatively you could specify two different % TAWs: multiTawWC = InitialWaterContent(wc_type = 'Pct',                                 method = 'Layer',                                 depth_layer= [1,2],                                 value = [80, 50]) <p>There are 4 different outputs produced by the model:</p> <ol> <li>Daily Water Flux</li> </ol> Variable Name Unit water content mm groundwater depth mm surface storage mm irrigation mm infiltration mm runoff mm deep percolation mm capillary rise mm groundwater inflow mm actual surface evaporation mm potential surface evaporation mm actual transpiration mm precipitation mm <ol> <li>Soil-water content in each soil compartment</li> </ol> Variable Name Unit compartment water content mm/mm <ol> <li>Crop growth</li> </ol> Variable Name Unit growing degree days - cumulative growing degree days - root depth m canopy cover - canopy cover (no stress) - biomass kg/ha biomass (no stress) kg/ha harvest index - adjusted harvest index - yield t/ha <ol> <li>Final summary (seasonal total)</li> </ol> Variable Name Unit yield t/ha total irrigation mm <p>Use the <code>.head(N)</code> command to view the first N entries of the output files below</p> In\u00a0[29]: Copied! <pre># model._outputs.water_flux.head()\n# model._outputs.water_storage.head()\n# model._outputs.crop_growth.head()\nmodel._outputs.final_stats.head()\n</pre> # model._outputs.water_flux.head() # model._outputs.water_storage.head() # model._outputs.crop_growth.head() model._outputs.final_stats.head() Out[29]: Season crop Type Harvest Date (YYYY/MM/DD) Harvest Date (Step) Yield (tonne/ha) Seasonal irrigation (mm) 0 0 Wheat 1980-04-15 196 8.940140 0 1 1 Wheat 1981-04-16 562 8.310045 0 2 2 Wheat 1982-04-16 927 9.136122 0 3 3 Wheat 1983-04-16 1292 8.811568 0 4 4 Wheat 1984-04-15 1657 8.682660 0 In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#aquacrop-ospy-bridging-the-gap-between-research-and-practice-in-crop-water-modelling","title":"AquaCrop-OSPy: Bridging the gap between research and practice in crop-water modelling\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#notebook-1-getting-started-running-your-first-simulation-with-aquacrop-ospy","title":"Notebook 1: Getting started: Running your first simulation with AquaCrop-OSPy\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#notes-on-google-colab","title":"Notes on Google Colab\u00b6","text":"<p>If you are unfamiliar with Jupyter Notebooks or Google Colab, here is an introductory notebook to get you started. In short, these are computable documents that let you combine text blocks such as these (including html, LaTeX, etc.) with code blocks that you can write, edit and execute. To run the code in each cell either click the run button in the cell's top left corner or hit SHIFT-ENTER when the cell is selected. You can also navigate through the document using the table of contents on the left hand side.</p> <p>We recommend you save a copy of this notebook to your dive (File-&gt;Save a copy to drive). Then any changes you make to this notebook will be saved and you can open it it again at any time and carry on.</p>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#imports","title":"Imports\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#selecting-model-components","title":"Selecting Model Components\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#climate-measurements","title":"Climate Measurements\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#soil","title":"Soil\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#crop","title":"Crop\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#initial-water-content","title":"Initial water content\u00b6","text":"<p>Specifying the intial soil-water content at the begining of the simulation is done via the <code>InitialWaterContent</code>. When creating an <code>InitialWaterContent</code>, it needs a list of locations and soil water contents. This table below details all the input paramaters for the <code>InitialWaterContent</code>. For a more detailed example, see the third section of Appendix D: Initial water content.</p> Variable Name Type Description Default wc_type <code>str</code> Type of value 'Prop' 'Prop' = 'WP' / 'FC' / 'SAT' 'Num' = XXX m3/m3 'Pct' = % TAW Method <code>str</code> 'Depth' = Interpolate depth points; 'Layer' = Constant value for each soil layer 'Layer' depth_layer <code>list</code> locations in soil profile (soil layer or depth) [1] value <code>list</code> value at that location ['FC'] <p>In the cell below we initialize the water content to be Field Capacity (FC) accross the whole soil profile.</p>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#model","title":"Model\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#appendix-a-built-in-weather-files","title":"Appendix A: Built-in weather files\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#appendix-b-custom-soils","title":"Appendix B: Custom Soils\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#apendix-c-custom-crops","title":"Apendix C: Custom Crops\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#appendix-d-managment-and-initial-conditions","title":"Appendix D: Managment and initial conditions\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#field-management","title":"Field management\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#groundwater","title":"Groundwater\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#initial-water-content","title":"Initial water content\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_1/#appendix-e-output-files","title":"Appendix E: Output files\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_2/","title":"Estimating Irrigation Demand","text":"<p>This series of notebooks provides users with an introduction to AquaCrop-OSPy, an open-source Python implementation of the U.N. Food and Agriculture Organization (FAO) AquaCrop model. AquaCrop-OSPy is accompanied by a series of Jupyter notebooks, which guide users interactively through a range of common applications of the model. Only basic Python experience is required, and the notebooks can easily be extended and adapted by users for their own applications and needs.</p> <p>This notebook series consists of four parts:</p> <ol> <li>Running an AquaCrop-OSPy model</li> <li>Estimation of irrigation water demands</li> <li>Optimisation of irrigation management strategies</li> <li>Projection of climate change impacts</li> </ol> <p>Install and import aquacrop as we did in Notebook 1.</p> In\u00a0[\u00a0]: Copied! <pre># !pip install aquacrop\n\n# from google.colab import output\n# output.clear()\n</pre> # !pip install aquacrop  # from google.colab import output # output.clear() <p>If for any reason you would rather not compile the aquacrop modules ahead-of-time, you can run the following cell to run the notebook in pure python (N.B. it will run slower).</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['DEVELOPMENT'] = 'True'\n</pre> # import os # os.environ['DEVELOPMENT'] = 'True' In\u00a0[1]: Copied! <pre>from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement\nfrom aquacrop.utils import prepare_weather, get_filepath\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n</pre> from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement from aquacrop.utils import prepare_weather, get_filepath  import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns <p>In Notebook 1, we learned how to create an <code>AquaCropModel</code> by selecting a weather data file, <code>Soil</code>, <code>Crop</code> and <code>InitialWaterContent</code> (initial water content). In this notebook, we show how AquaCrop-OSPy can be used to explore impacts of different irrigation management strategies on water use and crop yields. The example workflow below shows how different irrigation management practices can be defined in the model, and resulting impacts on water use productivity explored to support efficient irrigation scheduling and planning decisions.</p> <p>We start by creating a weather DataFrame containing daily measurements of minimum temperature, maximum temperature, precipitation and reference evapotranspiration. In this example we will use the built in file containing weather data from Champion, Nebraska, USA. (link).</p> In\u00a0[2]: Copied! <pre>path = get_filepath('champion_climate.txt')\nwdf = prepare_weather(path)\nwdf\n</pre> path = get_filepath('champion_climate.txt') wdf = prepare_weather(path) wdf Out[2]: MinTemp MaxTemp Precipitation ReferenceET Date 0 -21.11 3.33 0.0 1.59 1982-01-01 1 -10.00 0.56 0.0 0.86 1982-01-02 2 -11.67 -2.22 0.0 0.72 1982-01-03 3 -12.22 7.22 0.0 1.71 1982-01-04 4 -14.44 -1.11 0.0 0.92 1982-01-05 ... ... ... ... ... ... 13509 -7.93 -2.01 0.0 0.52 2018-12-27 13510 -15.52 -5.35 0.0 0.62 2018-12-28 13511 -17.23 2.76 0.0 1.37 2018-12-29 13512 -11.28 10.96 0.0 2.13 2018-12-30 13513 -13.80 0.19 0.0 1.04 2018-12-31 <p>13514 rows \u00d7 5 columns</p> <p>We will run a 37 season simulation starting at 1982-05-01 and ending on 2018-10-30</p> In\u00a0[3]: Copied! <pre>sim_start = '1982/05/01'\nsim_end = '2018/10/30'\n</pre> sim_start = '1982/05/01' sim_end = '2018/10/30' <p>Next we must define a soil, crop and initial soil water content. This is done by creating a <code>Soil</code>, <code>Crop</code> and <code>InitialWaterContent</code>. In this example we select a sandy loam soil, a Maize crop, and with the soil initially at Field Capacity.</p> In\u00a0[4]: Copied! <pre>soil= Soil('SandyLoam')\n\ncrop = Crop('Maize',planting_date='05/01')\n\ninitWC = InitialWaterContent(value=['FC'])\n</pre> soil= Soil('SandyLoam')  crop = Crop('Maize',planting_date='05/01')  initWC = InitialWaterContent(value=['FC']) <p>Irrigation management parameters are selected by creating an <code>IrrigationManagement</code> object. With this class we can specify a range of different irrigation management strategies. The 6 different strategies can be selected using the <code>IrrMethod</code> argument when creating the class. These strategies are as follows:</p> <ul> <li><code>IrrMethod=0</code>: Rainfed (no irrigation)</li> <li><code>IrrMethod=1</code>: Irrigation is triggered if soil water content drops below a specified threshold (or four thresholds representing four major crop growth stages (emergence, canopy growth, max canopy, senescence).</li> <li><code>IrrMethod=2</code>: Irrigation is triggered every N days</li> <li><code>IrrMethod=3</code>: Predefined irrigation schedule</li> <li><code>IrrMethod=4</code>: Net irrigation (maintain a soil-water level by topping up all compartments daily)</li> <li><code>IrrMethod=5</code>: Constant depth applied each day</li> </ul> <p>The full list of parameters you can edit are:</p> <p>Variable Name | Type | Description | Default --- | --- | --- | --- IrrMethod| <code>int</code> | Irrigation method: | 0 || 0 : rainfed | || 1 : soil moisture targets || 2 : set time interval | || 3: predefined schedule | || 4: net irrigation | || 5: constant depth | SMT | <code>list[float]</code> | Soil moisture targets (%TAW) to maintain in each growth stage  | [100,100,100,100] || (only used if irrigation method is equal to 1) | IrrInterval  | <code>int</code> | Irrigation interval in days | 3 || (only used if irrigation method is equal to 2) | Schedule | <code>pandas.DataFrame</code> | DataFrame containing dates and depths | None || (only used if irrigation method is equal to 3) | NetIrrSMT | <code>float</code> | Net irrigation threshold moisture level (% of TAW that will be maintained) | 80. || (only used if irrigation method is equal to 4) | depth  | <code>float</code> | constant depth (mm) to apply on each day | 0. || (only used if irrigation method is equal to 5) | WetSurf | <code>int</code> | Soil surface wetted by irrigation (%) | 100 AppEff | <code>int</code> |  Irrigation application efficiency (%) | 100 MaxIrr |  <code>float</code> | Maximum depth (mm) that can be applied each day | 25 MaxIrrSeason |  <code>float</code> | Maximum total irrigation (mm) that can be applied in one season | 10_000</p> <p>For the purposes of this demonstration we will investigate the yields and irrigation applied for a range of constant soil-moisture thresholds. Meaning that all 4 soil-moisture thresholds are equal. These irrigation strategies will be compared over a 37 year period. The cell below will create and run an <code>AquaCropModel</code> for each irrigation strategy and save the final output.</p> In\u00a0[5]: Copied! <pre># define labels to help after\nlabels=[]\n\noutputs=[]\nfor smt in range(0,110,20):\n    crop.Name = str(smt) # add helpfull label\n    labels.append(str(smt))\n    irr_mngt = IrrigationManagement(irrigation_method=1,SMT=[smt]*4) # specify irrigation management\n    model = AquaCropModel(sim_start,\n                        sim_end,\n                        wdf,\n                        soil,\n                        crop,\n                        initial_water_content=initWC,\n                        irrigation_management=irr_mngt) # create model\n    model.run_model(till_termination=True) # run model till the end\n    outputs.append(model._outputs.final_stats) # save results\n</pre> # define labels to help after labels=[]  outputs=[] for smt in range(0,110,20):     crop.Name = str(smt) # add helpfull label     labels.append(str(smt))     irr_mngt = IrrigationManagement(irrigation_method=1,SMT=[smt]*4) # specify irrigation management     model = AquaCropModel(sim_start,                         sim_end,                         wdf,                         soil,                         crop,                         initial_water_content=initWC,                         irrigation_management=irr_mngt) # create model     model.run_model(till_termination=True) # run model till the end     outputs.append(model._outputs.final_stats) # save results <p>Combine results so that they can be easily visualized.</p> In\u00a0[6]: Copied! <pre>import pandas as pd\n\ndflist=outputs\nlabels[0]='Rainfed'\noutlist=[]\nfor i in range(len(dflist)):\n    temp = pd.DataFrame(dflist[i][['Yield (tonne/ha)',\n                                   'Seasonal irrigation (mm)']])\n    temp['label']=labels[i]\n    outlist.append(temp)\n\nall_outputs = pd.concat(outlist,axis=0)\n</pre> import pandas as pd  dflist=outputs labels[0]='Rainfed' outlist=[] for i in range(len(dflist)):     temp = pd.DataFrame(dflist[i][['Yield (tonne/ha)',                                    'Seasonal irrigation (mm)']])     temp['label']=labels[i]     outlist.append(temp)  all_outputs = pd.concat(outlist,axis=0) In\u00a0[7]: Copied! <pre># combine all results\nresults=pd.concat(outlist)\n</pre> # combine all results results=pd.concat(outlist) <p>Use <code>matplotlib</code> and <code>seaborn</code> to show the range of yields and total irrigation for each strategy over the simulation years.</p> In\u00a0[8]: Copied! <pre># import plotting libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# create figure consisting of 2 plots\nfig,ax=plt.subplots(2,1,figsize=(10,14))\n\n# create two box plots\nsns.boxplot(data=results,x='label',y='Yield (tonne/ha)',ax=ax[0])\nsns.boxplot(data=results,x='label',y='Seasonal irrigation (mm)',ax=ax[1])\n\n# labels and font sizes\nax[0].tick_params(labelsize=15)\nax[0].set_xlabel('Soil-moisture threshold (%TAW)',fontsize=18)\nax[0].set_ylabel('Yield (t/ha)',fontsize=18)\n\nax[1].tick_params(labelsize=15)\nax[1].set_xlabel('Soil-moisture threshold (%TAW)',fontsize=18)\nax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18)\n\nplt.legend(fontsize=18)\n</pre> # import plotting libraries import matplotlib.pyplot as plt import seaborn as sns  # create figure consisting of 2 plots fig,ax=plt.subplots(2,1,figsize=(10,14))  # create two box plots sns.boxplot(data=results,x='label',y='Yield (tonne/ha)',ax=ax[0]) sns.boxplot(data=results,x='label',y='Seasonal irrigation (mm)',ax=ax[1])  # labels and font sizes ax[0].tick_params(labelsize=15) ax[0].set_xlabel('Soil-moisture threshold (%TAW)',fontsize=18) ax[0].set_ylabel('Yield (t/ha)',fontsize=18)  ax[1].tick_params(labelsize=15) ax[1].set_xlabel('Soil-moisture threshold (%TAW)',fontsize=18) ax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18)  plt.legend(fontsize=18)  <pre>No handles with labels found to put in legend.\n</pre> Out[8]: <pre>&lt;matplotlib.legend.Legend at 0x7f01c952d190&gt;</pre> <p>Testing different irrigation strategies is as simple as creating multiple <code>IrrMngtClass</code> objects. The first strategy we will test is rainfed growth (no irrigation).</p> In\u00a0[9]: Copied! <pre># define irrigation management\nrainfed = IrrigationManagement(irrigation_method=0)\n</pre> # define irrigation management rainfed = IrrigationManagement(irrigation_method=0) <p>The second strategy triggers irrigation if the root-zone water content drops below an irrigation threshold. There are 4 thresholds corresponding to four main crop growth stages (emergence, canopy growth, max canopy,  canopy senescence). The quantity of water applied is given by <code>min(depletion,MaxIrr)</code> where <code>MaxIrr</code> can be specified when creating an <code>IrrMngtClass</code>.</p> In\u00a0[10]: Copied! <pre># irrigate according to 4 different soil-moisture thresholds\nthreshold4_irrigate = IrrigationManagement(irrigation_method=1,SMT=[40,60,70,30]*4)\n</pre> # irrigate according to 4 different soil-moisture thresholds threshold4_irrigate = IrrigationManagement(irrigation_method=1,SMT=[40,60,70,30]*4) <p>The third strategy irrigates every <code>IrrInterval</code> days where the quantity of water applied is given by <code>min(depletion,MaxIrr)</code> where <code>MaxIrr</code> can be specified when creating an <code>IrrMngtClass</code>.</p> In\u00a0[11]: Copied! <pre># irrigate every 7 days\ninterval_7 = IrrigationManagement(irrigation_method=2,IrrInterval=7)\n</pre> # irrigate every 7 days interval_7 = IrrigationManagement(irrigation_method=2,IrrInterval=7) <p>The fourth strategy irrigates according to a predefined calendar. This calendar is defined as a pandas DataFrame and this example, we will create a calendar that irrigates on the first Tuesday of each month.</p> In\u00a0[12]: Copied! <pre>import pandas as pd # import pandas library\n\nall_days = pd.date_range(sim_start,sim_end) # list of all dates in simulation period\n\nnew_month=True\ndates=[]\n# iterate through all simulation days\nfor date in all_days:\n    #check if new month\n    if date.is_month_start:\n        new_month=True\n\n    if new_month:\n        # check if tuesday (dayofweek=1)\n        if date.dayofweek==1:\n            #save date\n            dates.append(date)\n            new_month=False\n</pre> import pandas as pd # import pandas library  all_days = pd.date_range(sim_start,sim_end) # list of all dates in simulation period  new_month=True dates=[] # iterate through all simulation days for date in all_days:     #check if new month     if date.is_month_start:         new_month=True      if new_month:         # check if tuesday (dayofweek=1)         if date.dayofweek==1:             #save date             dates.append(date)             new_month=False <p>Now we have a list of all the first Tuesdays of the month, we can create the full schedule.</p> In\u00a0[13]: Copied! <pre>depths = [25]*len(dates) # depth of irrigation applied\nschedule=pd.DataFrame([dates,depths]).T # create pandas DataFrame\nschedule.columns=['Date','Depth'] # name columns\n\nschedule\n</pre> depths = [25]*len(dates) # depth of irrigation applied schedule=pd.DataFrame([dates,depths]).T # create pandas DataFrame schedule.columns=['Date','Depth'] # name columns  schedule Out[13]: Date Depth 0 1982-05-04 25 1 1982-06-01 25 2 1982-07-06 25 3 1982-08-03 25 4 1982-09-07 25 ... ... ... 433 2018-06-05 25 434 2018-07-03 25 435 2018-08-07 25 436 2018-09-04 25 437 2018-10-02 25 <p>438 rows \u00d7 2 columns</p> <p>Then pass this schedule into our <code>IrrMngtClass</code>.</p> In\u00a0[14]: Copied! <pre>irrigate_schedule = IrrigationManagement(irrigation_method=3,schedule=schedule)\n</pre> irrigate_schedule = IrrigationManagement(irrigation_method=3,schedule=schedule) <p>The fifth strategy is net irrigation. This keeps the soil-moisture content above a specified level. This method differs from the soil moisture thresholds (second strategy) as each compartment is filled to field capacity, instead of water starting above the first compartment and filtering down. In this example the net irrigation mode will maintain a water content of 70% total available water.</p> In\u00a0[15]: Copied! <pre>net_irrigation = IrrigationManagement(irrigation_method=4,NetIrrSMT=70)\n</pre> net_irrigation = IrrigationManagement(irrigation_method=4,NetIrrSMT=70) <p>Now its time to compare the strategies over the 37 year period. The cell below will create and run an <code>AquaCropModel</code> for each irrigation strategy and save the final output.</p> In\u00a0[16]: Copied! <pre># define labels to help after\nlabels=['rainfed','four thresholds','interval','schedule','net']\nstrategies = [rainfed,threshold4_irrigate,interval_7,irrigate_schedule,net_irrigation]\n\noutputs=[]\nfor i,irr_mngt in enumerate(strategies): # for both irrigation strategies...\n    crop.Name = labels[i] # add helpfull label\n    model = AquaCropModel(sim_start,\n                        sim_end,\n                        wdf,\n                        soil,\n                        crop,\n                        initial_water_content=initWC,\n                        irrigation_management=irr_mngt) # create model\n    model.run_model(till_termination=True) # run model till the end\n    outputs.append(model._outputs.final_stats) # save results\n</pre> # define labels to help after labels=['rainfed','four thresholds','interval','schedule','net'] strategies = [rainfed,threshold4_irrigate,interval_7,irrigate_schedule,net_irrigation]  outputs=[] for i,irr_mngt in enumerate(strategies): # for both irrigation strategies...     crop.Name = labels[i] # add helpfull label     model = AquaCropModel(sim_start,                         sim_end,                         wdf,                         soil,                         crop,                         initial_water_content=initWC,                         irrigation_management=irr_mngt) # create model     model.run_model(till_termination=True) # run model till the end     outputs.append(model._outputs.final_stats) # save results <p>The final strategy to show is for a custom irrigation strategy. This is one of the key features of AquaCrop-OSPy as users can define an a complex irrigation strategy that incorperates any external data, code bases or machine learning models. To showcase this feature, we will  define a function that will irrigate according to the follwong logic:</p> <ol> <li><p>There will be no rain over the next 10 days -&gt; Irrigate 10mm</p> </li> <li><p>There will be rain in the next 10 days but the soil is over 70% depleted -&gt; Irrigate 10mm</p> </li> <li><p>Otherwise -&gt; No irrigation</p> </li> </ol> In\u00a0[17]: Copied! <pre># function to return the irrigation depth to apply on next day\ndef get_depth(model):    \n    t = model._clock_struct.time_step_counter # current timestep\n    # get weather data for next 7 days\n    weather10 = model._weather[t+1:min(t+10+1,len(model._weather))]\n    # if it will rain in next 7 days\n    if sum(weather10[:,2])&gt;0:\n        # check if soil is over 70% depleted\n        if t&gt;0 and model._init_cond.depletion/model._init_cond.taw &gt; 0.7:\n            depth=10\n        else:\n            depth=0\n    else:\n        # no rain for next 10 days\n        depth=10\n\n\n    return depth\n</pre> # function to return the irrigation depth to apply on next day def get_depth(model):         t = model._clock_struct.time_step_counter # current timestep     # get weather data for next 7 days     weather10 = model._weather[t+1:min(t+10+1,len(model._weather))]     # if it will rain in next 7 days     if sum(weather10[:,2])&gt;0:         # check if soil is over 70% depleted         if t&gt;0 and model._init_cond.depletion/model._init_cond.taw &gt; 0.7:             depth=10         else:             depth=0     else:         # no rain for next 10 days         depth=10       return depth In\u00a0[18]: Copied! <pre>model._clock_struct.time_step_counter\n</pre> model._clock_struct.time_step_counter Out[18]: <pre>13280</pre> In\u00a0[19]: Copied! <pre># create model with IrrMethod= Constant depth\ncrop.Name = 'weather' # add helpfull label\n\nmodel = AquaCropModel(sim_start,sim_end,wdf,soil,crop,initial_water_content=initWC,\n                      irrigation_management=IrrigationManagement(irrigation_method=5,)) \n\nmodel._initialize()\n\nwhile model._clock_struct.model_is_finished is False:    \n    # get depth to apply\n    depth=get_depth(model)\n    \n    model._param_struct.IrrMngt.depth=depth\n\n    model.run_model(initialize_model=False)\n</pre> # create model with IrrMethod= Constant depth crop.Name = 'weather' # add helpfull label  model = AquaCropModel(sim_start,sim_end,wdf,soil,crop,initial_water_content=initWC,                       irrigation_management=IrrigationManagement(irrigation_method=5,))   model._initialize()  while model._clock_struct.model_is_finished is False:         # get depth to apply     depth=get_depth(model)          model._param_struct.IrrMngt.depth=depth      model.run_model(initialize_model=False) In\u00a0[20]: Copied! <pre>outputs.append(model._outputs.final_stats) # save results\nlabels.append('weather')\n</pre> outputs.append(model._outputs.final_stats) # save results labels.append('weather') <p>Combine results so that they can be easily visualized.</p> In\u00a0[21]: Copied! <pre>dflist=outputs\noutlist=[]\nfor i in range(len(dflist)):\n    temp = pd.DataFrame(dflist[i][['Yield (tonne/ha)','Seasonal irrigation (mm)']])\n    temp['label']=labels[i]\n    outlist.append(temp)\n\nall_outputs = pd.concat(outlist,axis=0)\n</pre> dflist=outputs outlist=[] for i in range(len(dflist)):     temp = pd.DataFrame(dflist[i][['Yield (tonne/ha)','Seasonal irrigation (mm)']])     temp['label']=labels[i]     outlist.append(temp)  all_outputs = pd.concat(outlist,axis=0) In\u00a0[22]: Copied! <pre># combine all results\nresults=pd.concat(outlist)\n</pre> # combine all results results=pd.concat(outlist) <p>Use <code>matplotlib</code> and <code>seaborn</code> to show the range of yields and total irrigation for each strategy over the simulation years.</p> In\u00a0[23]: Copied! <pre># import plotting libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# create figure consisting of 2 plots\nfig,ax=plt.subplots(2,1,figsize=(10,14))\n\n# create two box plots\nsns.boxplot(data=results,x='label',y='Yield (tonne/ha)',ax=ax[0])\nsns.boxplot(data=results,x='label',y='Seasonal irrigation (mm)',ax=ax[1])\n\n# labels and font sizes\nax[0].tick_params(labelsize=15)\nax[0].set_xlabel(' ')\nax[0].set_ylabel('Yield (t/ha)',fontsize=18)\n\nax[1].tick_params(labelsize=15)\nax[1].set_xlabel(' ')\nax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18)\n\nplt.legend(fontsize=18)\n</pre> # import plotting libraries import matplotlib.pyplot as plt import seaborn as sns  # create figure consisting of 2 plots fig,ax=plt.subplots(2,1,figsize=(10,14))  # create two box plots sns.boxplot(data=results,x='label',y='Yield (tonne/ha)',ax=ax[0]) sns.boxplot(data=results,x='label',y='Seasonal irrigation (mm)',ax=ax[1])  # labels and font sizes ax[0].tick_params(labelsize=15) ax[0].set_xlabel(' ') ax[0].set_ylabel('Yield (t/ha)',fontsize=18)  ax[1].tick_params(labelsize=15) ax[1].set_xlabel(' ') ax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18)  plt.legend(fontsize=18)  <pre>No handles with labels found to put in legend.\n</pre> Out[23]: <pre>&lt;matplotlib.legend.Legend at 0x7f0133040b50&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_2/#aquacrop-ospy-bridging-the-gap-between-research-and-practice-in-crop-water-modelling","title":"AquaCrop-OSPy: Bridging the gap between research and practice in crop-water modelling\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_2/#install-and-import-aquacrop-ospy","title":"Install and import AquaCrop-OSPy\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_2/#notebook-2-estimating-irrigation-water-demands-under-different-irrigation-strategies","title":"Notebook 2: Estimating irrigation water demands under different irrigation strategies\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_2/#appendix-a-other-types-of-irrigation-strategy","title":"Appendix A: Other types of irrigation strategy\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_3/","title":"Optimizing Irrigation","text":"<p>This series of notebooks provides users with an introduction to AquaCrop-OSPy, an open-source Python implementation of the U.N. Food and Agriculture Organization (FAO) AquaCrop model. AquaCrop-OSPy is accompanied by a series of Jupyter notebooks, which guide users interactively through a range of common applications of the model. Only basic Python experience is required, and the notebooks can easily be extended and adapted by users for their own applications and needs.</p> <p>In the previous notebook, we looked at how to simulate yields and water use for different pre-specified irrigation management practices or rules. However, what if you wanted to know which strategy would give you the maximum yield for a given amount of irrigation water use? In this notebook, we look at how optimal irrigation schedules can be identified by linking AquaCrop-OSPy with one of the many optimization modules in available in the python ecosystem.</p> <p>Our specific example focuses on optimizing soil-moisture thresholds which are commonly used both in practice and literature on optimizing irrigation decisions. During the growing season, if the soil-moisture content drops below the threshold, irrigation is applied to refill the soil profile back to field capacity subject to a maximum irrigation depth. AquaCrop-OSPy allows you to define four thresholds corresponding to four main growing periods (emergence, canopy growth, max canopy and senescence). Changing the threshold depending on crop growth stage reflects the fact that crop water requirements and drought stress responses vary over the course of the season.</p> <p>Using the optimization library <code>scipy.optimize</code> we will find sets of soil-moisture thresholds that maximize yields for a Maize crop located in Champion Nebraska. The optimization will be repeated for different water supply constraints (maximum amount of water that can be applied in a given season). The simulation will take place over 3 years (2016-2018).</p> <p>Import and install AquaCrop-OSPy</p> In\u00a0[1]: Copied! <pre># !pip install aquacrop\n\n# from google.colab import output\n# output.clear()\n</pre> # !pip install aquacrop  # from google.colab import output # output.clear() <p>If for any reason you would rather not compile the aquacrop modules ahead-of-time, you can run the following cell to run the notebook in pure python (N.B. it will run slower).</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['DEVELOPMENT'] = 'True'\n</pre> # import os # os.environ['DEVELOPMENT'] = 'True' In\u00a0[2]: Copied! <pre>from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement\nfrom aquacrop.utils import prepare_weather, get_filepath\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import fmin\n</pre> from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent, IrrigationManagement from aquacrop.utils import prepare_weather, get_filepath  import numpy as np import matplotlib.pyplot as plt from scipy.optimize import fmin In\u00a0[3]: Copied! <pre>path = get_filepath('champion_climate.txt')\nwdf = prepare_weather(path)\n</pre> path = get_filepath('champion_climate.txt') wdf = prepare_weather(path) <p>Define a function called <code>run_model</code> that creates and runs an AquaCrop model (just like in the previous notebooks), and returns the final output.</p> In\u00a0[4]: Copied! <pre>def run_model(smts,max_irr_season,year1,year2):\n    \"\"\"\n    funciton to run model and return results for given set of soil moisture targets\n    \"\"\"\n\n    maize = Crop('Maize',planting_date='05/01') # define crop\n    loam = Soil('ClayLoam') # define soil\n    init_wc = InitialWaterContent(wc_type='Pct',value=[70]) # define initial soil water conditions\n\n    irrmngt = IrrigationManagement(irrigation_method=1,SMT=smts,MaxIrrSeason=max_irr_season) # define irrigation management\n\n    # create and run model\n    model = AquaCropModel(f'{year1}/05/01',f'{year2}/10/31',wdf,loam,maize,\n                          irrigation_management=irrmngt,initial_water_content=init_wc)\n\n    model.run_model(till_termination=True)\n    return model.get_simulation_results()\n</pre> def run_model(smts,max_irr_season,year1,year2):     \"\"\"     funciton to run model and return results for given set of soil moisture targets     \"\"\"      maize = Crop('Maize',planting_date='05/01') # define crop     loam = Soil('ClayLoam') # define soil     init_wc = InitialWaterContent(wc_type='Pct',value=[70]) # define initial soil water conditions      irrmngt = IrrigationManagement(irrigation_method=1,SMT=smts,MaxIrrSeason=max_irr_season) # define irrigation management      # create and run model     model = AquaCropModel(f'{year1}/05/01',f'{year2}/10/31',wdf,loam,maize,                           irrigation_management=irrmngt,initial_water_content=init_wc)      model.run_model(till_termination=True)     return model.get_simulation_results()  In\u00a0[5]: Copied! <pre>run_model([70]*4,300,2018,2018)\n</pre> run_model([70]*4,300,2018,2018) Out[5]: Season crop Type Harvest Date (YYYY/MM/DD) Harvest Date (Step) Yield (tonne/ha) Seasonal irrigation (mm) 0 0 Maize 2018-09-10 131 14.298679 300.0 <p>Define <code>evaluate</code> will act as a reward function for the optimization library to optimize. Inside this function we run the model and return the reward (in this case the average yield).</p> In\u00a0[6]: Copied! <pre>import numpy as np # import numpy library\n\ndef evaluate(smts,max_irr_season,test=False):\n    \"\"\"\n    funciton to run model and calculate reward (yield) for given set of soil moisture targets\n    \"\"\"\n    # run model\n    out = run_model(smts,max_irr_season,year1=2016,year2=2018)\n    # get yields and total irrigation\n    yld = out['Yield (tonne/ha)'].mean()\n    tirr = out['Seasonal irrigation (mm)'].mean()\n\n    reward=yld\n\n    # return either the negative reward (for the optimization)\n    # or the yield and total irrigation (for analysis)\n    if test:\n        return yld,tirr,reward\n    else:\n        return -reward\n</pre> import numpy as np # import numpy library  def evaluate(smts,max_irr_season,test=False):     \"\"\"     funciton to run model and calculate reward (yield) for given set of soil moisture targets     \"\"\"     # run model     out = run_model(smts,max_irr_season,year1=2016,year2=2018)     # get yields and total irrigation     yld = out['Yield (tonne/ha)'].mean()     tirr = out['Seasonal irrigation (mm)'].mean()      reward=yld      # return either the negative reward (for the optimization)     # or the yield and total irrigation (for analysis)     if test:         return yld,tirr,reward     else:         return -reward  In\u00a0[7]: Copied! <pre>evaluate([70]*4,300)\n</pre> evaluate([70]*4,300) Out[7]: <pre>-14.14377270193747</pre> <p>Define <code>get_starting_point</code> that chooses a set of random irrigation strategies and evaluates them to give us a good starting point for our optimization. (Since we are only using a local minimization function this will help get a good result)</p> In\u00a0[8]: Copied! <pre>def get_starting_point(num_smts,max_irr_season,num_searches):\n    \"\"\"\n    find good starting threshold(s) for optimization\n    \"\"\"\n\n    # get random SMT's\n    x0list = np.random.rand(num_searches,num_smts)*100\n    rlist=[]\n    # evaluate random SMT's\n    for xtest in x0list:\n        r = evaluate(xtest,max_irr_season,)\n        rlist.append(r)\n\n    # save best SMT\n    x0=x0list[np.argmin(rlist)]\n    \n    return x0\n</pre> def get_starting_point(num_smts,max_irr_season,num_searches):     \"\"\"     find good starting threshold(s) for optimization     \"\"\"      # get random SMT's     x0list = np.random.rand(num_searches,num_smts)*100     rlist=[]     # evaluate random SMT's     for xtest in x0list:         r = evaluate(xtest,max_irr_season,)         rlist.append(r)      # save best SMT     x0=x0list[np.argmin(rlist)]          return x0 In\u00a0[9]: Copied! <pre>get_starting_point(4,300,10)\n</pre> get_starting_point(4,300,10) Out[9]: <pre>array([59.91075266, 82.0856109 , 76.00348259, 84.25790193])</pre> <p>Define <code>optimize</code> that uses the <code>scipy.optimize.fmin</code> optimization package to find yield maximizing irrigation strategies for a maximum seasonal irrigation limit.</p> In\u00a0[10]: Copied! <pre>def optimize(num_smts,max_irr_season,num_searches=100):\n    \"\"\" \n    optimize thresholds to be profit maximising\n    \"\"\"\n    # get starting optimization strategy\n    x0=get_starting_point(num_smts,max_irr_season,num_searches)\n    # run optimization\n    res = fmin(evaluate, x0,disp=0,args=(max_irr_season,))\n    # reshape array\n    smts= res.squeeze()\n    # evaluate optimal strategy\n    return smts\n</pre> def optimize(num_smts,max_irr_season,num_searches=100):     \"\"\"      optimize thresholds to be profit maximising     \"\"\"     # get starting optimization strategy     x0=get_starting_point(num_smts,max_irr_season,num_searches)     # run optimization     res = fmin(evaluate, x0,disp=0,args=(max_irr_season,))     # reshape array     smts= res.squeeze()     # evaluate optimal strategy     return smts In\u00a0[11]: Copied! <pre>smts=optimize(4,300)\n</pre> smts=optimize(4,300) In\u00a0[12]: Copied! <pre>evaluate(smts,300,True)\n</pre> evaluate(smts,300,True) Out[12]: <pre>(14.217296560597573, 283.3333333333333, 14.217296560597573)</pre> <p>For a range of maximum seasonal irrigation limits (0-450mm), find the yield maximizing irrigation schedule.</p> In\u00a0[1]: Copied! <pre>from tqdm.autonotebook import tqdm # progress bar\n\nopt_smts=[]\nyld_list=[]\ntirr_list=[]\nfor max_irr in tqdm(range(0,500,50)):\n    \n\n    # find optimal thresholds and save to list\n    smts=optimize(4,max_irr)\n    opt_smts.append(smts)\n\n    # save the optimal yield and total irrigation\n    yld,tirr,_=evaluate(smts,max_irr,True)\n    yld_list.append(yld)\n    tirr_list.append(tirr)\n</pre> from tqdm.autonotebook import tqdm # progress bar  opt_smts=[] yld_list=[] tirr_list=[] for max_irr in tqdm(range(0,500,50)):           # find optimal thresholds and save to list     smts=optimize(4,max_irr)     opt_smts.append(smts)      # save the optimal yield and total irrigation     yld,tirr,_=evaluate(smts,max_irr,True)     yld_list.append(yld)     tirr_list.append(tirr) <pre>\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\nc:\\Users\\s10034cb\\Dropbox (The University of Manchester)\\Manchester Postdoc\\aquacrop\\docs\\notebooks\\AquaCrop_OSPy_Notebook_3.ipynb Cell 23 line 6\n      &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=3'&gt;4&lt;/a&gt; yld_list=[]\n      &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=4'&gt;5&lt;/a&gt; tirr_list=[]\n----&gt; &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=5'&gt;6&lt;/a&gt; for max_irr in tqdm(range(0,500,50)):\n      &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=6'&gt;7&lt;/a&gt;     \n      &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=7'&gt;8&lt;/a&gt; \n      &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=8'&gt;9&lt;/a&gt;     # find optimal thresholds and save to list\n     &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=9'&gt;10&lt;/a&gt;     smts=optimize(4,max_irr)\n     &lt;a href='vscode-notebook-cell:/c%3A/Users/s10034cb/Dropbox%20%28The%20University%20of%20Manchester%29/Manchester%20Postdoc/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_3.ipynb#X31sZmlsZQ%3D%3D?line=10'&gt;11&lt;/a&gt;     opt_smts.append(smts)\n\nFile c:\\Users\\s10034cb\\AppData\\Local\\anaconda3\\envs\\aquacrop\\lib\\site-packages\\tqdm\\notebook.py:233, in tqdm_notebook.__init__(self, *args, **kwargs)\n    231 unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1\n    232 total = self.total * unit_scale if self.total else self.total\n--&gt; 233 self.container = self.status_printer(self.fp, total, self.desc, self.ncols)\n    234 self.container.pbar = proxy(self)\n    235 self.displayed = False\n\nFile c:\\Users\\s10034cb\\AppData\\Local\\anaconda3\\envs\\aquacrop\\lib\\site-packages\\tqdm\\notebook.py:108, in tqdm_notebook.status_printer(_, total, desc, ncols)\n     99 # Fallback to text bar if there's no total\n    100 # DEPRECATED: replaced with an 'info' style bar\n    101 # if not total:\n   (...)\n    105 \n    106 # Prepare IPython progress bar\n    107 if IProgress is None:  # #187 #451 #558 #872\n--&gt; 108     raise ImportError(WARN_NOIPYW)\n    109 if total:\n    110     pbar = IProgress(min=0, max=total)\n\nImportError: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html</pre> <p>Visualize the optimal yield and total irrigation, creating a crop-water production function.</p> In\u00a0[14]: Copied! <pre># create plot\nfig,ax=plt.subplots(1,1,figsize=(13,8))\n\n# plot results\nax.scatter(tirr_list,yld_list)\nax.plot(tirr_list,yld_list)\n\n# labels\nax.set_xlabel('Total Irrigation (ha-mm)',fontsize=18)\nax.set_ylabel('Yield (tonne/ha)',fontsize=18)\nax.set_xlim([-20,600])\nax.set_ylim([2,15.5])\n\n# annotate with optimal thresholds\nbbox = dict(boxstyle=\"round\",fc=\"1\")\noffset = [15,15,15, 15,15,-125,-100,  -5, 10,10]\nyoffset= [0,-5,-10,-15, -15,  0,  10,15, -20,10]\nfor i,smt in enumerate(opt_smts):\n    smt=smt.clip(0,100)\n    ax.annotate('(%.0f, %.0f, %.0f, %.0f)'%(smt[0],smt[1],smt[2],smt[3]),\n                (tirr_list[i], yld_list[i]), xytext=(offset[i], yoffset[i]), textcoords='offset points',\n                bbox=bbox,fontsize=12)\n</pre> # create plot fig,ax=plt.subplots(1,1,figsize=(13,8))  # plot results ax.scatter(tirr_list,yld_list) ax.plot(tirr_list,yld_list)  # labels ax.set_xlabel('Total Irrigation (ha-mm)',fontsize=18) ax.set_ylabel('Yield (tonne/ha)',fontsize=18) ax.set_xlim([-20,600]) ax.set_ylim([2,15.5])  # annotate with optimal thresholds bbox = dict(boxstyle=\"round\",fc=\"1\") offset = [15,15,15, 15,15,-125,-100,  -5, 10,10] yoffset= [0,-5,-10,-15, -15,  0,  10,15, -20,10] for i,smt in enumerate(opt_smts):     smt=smt.clip(0,100)     ax.annotate('(%.0f, %.0f, %.0f, %.0f)'%(smt[0],smt[1],smt[2],smt[3]),                 (tirr_list[i], yld_list[i]), xytext=(offset[i], yoffset[i]), textcoords='offset points',                 bbox=bbox,fontsize=12)   <p>Note that fmin is a local optimizer and so optimal soil-moisture thresholds will vary over multiple repetitions</p> In\u00a0[15]: Copied! <pre># import multiprocessing library\nfrom multiprocessing import Pool\n\n# time library so we can check the speed up\nfrom time import time\n\n# define funciton to parallelize\ndef func(max_irr):\n\n    # find optimal smts\n    smts=optimize(4,max_irr)\n\n    # return the optimal yield, total irrigaiton and thresholds\n    yld,tirr,_=evaluate(smts,max_irr,True)\n    print(f\"finished max_irr = {max_irr} at {round(time()-start)} seconds\")\n    return yld,tirr,smts\n</pre> # import multiprocessing library from multiprocessing import Pool  # time library so we can check the speed up from time import time  # define funciton to parallelize def func(max_irr):      # find optimal smts     smts=optimize(4,max_irr)      # return the optimal yield, total irrigaiton and thresholds     yld,tirr,_=evaluate(smts,max_irr,True)     print(f\"finished max_irr = {max_irr} at {round(time()-start)} seconds\")     return yld,tirr,smts  <p>Multi processing in python can be done using the <code>Pool</code> object. The code below create a <code>Pool</code> object, passing in the number of CPU cores that you want to parallelize over. Then use <code>p.map</code> to evaluate the function <code>func</code> for each input given in the list.</p> In\u00a0[16]: Copied! <pre>start = time() # save start time \nwith Pool(8) as p:\n    results = p.map(func, list(range(0,500,50)))\n</pre> start = time() # save start time  with Pool(8) as p:     results = p.map(func, list(range(0,500,50))) <pre>finished max_irr = 0 at 22 seconds\nfinished max_irr = 50 at 25 seconds\nfinished max_irr = 150 at 26 seconds\nfinished max_irr = 350 at 27 seconds\nfinished max_irr = 100 at 27 seconds\nfinished max_irr = 250 at 28 seconds\nfinished max_irr = 200 at 28 seconds\nfinished max_irr = 300 at 30 seconds\nfinished max_irr = 400 at 48 seconds\nfinished max_irr = 450 at 51 seconds\n</pre> <p>This approach in Colab does not give us a massive speed up, however this approach can be a big help if more CPU cores are available. Combine results for visualization.</p> In\u00a0[17]: Copied! <pre>parr_opt_smts=[]\nparr_yld_list=[]\nparr_tirr_list=[]\nfor i in range(len(results)):\n    parr_yld_list.append(results[i][0])\n    parr_tirr_list.append(results[i][1])\n    parr_opt_smts.append(results[i][2])\n</pre> parr_opt_smts=[] parr_yld_list=[] parr_tirr_list=[] for i in range(len(results)):     parr_yld_list.append(results[i][0])     parr_tirr_list.append(results[i][1])     parr_opt_smts.append(results[i][2]) <p>Plot crop-water production function.</p> In\u00a0[18]: Copied! <pre>fig,ax=plt.subplots(1,1,figsize=(10,7))\n\nax.scatter(parr_tirr_list,parr_yld_list)\nax.plot(parr_tirr_list,parr_yld_list)\n\nax.set_xlabel('Total Irrigation (ha-mm)')\nax.set_ylabel('Yield (tonne/ha)',fontsize=18)\n</pre> fig,ax=plt.subplots(1,1,figsize=(10,7))  ax.scatter(parr_tirr_list,parr_yld_list) ax.plot(parr_tirr_list,parr_yld_list)  ax.set_xlabel('Total Irrigation (ha-mm)') ax.set_ylabel('Yield (tonne/ha)',fontsize=18) Out[18]: <pre>Text(0, 0.5, 'Yield (tonne/ha)')</pre>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_3/#aquacrop-ospy-bridging-the-gap-between-research-and-practice-in-crop-water-modelling","title":"AquaCrop-OSPy: Bridging the gap between research and practice in crop-water modelling\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_3/#notebook-3-developing-and-optimizing-irrigation-stratgeies","title":"Notebook 3: Developing and optimizing irrigation stratgeies\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_3/#appendix-parrallel","title":"Appendix: Parrallel\u00b6","text":"<p>Can also speed things up with a parallel approach. Though for Colab notebooks there are only 2 CPUs so we are not expecting a massive speed up. But this kind of approach can be useful when more CPUs are available either locally or in cloud computing infestructure.</p>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_4/","title":"Climate Change Impacts","text":"<p>This series of notebooks provides users with an introduction to AquaCrop-OSPy, an open-source Python implementation of the U.N. Food and Agriculture Organization (FAO) AquaCrop model. AquaCrop-OSPy is accompanied by a series of Jupyter notebooks, which guide users interactively through a range of common applications of the model. Only basic Python experience is required, and the notebooks can easily be extended and adapted by users for their own applications and needs.</p> <p>This notebook series consists of four parts:</p> <ol> <li>Running an AquaCrop-OSPy model</li> <li>Estimation of irrigation water demands</li> <li>Optimisation of irrigation management strategies</li> <li>Projection of climate change impacts</li> </ol> <p>In this notebook, we show how AquaCrop-OSPy can be used to simulate impacts of climate change on crop production and irrigation water demands. Climate change is a major driver of production and water scarcity for agriculture globally, and data generated can thus play an important role in designing effective adaptation measures to support farmers and rural economies.</p> <p>The example presented here focuses on a case study of maize production in the central United States. Baseline data from this region (1982-2018) is used to generate future climate projections using the LARS weather generator. Projections are generated for the periods (2021-2040, 2041-2060, 2061-2080) and for emissions scenarios RCP4.5 and RCP8.5 based on outputs from the EC-EARTH climate model.</p> <p>First install and import AquaCrop-OSPy</p> In\u00a0[1]: Copied! <pre># !pip install aquacrop tqdm matplotlib seaborn\n\n# from google.colab import output\n# output.clear()\n</pre> # !pip install aquacrop tqdm matplotlib seaborn  # from google.colab import output # output.clear() <p>If for any reason you would rather not compile the aquacrop modules ahead-of-time, you can run the following cell to run the notebook in pure python (N.B. it will run slower).</p> In\u00a0[\u00a0]: Copied! <pre># import os\n# os.environ['DEVELOPMENT'] = 'True'\n</pre> # import os # os.environ['DEVELOPMENT'] = 'True' In\u00a0[27]: Copied! <pre>from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent,CO2, IrrigationManagement\nfrom aquacrop.utils import get_filepath, prepare_lars_weather,select_lars_wdf\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom tqdm.autonotebook import tqdm # progress bar\n</pre> from aquacrop import AquaCropModel, Soil, Crop, InitialWaterContent,CO2, IrrigationManagement from aquacrop.utils import get_filepath, prepare_lars_weather,select_lars_wdf  import pandas as pd import matplotlib.pyplot as plt import seaborn as sns from tqdm.autonotebook import tqdm # progress bar  <p>Given the popularity of using LARS-WG for this type of analyis, AquaCrop-OSPy contains a built in function for reading LARS generated outputs. These outputs consist of daily climate projections of precipitation, minimum and maximum temperature and solar radiation. Using the Hargreaves ETo method these values were used to estimate the reference evapotranspiration, resulting in a weather DataFrame in the format required by AquaCrop-OSPy.</p> <p>The cell below imports the baseline data from Champion, Nebraska</p> In\u00a0[11]: Copied! <pre># get baseline lars data\nlars_fp=get_filepath('CP.dat')\nlars_base=prepare_lars_weather(lars_fp,-1,False,order=['year', 'jday', 'maxTemp', 'minTemp', 'precip','rad',])\n</pre> # get baseline lars data lars_fp=get_filepath('CP.dat') lars_base=prepare_lars_weather(lars_fp,-1,False,order=['year', 'jday', 'maxTemp', 'minTemp', 'precip','rad',]) In\u00a0[12]: Copied! <pre>lars_base.head()\n</pre> lars_base.head() Out[12]: MinTemp MaxTemp Precipitation ReferenceET Date 0 3.89 17.22 0.00 1.868710 1981-05-20 1 6.67 21.67 0.00 2.665948 1981-05-21 2 5.56 25.00 2.01 3.420034 1981-05-22 3 5.56 19.44 0.00 2.440758 1981-05-23 4 5.56 24.44 0.00 3.520489 1981-05-24 <p>For each combination of climate scenario and projection period, read in climate data and save the weather DataFrame.</p> In\u00a0[13]: Copied! <pre>rcp_list = [45,85]\nyr_list = [2030,2050,2070]\nyr_range_list = ['2021-2040','2041-2060','2061-2080']\n\nlabel_list=[]\nwdf_list = []\nall_year_list=[]\nfor yr,yr_range in zip(yr_list,yr_range_list):\n    for rcp in rcp_list:\n        wdf =prepare_lars_weather(get_filepath(f'CP_EC-EARTH[CP,RCP{rcp},{yr_range}]WG.dat'),\n                              yr,True,[\"simyear\",\"jday\",\"minTemp\",\"maxTemp\",\"precip\",\"rad\"])\n        wdf_list.append(wdf)\n        label_list.append(f'RCP{rcp/10},\\n{yr_range}')\n        all_year_list.append(yr)\n</pre> rcp_list = [45,85] yr_list = [2030,2050,2070] yr_range_list = ['2021-2040','2041-2060','2061-2080']  label_list=[] wdf_list = [] all_year_list=[] for yr,yr_range in zip(yr_list,yr_range_list):     for rcp in rcp_list:         wdf =prepare_lars_weather(get_filepath(f'CP_EC-EARTH[CP,RCP{rcp},{yr_range}]WG.dat'),                               yr,True,[\"simyear\",\"jday\",\"minTemp\",\"maxTemp\",\"precip\",\"rad\"])         wdf_list.append(wdf)         label_list.append(f'RCP{rcp/10},\\n{yr_range}')         all_year_list.append(yr) In\u00a0[14]: Copied! <pre>label_list\n</pre> label_list Out[14]: <pre>['RCP4.5,\\n2021-2040',\n 'RCP8.5,\\n2021-2040',\n 'RCP4.5,\\n2041-2060',\n 'RCP8.5,\\n2041-2060',\n 'RCP4.5,\\n2061-2080',\n 'RCP8.5,\\n2061-2080']</pre> In\u00a0[15]: Copied! <pre># co2 concentrations for the scenarios listed in order\nco2_list = [435,449,487,541,524,677]\n</pre> # co2 concentrations for the scenarios listed in order co2_list = [435,449,487,541,524,677] <p>The LARS generated output files in this example comprise of 100 years of daily weather data (denoted by the 'simyear' column). To select any one of these years, use the <code>select_lars_wdf</code> function.</p> In\u00a0[16]: Copied! <pre>wdf_list[0].head()\n</pre> wdf_list[0].head() Out[16]: simyear MinTemp MaxTemp Precipitation ReferenceET Date 0 1 -1.3 -0.4 0.0 0.113671 2030-01-01 1 1 -10.2 19.7 0.0 3.438354 2030-01-02 2 1 -8.2 9.0 0.0 1.568464 2030-01-03 3 1 -5.0 17.3 0.0 2.585045 2030-01-04 4 1 -7.6 0.0 0.0 0.573125 2030-01-05 In\u00a0[17]: Copied! <pre>select_lars_wdf(wdf_list[0],simyear=3).head()\n</pre> select_lars_wdf(wdf_list[0],simyear=3).head() Out[17]: MinTemp MaxTemp Precipitation ReferenceET Date 0 -12.3 2.5 0.0 1.030637 2030-01-01 1 -9.0 -6.0 0.0 0.171382 2030-01-02 2 -8.4 11.5 0.0 1.889522 2030-01-03 3 -11.6 -6.6 0.0 0.291564 2030-01-04 4 -14.7 7.7 0.0 1.671600 2030-01-05 <p>Now that all the climate data is ready, we can define our crop, soil, initial water content and irrigation management. In this example we will use the AquaCrop default Maize crop in calendar day mode. The reason for using calendar day mode is so that the growing season will be the same length in each scenario.</p> <p>We choose a Clay loam soil starting at Field Capacity, and an irrigation policy that irrigates if the soil drops below 70% total available water (essentially meeting full crop-water requirements).</p> In\u00a0[18]: Copied! <pre>crop=Crop('Maize',planting_date='05/01',\n               CalendarType=1,Emergence = 6,Senescence=107,\n               MaxRooting=108,Maturity=132,HIstart=66,\n               Flowering=13,YldForm=61,CDC=0.117,CGC=0.163)\n          \nsoil=Soil('ClayLoam')\ninit_wc = InitialWaterContent() # default is field capacity\nirrmngt=IrrigationManagement(1,SMT=[70]*4)\n</pre> crop=Crop('Maize',planting_date='05/01',                CalendarType=1,Emergence = 6,Senescence=107,                MaxRooting=108,Maturity=132,HIstart=66,                Flowering=13,YldForm=61,CDC=0.117,CGC=0.163)            soil=Soil('ClayLoam') init_wc = InitialWaterContent() # default is field capacity irrmngt=IrrigationManagement(1,SMT=[70]*4) <p>Run the simulation for the baseline period and save the yields and total irrigation.</p> In\u00a0[19]: Copied! <pre>#run for baseline scenario\nmodel=AquaCropModel('1982/05/01','2018/10/30',lars_base,soil,crop,\n                    init_wc,irrigation_management=irrmngt)\n\nmodel.run_model(till_termination=True)\n</pre> #run for baseline scenario model=AquaCropModel('1982/05/01','2018/10/30',lars_base,soil,crop,                     init_wc,irrigation_management=irrmngt)  model.run_model(till_termination=True) Out[19]: <pre>True</pre> In\u00a0[20]: Copied! <pre>baseline_yields = list(model.get_simulation_results()['Yield (tonne/ha)'].values)\nbaseline_tirrs = list(model.get_simulation_results()['Seasonal irrigation (mm)'].values)\nbaseline_labels = ['Baseline']*len(baseline_tirrs)\n</pre> baseline_yields = list(model.get_simulation_results()['Yield (tonne/ha)'].values) baseline_tirrs = list(model.get_simulation_results()['Seasonal irrigation (mm)'].values) baseline_labels = ['Baseline']*len(baseline_tirrs) <p>Define <code>run_gen_model</code> function that runs AquaCrop-OSPy for all 100 generated years of a climate scenario and future period (e.g. 2050 at RCP4.5), saving the yields and total irrigation.</p> In\u00a0[30]: Copied! <pre>def run_gen_model(all_wdf,co2conc,year):\n    gen_yields=[]\n    gen_tirrs=[]\n    for i in range(100):\n        wdf = select_lars_wdf(all_wdf,i+1)\n\n        co2 = CO2(constant_conc=True)\n        co2.current_concentration = co2conc\n        \n        model=AquaCropModel(f'{year}/05/01',f'{year}/10/30',wdf,soil,crop,\n                            InitialWaterContent(),irrigation_management=irrmngt,co2_concentration=co2)\n\n        model.run_model(till_termination=True)\n\n        gen_yields.append(model.get_simulation_results()['Yield (tonne/ha)'].mean())\n        gen_tirrs.append(model.get_simulation_results()['Seasonal irrigation (mm)'].mean())\n\n    return gen_yields,gen_tirrs\n</pre> def run_gen_model(all_wdf,co2conc,year):     gen_yields=[]     gen_tirrs=[]     for i in range(100):         wdf = select_lars_wdf(all_wdf,i+1)          co2 = CO2(constant_conc=True)         co2.current_concentration = co2conc                  model=AquaCropModel(f'{year}/05/01',f'{year}/10/30',wdf,soil,crop,                             InitialWaterContent(),irrigation_management=irrmngt,co2_concentration=co2)          model.run_model(till_termination=True)          gen_yields.append(model.get_simulation_results()['Yield (tonne/ha)'].mean())         gen_tirrs.append(model.get_simulation_results()['Seasonal irrigation (mm)'].mean())      return gen_yields,gen_tirrs <p>For each combination of climate scenario and projection period, run AquaCrop-OSPy and save results.</p> In\u00a0[31]: Copied! <pre>all_ylds = []\nall_tirrs = []\nall_labels = []\nfor i in (range(6)):\n    year = all_year_list[i]\n    wdf = wdf_list[i]\n    co2 = co2_list[i]\n    label=label_list[i]\n\n    yld_list,tirr_list = run_gen_model(wdf,co2,year)\n\n    all_ylds.extend(yld_list)\n    all_tirrs.extend(tirr_list)\n    all_labels.extend([label]*len(yld_list))\n</pre> all_ylds = [] all_tirrs = [] all_labels = [] for i in (range(6)):     year = all_year_list[i]     wdf = wdf_list[i]     co2 = co2_list[i]     label=label_list[i]      yld_list,tirr_list = run_gen_model(wdf,co2,year)      all_ylds.extend(yld_list)     all_tirrs.extend(tirr_list)     all_labels.extend([label]*len(yld_list))  <p>Combine projection results with baseline.</p> In\u00a0[32]: Copied! <pre>all_ylds = baseline_yields+all_ylds\nall_tirrs = baseline_tirrs+all_tirrs\nall_labels = baseline_labels+all_labels\n</pre> all_ylds = baseline_yields+all_ylds all_tirrs = baseline_tirrs+all_tirrs all_labels = baseline_labels+all_labels In\u00a0[33]: Copied! <pre>import pandas as pd\n\ndf = pd.DataFrame([all_ylds,all_tirrs,all_labels]).T\ndf.columns = ['Yield','Tirr','Label']\ndf.head()\n</pre> import pandas as pd  df = pd.DataFrame([all_ylds,all_tirrs,all_labels]).T df.columns = ['Yield','Tirr','Label'] df.head() Out[33]: Yield Tirr Label 0 12.641796 50.0 Baseline 1 12.88586 75.0 Baseline 2 13.601316 175.0 Baseline 3 13.251319 175.0 Baseline 4 13.747646 90.65583 Baseline <p>Visualize results for all projections and baselines.</p> In\u00a0[34]: Copied! <pre># plotting libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# create figure \nfig,ax=plt.subplots(2,1,figsize=(12,14))\n\n# create box plots\nsns.boxplot(data=df,x='Label',y='Yield',ax=ax[0])\nsns.boxplot(data=df,x='Label',y='Tirr',ax=ax[1])\n\n# labels and fontsize\n\nax[0].tick_params(labelsize=15)\nax[0].set_xlabel(' ')\nax[0].set_ylabel('Yield (t/ha)',fontsize=18)\n\nax[1].tick_params(labelsize=15)\nax[1].set_xlabel(' ')\nax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18)\n</pre> # plotting libraries import matplotlib.pyplot as plt import seaborn as sns  # create figure  fig,ax=plt.subplots(2,1,figsize=(12,14))  # create box plots sns.boxplot(data=df,x='Label',y='Yield',ax=ax[0]) sns.boxplot(data=df,x='Label',y='Tirr',ax=ax[1])  # labels and fontsize  ax[0].tick_params(labelsize=15) ax[0].set_xlabel(' ') ax[0].set_ylabel('Yield (t/ha)',fontsize=18)  ax[1].tick_params(labelsize=15) ax[1].set_xlabel(' ') ax[1].set_ylabel('Total Irrigation (ha-mm)',fontsize=18) Out[34]: <pre>Text(0, 0.5, 'Total Irrigation (ha-mm)')</pre> In\u00a0[35]: Copied! <pre>all_precip = []\nall_et = []\nall_new_labels = []\nfor year in range(1982,2019):\n    #run for baseline scenario\n    wdf = lars_base[lars_base.Date&gt;f'{year}-05-01']\n    wdf = wdf[wdf.Date&lt;f'{year}-10-31']\n\n    all_precip.extend([wdf.Precipitation.mean()])\n    all_et.extend([wdf.ReferenceET.mean()])\n    all_new_labels.extend(['baseline'])\n</pre> all_precip = [] all_et = [] all_new_labels = [] for year in range(1982,2019):     #run for baseline scenario     wdf = lars_base[lars_base.Date&gt;f'{year}-05-01']     wdf = wdf[wdf.Date In\u00a0[36]: Copied! <pre>for i in range(6):\n\n    year = all_year_list[i]\n    wdf = wdf_list[i]\n    co2 = co2_list[i]\n    label=label_list[i]\n\n    wdf = wdf[wdf.Date&gt;f'{year}-05-01']\n    wdf = wdf[wdf.Date&lt;f'{year}-10-31']\n\n    #print(wdf.ReferenceET.mean())\n\n    precip_list = list(wdf.groupby('simyear').mean().Precipitation.values)\n    et_list = list(wdf.groupby('simyear').mean().ReferenceET.values)\n\n\n    all_precip.extend(precip_list)\n    all_et.extend(et_list)\n    all_new_labels.extend([label]*len(et_list))\n</pre> for i in range(6):      year = all_year_list[i]     wdf = wdf_list[i]     co2 = co2_list[i]     label=label_list[i]      wdf = wdf[wdf.Date&gt;f'{year}-05-01']     wdf = wdf[wdf.Date <pre>\n---------------------------------------------------------------------------\nImportError                               Traceback (most recent call last)\n/home/mbyx3tk2/acdev/jul5/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_4.ipynb Cell 37' in &lt;cell line: 4&gt;()\n      &lt;a href='vscode-notebook-cell:/home/mbyx3tk2/acdev/jul5/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_4.ipynb#ch0000035?line=0'&gt;1&lt;/a&gt; from tqdm.notebook import tqdm # progress bar\n----&gt; &lt;a href='vscode-notebook-cell:/home/mbyx3tk2/acdev/jul5/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_4.ipynb#ch0000035?line=3'&gt;4&lt;/a&gt; for i in tqdm(range(6)):\n      &lt;a href='vscode-notebook-cell:/home/mbyx3tk2/acdev/jul5/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_4.ipynb#ch0000035?line=5'&gt;6&lt;/a&gt;     year = all_year_list[i]\n      &lt;a href='vscode-notebook-cell:/home/mbyx3tk2/acdev/jul5/aquacrop/docs/notebooks/AquaCrop_OSPy_Notebook_4.ipynb#ch0000035?line=6'&gt;7&lt;/a&gt;     wdf = wdf_list[i]\n\nFile ~/actom/lib/python3.8/site-packages/tqdm/notebook.py:242, in tqdm_notebook.__init__(self, *args, **kwargs)\n    240 unit_scale = 1 if self.unit_scale is True else self.unit_scale or 1\n    241 total = self.total * unit_scale if self.total else self.total\n--&gt; 242 self.container = self.status_printer(self.fp, total, self.desc, self.ncols)\n    243 self.container.pbar = proxy(self)\n    244 self.displayed = False\n\nFile ~/actom/lib/python3.8/site-packages/tqdm/notebook.py:118, in tqdm_notebook.status_printer(_, total, desc, ncols)\n    109 # Fallback to text bar if there's no total\n    110 # DEPRECATED: replaced with an 'info' style bar\n    111 # if not total:\n   (...)\n    115 \n    116 # Prepare IPython progress bar\n    117 if IProgress is None:  # #187 #451 #558 #872\n--&gt; 118     raise ImportError(WARN_NOIPYW)\n    119 if total:\n    120     pbar = IProgress(min=0, max=total)\n\nImportError: IProgress not found. Please update jupyter and ipywidgets. See https://ipywidgets.readthedocs.io/en/stable/user_install.html</pre> In\u00a0[\u00a0]: Copied! <pre>import pandas as pd\n\ndf = pd.DataFrame([all_precip,all_et,all_new_labels]).T\ndf.columns = ['precip','et','Label']\ndf.head()\n</pre> import pandas as pd  df = pd.DataFrame([all_precip,all_et,all_new_labels]).T df.columns = ['precip','et','Label'] df.head() precip et Label 0 2.043242 2.956046 baseline 1 1.173352 3.073606 baseline 2 0.894066 3.21152 baseline 3 1.567473 3.21065 baseline 4 2.312967 3.272438 baseline In\u00a0[\u00a0]: Copied! <pre># plotting libraries\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# create figure \nfig,ax=plt.subplots(2,1,figsize=(12,14))\n\n# create box plots\nsns.boxplot(data=df,x='Label',y='precip',ax=ax[0])\nsns.boxplot(data=df,x='Label',y='et',ax=ax[1])\n\n# labels and fontsize\n\nax[0].tick_params(labelsize=15)\nax[0].set_xlabel(' ')\nax[0].set_ylabel('Precipitation (mm/ha)',fontsize=18)\n\nax[1].tick_params(labelsize=15)\nax[1].set_xlabel(' ')\nax[1].set_ylabel('ETo (mm/ha)',fontsize=18)\n</pre> # plotting libraries import matplotlib.pyplot as plt import seaborn as sns  # create figure  fig,ax=plt.subplots(2,1,figsize=(12,14))  # create box plots sns.boxplot(data=df,x='Label',y='precip',ax=ax[0]) sns.boxplot(data=df,x='Label',y='et',ax=ax[1])  # labels and fontsize  ax[0].tick_params(labelsize=15) ax[0].set_xlabel(' ') ax[0].set_ylabel('Precipitation (mm/ha)',fontsize=18)  ax[1].tick_params(labelsize=15) ax[1].set_xlabel(' ') ax[1].set_ylabel('ETo (mm/ha)',fontsize=18) <pre>Text(0, 0.5, 'ETo (mm/ha)')</pre>"},{"location":"notebooks/AquaCrop_OSPy_Notebook_4/#aquacrop-ospy-bridging-the-gap-between-research-and-practice-in-crop-water-modelling","title":"AquaCrop-OSPy: Bridging the gap between research and practice in crop-water modelling\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_4/#notebook-4-irrigation-demands-under-different-climate-change-scenarios","title":"Notebook 4: Irrigation demands under different climate change scenarios\u00b6","text":""},{"location":"notebooks/AquaCrop_OSPy_Notebook_4/#appendix-precipitation-and-et-changes","title":"Appendix: Precipitation and ET changes\u00b6","text":""}]}